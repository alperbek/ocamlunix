<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.01">
<link rel="stylesheet" type="text/css" href="ocamlunix.css">
<title>Classical inter-process communication: pipes</title>
</head>
<body>
<a href="signals.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="sockets.html"><img src="next_motif.gif" alt="Next"></a>
<hr>
<h1 class="chapter" id="sec99"> 5  Classical inter-process communication: pipes</h1>
<p>So far, we have learned how to manage processes and how they can communicate
with the environment by using files. In the remainder of the
course we see how processes running in parallel can cooperate by
communicating among themselves.</p>
<h2 class="section" id="sec100">5.1  Pipes</h2>
<p>Regular files are not a satisfactory communication medium for processes
running in parallel. Take for example a reader/writer situation in
which one process writes data and the other reads them. If a file is used
as the communication medium, the reader can detect that the file
does not grow any more (<code>read</code> returns zero), but it does not know
whether the writer is finished or simply busy computing
more data. Moreover, the file keeps track of all the data transmitted,
requiring needless disk space.</p><p>Pipes provide a mechanism suitable for this kind of communication. A
pipe is made of two file descriptors. The first one
represents the pipe’s output. The second one represents
the pipe’s input. Pipes are created by the system call
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/pipe.html"><span class="c001">pipe</span></a><a id="hevea_default98"></a>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALpipe">pipe</a> : unit -&gt; file_descr * file_descr</div><p>The call returns a pair <code>(fd_in, fd_out)</code> where <code>fd_in</code> is a
file descriptor open in <em>read mode</em> on the pipe’s output and
<code>fd_out</code> is file descriptor open in <em>write mode</em> on the pipe’s
input. The pipe itself is an internal object of the kernel that can
only be accessed via these two descriptors. In particular, it has no
name in the file system.</p><div class="image"><img src="ocamlunix-image6.png" width="60%"></div><p>A pipe behaves like a queue (<em>first-in, first-out</em>). The first
thing written to the pipe is the first thing read from the pipe.
Writes (calls to <span class="c001">write</span><a id="hevea_default99"></a> on the pipe’s input
descriptor) fill the pipe and block when the pipe is full. They block
until another process reads enough data at the other end of the pipe
and return when all the data given to <code>write</code> have been
transmitted. Reads (calls to <span class="c001">read</span><a id="hevea_default100"></a> on the pipe’s output
descriptor) drain the pipe. If the pipe is empty, a call to <code>read</code>
blocks until at least a byte is written at the other end. It then
returns immediately without waiting for the number of bytes requested
by <code>read</code> to be available.</p><p>Pipes are useless if they are written and read by the same process
(such a process will likely block forever on a substantial write or on
a read on the empty pipe). Hence they are usually read and written by
different processes. Since a pipe has no name, one of these processes
must be created by forking the process that created the pipe. Indeed,
the two file descriptors of the pipe, like any other file descriptors,
are duplicated by the call to <span class="c001">fork</span><a id="hevea_default101"></a> and thus refer to the
same pipe in the parent and the child process.
</p><div class="example">
<h5 class="paragraph" id="sec101">Example</h5>
<p> The following snippet of code is typical.
</p><div class="mylisting"><span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in
match</span> fork () <span class="c006">with</span>
| 0 -&gt; close fd_in; ... write fd_out buffer1 offset1 count1 ...
| pid -&gt; close fd_out; ... read fd_in buffer2 offset2 count2 ...</div><p>After the <code>fork</code> there are two descriptors open on the pipe’s
input, one in the parent and the other in the child. The same
holds for the pipe’s output.
</p><div class="image"><img src="ocamlunix-image7.png" width="45%"></div><p>


In this example the child becomes the writer and the parent the
reader. Consequently the child closes its descriptor <code>fd_in</code> on the
pipe’s output (to save descriptors and to avoid programming
errors). This leaves the descriptor <code>fd_in</code> of the parent unchanged
as descriptors are allocated in process memory and after the fork the
parent’s and child’s memory are disjoint. The pipe, allocated in system
memory, still lives as there’s still the descriptor <code>fd_in</code> of the
parent open in read mode on the pipe’s output. Following the same
reasoning the parent closes its descriptor on the pipe’s input. The
result is as follows:
</p><div class="image"><img src="ocamlunix-image8.png" width="45%"></div><p>


Data written by the child on <code>fd_out</code> is transmitted to <code>fd_in</code>
in 
the parent.
</p><div class="fancybreak">* * *</div></div><p>
When all the descriptors on a pipe’s input are closed and the pipe is
empty, a call to <code>read</code> on its output returns zero:
end of file. And when all the descriptors on a pipe’s output are
closed, a call to <code>write</code> on its input kills the writing
process. More precisely the kernel sends the signal <code>sigpipe</code> to
the process calling <code>write</code> and the default handler of this signal
terminates the process. If the signal handler of <code>sigpipe</code> is
changed, the call to <code>write</code> fails with an <code>EPIPE</code> error.
</p>
<h2 class="section" id="sec102">5.2  Complete example: parallel sieve of Eratosthenes</h2>
<p>This is a classic example of parallel programming. The task of the
program is to enumerate the prime numbers and display them
interactively as they are found. The idea of the algorithm is as
follows. A process enumerates on its output the integers from 2 onwards. We
connect this process to a “filter” process that reads an
integer <span class="c004">p</span> on its input and displays it.</p><div class="image"><img src="ocamlunix-image9.png" width="38%"></div><p>


Therefore, the first filter process reads <span class="c004">p</span>=2. Then it creates a new
filter process connected to its output and filters out the multiples
of <span class="c004">p</span> it gets on its input; all numbers it reads that are not a
multiple of <span class="c004">p</span> are rewritten on its output.
</p><div class="image"><img src="ocamlunix-image10.png" width="65%"></div><p>


Hence the next process reads <span class="c004">p</span>=3, which it displays and then starts
to filter multiples of 3, and so on.
</p><div class="image"><img src="ocamlunix-image11.png" width="100%"></div><p>


This algorithm cannot be directly implemented in Unix because it
creates too many processes (the number of primes already found plus
one). Most Unix systems limit the number of process to a few dozens.
Moreover, on a uniprocessor machine, too many processes active
simultaneously can bring the system to its knees because of the
high costs incurred by switching process contexts. In the following
implementation each process first reads <span class="c004">n</span> primes <span class="c004">p</span><sub>1</sub>, …, <span class="c004">p</span><sub><span class="c004">n</span></sub>
on its input before transforming itself in a filter that eliminate the
multiples of <span class="c004">p</span><sub>1</sub>, …, <span class="c004">p</span><sub><span class="c004">n</span></sub>. In practice <span class="c004">n</span> = 1000 gives a
reasonable slowdown on process creation.</p><p>We start with the process that enumerates integers from 2 to <span class="c004">k</span>.
</p><div class="mylisting"><span class="c006">open</span> Unix;;

<span class="c006">let</span> input_int = input_binary_int
<span class="c006">let</span> output_int = output_binary_int

<span class="c006">let</span> generate k output =
  <span class="c006">let rec</span> gen m =
    output_int output m;
    <span class="c006">if</span> m &lt; k <span class="c006">then</span> gen (m+1)
  <span class="c006">in</span>
  gen 2;;</div><p>To output and input the integers, the following functions are used:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALoutput_binary_int">output_binary_int</a> : out_channel -&gt; int -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinput_binary_int">input_binary_int</a> : in_channel -&gt; int</div><p>The function <code>output_binary_int</code> from the standard library writes a
four-byte binary representation of an integer on an
<code>out_channel</code>. The integer can be read back by the function
<code>input_binary_int</code> on an <code>in_channel</code>. Using these functions
from the standard library has two advantages: first, there is no need to
code the function converting integers to a bytewise
representation<sup><a id="text7" href="#note7">1</a></sup>; second, since
these functions use buffered <span class="c005">i/o</span>, fewer system calls are
performed, which results in better performance. The following functions
create an <code>in_channel</code> or <code>out_channel</code> to buffer the
<span class="c005">i/o</span> on the given descriptor:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALin_channel_of_descr">in_channel_of_descr</a><a id="hevea_default102"></a> : file_descr -&gt; in_channel
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALout_channel_of_descr">out_channel_of_descr</a><a id="hevea_default103"></a> : file_descr -&gt; out_channel</div><p>They allow a program to perform buffered <span class="c005">i/o</span> on descriptors acquired
indirectly or that are not the result of opening a file. These
functions are not here to mix buffered <span class="c005">i/o</span> with non-buffered
<span class="c005">i/o</span>; this is possible but very brittle and highly
discouraged — particularly for input. Note also that it is possible
but very risky to create more than one <code>in_channel</code> (for example)
on the same descriptor.</p><p>We now continue with the filter process. It uses the auxiliary function
<code>read_first_primes</code>. A call to <code>read_first_primes input count</code> 
reads <code>count</code> prime numbers on <code>input</code> (an <code>in_channel</code>) and eliminates
multiples of the primes already read. These <code>count</code> primes are
displayed as soon as they are read and we return them in a list.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let</span> print_prime n = print_int n; print_newline ()
<span class="c003">   2</span> 
<span class="c003">   3</span> <span class="c006">let</span> read_first_primes input count =
<span class="c003">   4</span>   <span class="c006">let rec</span> read_primes first_primes count =
<span class="c003">   5</span>     <span class="c006">if</span> count &lt;= 0 <span class="c006">then</span> first_primes <span class="c006">else</span>
<span class="c003">   6</span>     <span class="c006">let</span> n = input_int input <span class="c006">in</span>
<span class="c003">   7</span>     <span class="c006">if</span> List.exists (<span class="c006">fun</span> m -&gt; n <span class="c006">mod</span> m = 0) first_primes <span class="c006">then</span>
<span class="c003">   8</span>       read_primes first_primes count
<span class="c003">   9</span>     <span class="c006">else begin</span>
<span class="c003">  10</span>       print_prime n;
<span class="c003">  11</span>       read_primes (n :: first_primes) (count - 1)
<span class="c003">  12</span>     <span class="c006">end</span>
<span class="c003">  13</span>   <span class="c006">in</span>
<span class="c003">  14</span>   read_primes [] count<a id="prog:pprime"></a>;;</div><p>And here is the concrete filter function: 
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let rec</span> filter input =
<span class="c003">   2</span>   <span class="c006">try</span>
<span class="c003">   3</span>     <span class="c006">let</span> first_primes = read_first_primes input 1000 <span class="c006">in</span>
<span class="c003">   4</span>     <span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in</span>
<span class="c003">   5</span>     <span class="c006">match</span> fork () <span class="c006">with</span> <a id="prog:sievefilterfork"></a>
<span class="c003">   6</span>     | 0 -&gt;
<span class="c003">   7</span>         close fd_out;
<span class="c003">   8</span>         filter (in_channel_of_descr fd_in)
<span class="c003">   9</span>     | p -&gt;
<span class="c003">  10</span>         close fd_in;
<span class="c003">  11</span>         <span class="c006">let</span> output = out_channel_of_descr fd_out <span class="c006">in</span>
<span class="c003">  12</span>         <span class="c006">while true do</span> <a id="prog:sievefilterwhile"></a>
<span class="c003">  13</span>           <span class="c006">let</span> n = input_int input <span class="c006">in</span>
<span class="c003">  14</span>           <span class="c006">if</span> List.exists (<span class="c006">fun</span> m -&gt; n <span class="c006">mod</span> m = 0) first_primes <span class="c006">then</span> ()
<span class="c003">  15</span>           <span class="c006">else</span> output_int output n
<span class="c003">  16</span>         <span class="c006">done</span> <a id="prog:sievefilterdone"></a>
<span class="c003">  17</span>   <span class="c006">with</span> End_of_file -&gt; ();;</div><p>The filter starts by calling <code>read_first_primes</code> to read the first
1000 prime numbers on its input (the <code>input</code> argument of type
<code>in_channel</code>). Then we create a pipe and clone the process with
<code>fork</code>. The child starts to filter the output of this pipe. The
parent reads numbers on its input and writes each one to the pipe if it
is not a multiple of one of the 1000 primes it initially read.</p><p>Finally, the main program just connects the integer generator to the
first filter process with a pipe. Invoking the program <code>sieve k</code>
enumerates the primes smaller than <code>k</code>. If <code>k</code> is omitted (or
not an integer), it defaults to <code>max_int</code>.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let</span> sieve () =
<span class="c003">   2</span>   <span class="c006">let</span> len = <span class="c006">try</span> int_of_string Sys.argv.(1) <span class="c006">with</span> _ -&gt; max_int <span class="c006">in</span>
<span class="c003">   3</span>   <span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in</span>
<span class="c003">   4</span>   <span class="c006">match</span> fork () <span class="c006">with</span> <a id="prog:sievefork"></a>
<span class="c003">   5</span>   | 0 -&gt;
<span class="c003">   6</span>       close fd_out;
<span class="c003">   7</span>       filter (in_channel_of_descr fd_in)
<span class="c003">   8</span>   | p -&gt;
<span class="c003">   9</span>       close fd_in;
<span class="c003">  10</span>       generate len (out_channel_of_descr fd_out);; <a id="prog:gen"></a>
<span class="c003">  11</span> 
<span class="c003">  12</span> handle_unix_error sieve ();;</div><p>In this example we do not wait for the child before stopping the
parent. The reason is that parent processes are <em>generators</em> for
their children.</p><p>When <code>k</code> is given, the parent will terminate first and close
the descriptor on the input of the pipe connected to its child. Since
OCaml empties the buffers of descriptors open in write mode when a
process stops, the child process will read the last integer provided
by the parent. After that the child also stops etc. Thus, in this
program children become orphaned and are temporarily attached to the
process <code>init</code> before they die in turn.</p><p>If <code>k</code> is not given, all processes continue indefinitely until one or
more are killed. The death of a process results in the death of its child
as described above. It also closes the output of the pipe connected to
its parent. This will in turn kill the parent at the next write on the
pipe (the parent will receive a <code>sigpipe</code> signal whose default
handler terminates the process).</p><div class="exercise">
<h5 class="paragraph" id="sec103">Exercise 12</h5>
<p><a id="ex12"></a>
What needs to be changed so that the parent waits on the termination
of its children?
<a href="exercise12.html#exans12">Answer</a>.</p><div class="fancybreak">* * *</div></div><div class="exercise">
<h5 class="paragraph" id="sec105">Exercise 13</h5>
<p><a id="ex13"></a>
Whenever a prime is found, the function <code>print_prime</code> evaluates
<code>print_newline ()</code>. This performs a system call to empty the standard
output buffer and artificially limits the execution speed of the program.
In fact <code>print_newline ()</code> executes <code>print_char '\n'</code>
followed by <code>flush Pervasives.stdout</code>. What can happen if
<code>print_newline ()</code> is replaced by <code>print_char '\n'</code>? What needs
to be added to solve the problem?
<a href="exercise13.html#exans13">Answer</a>.</p><div class="fancybreak">* * *</div></div>
<h2 class="section" id="sec107">5.3  Named pipes</h2>
<p>On some Unix systems (System V, SunOS, Ultrix, Linux, <span class="c005">bsd</span>)
pipes with a name in the file system can be created. These <em>named
pipes</em> (also known as <em>fifo</em>) allow processes to communicate
even if they are not in a parent/child relationship. This contrasts
with regular pipes that limit communication between the pipe creator
and its descendants.</p><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/mkfifo.html"><span class="c001">mkfifo</span></a><a id="hevea_default104"></a> creates a named pipe: 
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALmkfifo">mkfifo</a> : string -&gt; file_perm -&gt; unit</div><p>The first argument is the name of the pipe, and the second one represents the
requested access permissions.</p><p>Named pipes are opened with a call to <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALopenfile"><span class="c001">openfile</span></a> like any
regular file. Reads and writes on a named pipe have the same semantics
as those on regular ones. Opening a named pipe in read-only mode
(resp. write-only mode) blocks until the pipe is opened by another
process for writing (resp. reading); if this has already happened,
there’s no blocking. Blocking can be avoided altogether by opening the
pipe with the flag <code>O_NONBLOCK</code>, but in this case reads and writes
on the pipe won’t block either. After the
pipe is opened, the function <code>clear_nonblock</code> will change this flag to make further
reads or writes on the pipe blocking. Alternatively,
<code>set_nonblock</code> will make reads and writes non-blocking.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALclear_nonblock">clear_nonblock</a><a id="hevea_default105"></a> : file_descr -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALset_nonblock">set_nonblock</a><a id="hevea_default106"></a> : file_descr -&gt; unit</div>
<h2 class="section" id="sec108">5.4  Descriptor redirections</h2>
<p>So far, we still do not know how to connect the standard input and
output of processes with a pipe as the shell does to execute
commands like <code>cmd1 | cmd2</code>. Indeed, the descriptors we get on the
ends of a pipe with a call to <code>pipe</code> (or to <code>openfile</code> on a
named pipe) are <em>new</em> descriptors, distinct from <code>stdin</code>,
<code>stdout</code> or <code>stderr</code>.</p><p>To address this problem, Unix provides the system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/dup2.html"><span class="c001">dup2</span></a><a id="hevea_default107"></a> 
(read: “<em>dup</em>licate a descriptor <em>to</em> another
descriptor”) that gives one file descriptor another one’s meaning.
This
can be done because there is a level of indirection between a file
descriptor (an object of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_descr"><span class="c001">file_descr</span></a>) and the object in the
kernel called a <em>file table entry</em> that points to the actual
file or pipe and maintains its current read/write position.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALdup2">dup2</a> : file_descr -&gt; file_descr -&gt; unit</div><p>The effect of <code>dup2 fd1 fd2</code> is to update the descriptor <code>fd2</code> to refer to
the file table entry pointed to by <code>fd1</code>. After the call, these two
descriptors refer to same file or pipe, at the same read/write
position.</p><div class="image"><img src="ocamlunix-image12.png" width="80%"></div><div class="example">
<h5 class="paragraph" id="sec109">Example</h5>
<p> 
Standard input redirection.
</p><div class="mylisting"><span class="c006">let</span> fd = openfile "foo" [O_RDONLY] 0 <span class="c006">in</span>
dup2 fd stdin;
close fd;
execvp "bar" [|"bar"|]</div><p>After the call to <code>dup2</code>, the descriptor <code>stdin</code> points to the
file <code>foo</code>. Any read on <code>stdin</code> will read from the file <code>foo</code>
(so does any read on <code>fd</code>; but since we won’t use it, we close it
immediately). This setting on <code>stdin</code> is preserved by <code>execvp</code>
and the program <code>bar</code> will execute with its standard input
connected to the file <code>foo</code>. This is the way the shell executes
commands like <code>bar &lt; foo</code>.
</p><div class="fancybreak">* * *</div></div><div class="example">
<h5 class="paragraph" id="sec110">Example</h5>
<p> 
Standard output redirection.
</p><div class="mylisting"><span class="c006">let</span> fd = openfile "foo" [O_WRONLY; O_TRUNC; O_CREAT] 0o666 <span class="c006">in</span>
dup2 fd stdout;
close fd;
execvp "bar" [|"bar"|]</div><p>After the call to <code>dup2</code>, the descriptor <code>stdout</code> points to
the file <code>foo</code>. Any write on <code>stdout</code> will write to the file
<code>foo</code> (so does any write on <code>fd</code>; but since we won’t use it we
close it immediately). This setting on <code>stdout</code> is preserved by
<code>execvp</code> and the program <code>bar</code> will execute with its standard output
connected to the file <code>foo</code>. This is the way the shell executes
commands like <code>bar &gt; foo</code>.
</p><div class="fancybreak">* * *</div></div><div class="example">
<h5 class="paragraph" id="sec111">Example</h5>
<p> Connecting the output of a program to the input of another.
</p><div class="mylisting"><span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in
match</span> fork () <span class="c006">with</span>
| 0 -&gt;
       dup2 fd_in stdin;
       close fd_out;
       close fd_in;
       execvp "cmd2" [|"cmd2"|]
| _ -&gt;
       dup2 fd_out stdout;
       close fd_out;
       close fd_in;
       execvp "cmd1" [|"cmd1"|]</div><p>The program <code>cmd2</code> is executed with its standard input connected to
the output of the pipe. In parallel, the program <code>cmd1</code> is executed
with its standard output connected to the input of the pipe. Therefore
whatever <code>cmd1</code> writes on its standard output is read by <code>cmd2</code>
on its standard input.</p><p>What happens if <code>cmd1</code> terminates before <code>cmd2</code>? When <code>cmd1</code>
terminates, all its open descriptors are closed. This means that there’s no
open descriptor on the input of the pipe. When <code>cmd2</code> has read all
the data waiting in the pipe, the next read returns an end of file;
<code>cmd2</code> will then do what it is assigned to do when it reaches the
end of its standard input — for example, terminate. </p><p>Now, if <code>cmd2</code> terminates before <code>cmd1</code>, the last descriptor on
the output of the pipe is closed and <code>cmd1</code> will get
a signal (which by default kills the process) the next time
it tries to write on its standard output. </p><div class="fancybreak">* * *</div></div><div class="exercise">
<h5 class="paragraph" id="sec112">Exercise 14</h5>
<p><a id="ex14"></a>
Implement some of the other redirections provided by the shell
<code>sh</code>. Namely: 
</p><div class="mylisting">&gt;&gt;      2&gt;      2&gt;&gt;     2&gt;1     &lt;&lt;</div><p><a href="exercise14.html#exans14">Answer</a>.</p><div class="fancybreak">* * *</div></div><p>Swapping two descriptors requires care. The naive sequence
<code>dup2 fd1 fd2;</code> <code>dup2 fd2 fd1</code> does not work. Indeed, the second
redirection has no effect since after the first one both descriptors
<code>fd1</code> and <code>fd2</code> already point to the same file table entry. The
initial value pointed by <code>fd2</code> was lost. This is like swapping the
contents of two reference cells: a temporary variable is needed to
save one of the two values. Here we can save one of the
descriptors by copying it with the system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/dup.html"><span class="c001">dup</span></a><a id="hevea_default108"></a>.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALdup">dup</a> : file_descr -&gt; file_descr</div><p>The call to <code>dup fd</code> returns a new descriptor pointing on the same
file table entry as <code>fd</code>. For example we can swap <code>stdout</code> and 
<code>stderr</code> with:

</p><div class="mylisting"><span class="c006">let</span> tmp = dup stdout <span class="c006">in</span>
dup2 stderr stdout;
dup2 tmp stderr;
close tmp;;</div><p>After the swap, do not forget to close the temporary descriptor
<code>tmp</code> to prevent a descriptor leak.</p>
<h2 class="section" id="sec114">5.5  Complete example: composing <span class="c004">N</span> commands</h2>
<p>We program a command <code>compose</code> such that 
</p><div class="mylisting">compose cmd<sub>1</sub> cmd<sub>2</sub> ... cmd<sub><span class="c004">n</span></sub></div><p>behaves like the shell command:
</p><div class="mylisting">cmd<sub>1</sub> | cmd<sub>2</sub> | ... | cmd<sub><span class="c004">n</span></sub></div><div class="mylisting"><span class="c003">   1</span> <span class="c006">open</span> Sys;;
<span class="c003">   2</span> <span class="c006">open</span> Unix;;
<span class="c003">   3</span> 
<span class="c003">   4</span> <span class="c006">let</span> compose () =
<span class="c003">   5</span>   <span class="c006">let</span> n = Array.length Sys.argv - 1 <span class="c006">in</span>
<span class="c003">   6</span>   <span class="c006">for</span> i = 1 <span class="c006">to</span> n - 1 <span class="c006">do</span> <a id="prog:composefor"></a>
<span class="c003">   7</span>     <span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in</span>
<span class="c003">   8</span>     <span class="c006">match</span> fork () <span class="c006">with</span>
<span class="c003">   9</span>     | 0 -&gt;
<span class="c003">  10</span>         dup2 fd_out stdout;
<span class="c003">  11</span>         close fd_out;
<span class="c003">  12</span>         close fd_in;
<span class="c003">  13</span>         execv "/bin/sh" [| "/bin/sh"; "-c"; Sys.argv.(i) |]
<span class="c003">  14</span>     | _ -&gt;
<span class="c003">  15</span>         dup2 fd_in stdin;
<span class="c003">  16</span>         close fd_out;
<span class="c003">  17</span>         close fd_in
<span class="c003">  18</span>   <span class="c006">done</span>;
<span class="c003">  19</span>   <span class="c006">match</span> fork () <span class="c006">with</span>
<span class="c003">  20</span>   | 0 -&gt; execv "/bin/sh" [|"/bin/sh"; "-c"; Sys.argv.(n) |]
<span class="c003">  21</span>   | _ -&gt;
<span class="c003">  22</span>       <span class="c006">let rec</span> wait_for_children retcode =
<span class="c003">  23</span>         <span class="c006">try</span>
<span class="c003">  24</span>           <span class="c006">match</span> wait () <span class="c006">with</span>
<span class="c003">  25</span>           | (pid, WEXITED n) -&gt; wait_for_children (retcode <span class="c006">lor</span> n)
<span class="c003">  26</span>           | (pid, _)         -&gt; wait_for_children 127
<span class="c003">  27</span>         <span class="c006">with</span>
<span class="c003">  28</span>           Unix_error(ECHILD, _, _) -&gt; retcode <span class="c006">in</span>
<span class="c003">  29</span>       exit (wait_for_children 0)
<span class="c003">  30</span> ;;
<span class="c003">  31</span> handle_unix_error compose ();;</div><p>The bulk of the work is done by the <code><span class="c006">for</span></code> loop starting at
line <a href="#prog%3Acomposefor">6</a>. For each command except the last one, we
create a new pipe and a child process. The child connects the pipe’s
input to its standard output and executes the command. After the
<code>fork</code> it inherits the standard input of its parent. The main
process (the parent) connects the pipe’s output to its standard input
and continues the loop. Suppose (induction hypothesis) that at the
beginning of the <span class="c004">i</span>th iteration, the situation is as follows:

</p><div class="image"><img src="ocamlunix-image13.png" width="80%"></div><p>


Rounded boxes represent processes. Their standard input is on the
left, their standard output on the right. The ellipses represent
the initial standard input and output of the <code>compose</code> process.
Just after the call to <code>pipe</code> and <code>fork</code> we have:
</p><div class="image"><img src="ocamlunix-image14.png" width="100%"></div><p>


When the parent calls <code>dup2</code>, we get:
</p><div class="image"><img src="ocamlunix-image15.png" width="100%"></div><p>


When the child calls <code>dup2</code> and <code>execv</code>, we get:
</p><div class="image"><img src="ocamlunix-image16.png" width="100%"></div><p>


and everything is ready for the next iteration. </p><p>The last command is forked after the loop because there’s no need to
create a new pipe: the process <code>compose</code> already has the right
standard input (the output of the next to last command) and output
(the one initially given to the command <code>compose</code>) for the
child. Hence it is sufficient to <code>fork</code> and <code>exec</code>. The parent then
waits for its children to terminate: it calls <code>wait</code> repeatedly
until the error <code>ECHILD</code> (no child to wait for) is raised. The
children’s return codes are combined with a bitwise “or”
(<code><span class="c006">lor</span></code> operator) to create a meaningful return code for
<code>compose</code> : zero if all the children returned zero, different from
zero otherwise.</p><p>Note that we execute commands through the shell <code>/bin/sh</code>. This
prevents us from having to parse complex commands into tokens as
in the following invocation:
</p><div class="mylisting">compose "grep foo" "wc -l"</div><p>Adding this functionality to our program would complicate it needlessly.</p>
<h2 class="section" id="sec115">5.6  Input/output multiplexing</h2>
<p>In all the examples so far, processes communicate <em>linearly</em>:
each process reads data coming from at most one other process. In this
section we highlight and solve the problems occurring whenever a
process needs to read data coming from <em>many</em> processes.</p><p>Consider the example of a multi-windowed terminal emulator. Suppose we
have a computer, called the client, connected to a Unix machine by a
serial port. We want to emulate, on the client, many terminal windows
connected to different user processes on the Unix machine. For example,
one window can be connected to a shell and another to a text
editor. Outputs from the shell are displayed in the first window and
those from the editor in the other. If the first window is
active, keystrokes from the client’s keyboard are sent to the input of
the shell and if the second window is active they are sent to the
input of the editor.</p><p>Since there’s only a single physical link between the client and the
Unix machine, we need to multiplex the virtual connections between
windows and processes by interleaving the data transmissions.
Here’s the protocol we are going to use. On the serial port, we send
messages with the following structure: 
</p><ul class="itemize"><li class="li-itemize">
One byte indicating the process number or window number of the receiver.
</li><li class="li-itemize">One byte indicating the number <span class="c004">N</span> of bytes that are following.
</li><li class="li-itemize"><span class="c004">N</span> bytes of data to send to the receiver.
</li></ul><p>
On the Unix machine, user processes (shell, editor, etc.) are
connected by a pipe to one or more auxiliary processes that read and
write on the serial port and (de)multiplex the data. The serial port
is a special file (<code>/dev/ttya</code>, for example), on which the
auxiliary processes <code>read</code> and <code>write</code> to communicate with the 
client.</p><p>Demultiplexing (transmission from the client to the user processes)
does not pose any particular problem. We just need a process that reads
messages on the serial port and writes the extracted data on the pipe
connected to the standard input of the receiving user process.
</p><div class="image"><img src="ocamlunix-image17.png" width="55%"></div><p>


Multiplexing (transmission from user processes to the client) is
more tricky. Let us try to mimic the demultiplexer: a process reads
sequentially the output of the pipes connected to the standard output
of the user processes and then writes the data it reads as message on
the serial port by adding the receiving window number and the length
of the data.
</p><div class="image"><img src="ocamlunix-image18.png" width="100%"></div><p>


This does not work, because reading a pipe can block. For example, if we
try to read the output of the shell but it has nothing to
display at that moment, the multiplexer process will block, and waiting
characters from the editor will be ignored.
There’s no way to know in advance on which pipes there is
data waiting to be displayed (in parallel algorithms, the situation
where a process is perpetually denied access to a shared resource is
called <em>starvation</em>).</p><p>Here is another approach: we associate with each user process a
<em>repeater</em> process. The repeater reads the output of the pipe
connected to the standard output of the user process, transforms the
data into messages and writes the result directly on the serial port
(each repeater process opens <code>/dev/ttya</code> in write mode).
</p><div class="image"><img src="ocamlunix-image19.png" width="100%"></div><p>Since each user process has its output transmitted independently,
blocking problems are solved. However the protocol may not be
respected. Two repeaters may try to write a message at the same time
and the Unix kernel does not guarantee the atomicity of writes, i.e. 
that they are performed in a single uninterruptible operation.
Thus the kernel may choose to write only a part of a message from a
repeater to <code>/dev/ttya</code>, then write a full message from another
repeater and finally write the remaining part of the first message.
This will utterly confuse the demultiplexer on the client: 
it will interpret the second message as part of the data of the
first and then interpret the rest of the data as a new message header.</p><p>To avoid this, repeater processes must synchronize so that at anytime
at most one of them is writing on the serial port (in parallel
algorithms we say that we need to enforce the mutual exclusion of
repeaters on the access to the serial link). Technically, this can be
done with concepts we have already seen so far: repeaters can create a
specific file (the “lock”) with the <code>O_EXCL</code> flag before
sending a message and destroy it after they are done writing to the
serial port. However this technique is not very efficient because the
lock creation and destruction costs are too high.</p><p>A better solution is to take the first approach (a single
multiplexer process) and set the output of the pipes connected to the
standard output of user processes in non-blocking mode with
<code>set_nonblock</code>. A read on an empty pipe will not block but return
immediately by raising the error <code>EAGAIN</code> or <code>EWOULDBLOCK</code>. We
just ignore this error and try to read the output of the next user
process. This will prevent starvation and avoid any mutual exclusion
problem. However it is a very inefficient solution, the multiplexer
process performs what is called “busy waiting”: it uses
processing time even if no process is
sending data. This can be alleviated by introducing calls to
<code>sleep</code> in the reading loop; unfortunately, it is very difficult to find
the right frequency. Short <code>sleep</code>s cause needless processor load when there
is little data, and long <code>sleep</code>s introduce perceptible delays when there is a lot of data.</p><p>This is a serious problem. To solve it, the designers of <span class="c005">bsd</span>
Unix introduced a new system call, <code>select</code>, which is now
available on most Unix variants. A call to <code>select</code> allows a
process to wait (passively) on one or more input/output events.
An event can be:
</p><ul class="itemize"><li class="li-itemize">
A read event: there is data to read on that descriptor.</li><li class="li-itemize">A write event: it is possible to write on that descriptor
without blocking.</li><li class="li-itemize">An exceptional event: an exceptional condition is
true on that descriptor. For example, on certain network connections
high-priority data (<em>out-of-band data</em>) can be sent that
overtakes normal data waiting to be sent. Receiving this kind of 
high-priority data is an exceptional condition.
</li></ul><p>
The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/select.html"><span class="c001">select</span></a><a id="hevea_default109"></a> has the following signature:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALselect">select</a> :
    file_descr list -&gt; file_descr list -&gt; file_descr list -&gt;
      float -&gt; file_descr list * file_descr list * file_descr list</div><p>The first three arguments are sets of descriptors represented by
lists: the first argument is the set of descriptors to watch for read
events; the second argument is the set of descriptors to watch for
write events; the third argument is the set of descriptors to watch
for exceptional events. The fourth argument is a timeout in
seconds. If it is positive or zero, the call to <code>select</code> will return
after that time, even if no event occurred. If it is negative, the call
to <code>select</code> waits indefinitely until one of the requested events occurs.</p><p>The <code>select</code> call returns a triplet of descriptor lists: the first
component is the list of descriptors ready for reading, the second
component those ready for writing and the third one those on which an
exceptional condition occurred. If the timeout expires before any
event occurs, the three lists are empty.</p><div class="example">
<h5 class="paragraph" id="sec116">Example</h5>
<p> 
The code below watches read events on the descriptors <code>fd1</code> and 
<code>fd2</code> and returns after 0.5 seconds. 
</p><div class="mylisting"><span class="c006">match</span> select [fd1; fd2] [] [] 0.5 <span class="c006">with</span>
| [], [], [] -&gt; <em>(* the 0,5s timeout expired *)</em>
| fdl, [], [] -&gt;
    <span class="c006">if</span> List.mem fd1 fdl <span class="c006">then</span>
         <em>(* read from fd1 *)</em>;
    <span class="c006">if</span> List.mem fd2 fdl <span class="c006">then</span>
         <em>(* read from fd2 *)</em></div><div class="fancybreak">* * *</div></div><div class="example">
<h5 class="paragraph" id="sec117">Example</h5>
<p> 
The following <code>multiplex</code> function is central to the
multiplexer/demultiplexer of the multi-windowed terminal emulator
described above.</p><p>To simplify, the multiplexer just sets the receiver of messages
according to their provenance and the demultiplexer redirects data
directly to the receiver number. In other words, we assume that either
each sender talks to a receiver with the same number, or that the
correspondence between them is magically established in the middle of
the serial link by rewriting the receiver number.</p><p>The <code>multiplex</code> function takes a descriptor open on the serial port
and two arrays of descriptors of the same size, one containing pipes
connected to the standard input of the user processes, the other
containing pipes connected to their standard output.
</p><div class="mylisting"><span class="c006">open</span> Unix;;

<span class="c006">let rec</span> really_read fd buff start length =
  <span class="c006">if</span> length &lt;= 0 <span class="c006">then</span> () <span class="c006">else
    match</span> read fd buff start length <span class="c006">with</span>
    | 0 -&gt; raise End_of_file
    | n -&gt; really_read fd buff (start+n) (length-n);;

<span class="c006">let</span> buffer = String.create 258;;

<span class="c006">let</span> multiplex channel inputs outputs =
  <span class="c006">let</span> input_fds = channel :: Array.to_list inputs <span class="c006">in
  try
    while true do
      let</span> (ready_fds, _, _) = select input_fds [] [] (-1.0) <span class="c006">in
      for</span> i = 0 <span class="c006">to</span> Array.length inputs - 1 <span class="c006">do
        if</span> List.mem inputs.(i) ready_fds <span class="c006">then begin
          let</span> n = read inputs.(i) buffer 2 255 <span class="c006">in</span>
          buffer.[0] &lt;- char_of_int i;
          buffer.[1] &lt;- char_of_int n;
          ignore (write channel buffer 0 (n+2));
          ()
        <span class="c006">end
      done</span>;
      <span class="c006">if</span> List.mem channel ready_fds <span class="c006">then begin</span>
        really_read channel buffer 0 2;
        <span class="c006">let</span> i = int_of_char(buffer.[0])
        <span class="c006">and</span> n = int_of_char(buffer.[1]) <span class="c006">in
        if</span> n = 0 <span class="c006">then</span> close outputs.(i) <span class="c006">else
        begin</span>
          really_read channel buffer 0 n;
          ignore (write outputs.(i) buffer 0 n);
          ()
        <span class="c006">end
      end
    done
  with</span> End_of_file -&gt; () ;;</div><p>The <code>multiplex</code> function starts by constructing a set of
descriptors (<code>input_fds</code>) that contain the input descriptors
(those connected to the standard output of the user processes) and the
descriptor of the serial port. On each iteration of the 
<code><span class="c006">while</span></code> loop we call <code>select</code> to watch for pending reads in
<code>input_fds</code>. We do not watch for any write or exceptional event and
we do not limit the waiting time. When <code>select</code> returns, we test whether
there is data waiting on an input descriptor or on the serial port.</p><p>If there is data on an input descriptor we <code>read</code> this input into a
buffer, add a message header and write the result on the serial
port. If <code>read</code> returns zero this indicates that the corresponding
pipe was closed. The terminal emulator on the client will receive a
message with zero bytes, signaling that the user process
with that number died; it can then close the corresponding window.</p><p>If there is data on the serial port, we read the two-byte message
header which gives us the number <code>i</code> of the receiver and the number
<code>n</code> of bytes to read. We then read <code>n</code> bytes on the channel and
write them on the output <code>i</code> connected to the standard input of the
corresponding user process. However, if <code>n</code> is 0, we close the
output <span class="c004">i</span>. The idea is that the terminal emulator at the other end
sends a message with <code>n = 0</code> to indicate an end of file on the
standard input of the receiving user process.</p><p>We get out of the loop when <code>really_read</code> raises the exception
<code>End_of_file</code>, which indicates an end of file on the
serial port.
</p><div class="fancybreak">* * *</div></div>
<h2 class="section" id="sec118">5.7  Miscellaneous: <span class="c001">write</span></h2>
<p>The function <code>write</code> of the <code>Unix</code> module iterates the system call
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/write.html"><span class="c001">write</span></a><a id="hevea_default110"></a> until all the requested bytes are effectively written.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALwrite">write</a> : file_descr -&gt; string -&gt; int -&gt; int -&gt; int</div><p>However, when the descriptor is a pipe (or a socket, see
chapter <a href="sockets.html#sec119">6</a>), writes may block and the system call
<code>write</code> may be interrupted by a signal. In this case the OCaml
call to <code>Unix.write</code> is interrupted and the error <code>EINTR</code> is
raised. The problem is that some of the data may already have been
written by a previous system call to <code>write</code> but the actual size
that was transferred is unknown and lost. This renders the function 
<code>write</code> of the <code>Unix</code> module useless in the presence of signals.</p><p>To address this problem, the <code>Unix</code> module also provides the
“raw” system call <code>write</code> under the name
<code>single_write</code>. 
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsingle_write">single_write</a> : file_descr -&gt; string -&gt; int -&gt; int -&gt; int</div><p>With <code>single_write</code>, if an error is raised it is guaranteed that no
data is written.</p><p>The rest of this section shows how to implement this
function. Fundamentally, it is just a matter of interfacing OCaml with
C (more information about this topic can be found in the relevant
section of the OCaml manual). The following code is written in the file
<code>single_write.c</code>:
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">#include</span> &lt;errno.h&gt;
<span class="c003">   2</span> <span class="c006">#include</span> &lt;string.h&gt;
<span class="c003">   3</span> <span class="c006">#include</span> &lt;caml/mlvalues.h&gt;
<span class="c003">   4</span> <span class="c006">#include</span> &lt;caml/memory.h&gt;
<span class="c003">   5</span> <span class="c006">#include</span> &lt;caml/signals.h&gt;
<span class="c003">   6</span> <span class="c006">#include</span> &lt;caml/unixsupport.h&gt;
<span class="c003">   7</span> 
<span class="c003">   8</span> CAMLprim value caml_single_write
<span class="c003">   9</span>         (value fd, value buf, value vofs, value vlen) {
<span class="c003">  10</span>   CAMLparam4(fd, buf, vofs, vlen);
<span class="c003">  11</span>   long ofs, len;
<span class="c003">  12</span>   int numbytes, ret;
<span class="c003">  13</span>   char iobuf[UNIX_BUFFER_SIZE];
<span class="c003">  14</span>   ofs = Long_val(vofs)
<span class="c003">  15</span>   len = Long_val(vlen)
<span class="c003">  16</span>   ret = 0;
<span class="c003">  17</span>   <span class="c006">if</span> (len &gt; 0) {
<span class="c003">  18</span>     numbytes = len &gt; UNIX_BUFFER_SIZE ? UNIX_BUFFER_SIZE : len;
<span class="c003">  19</span>     memmove (iobuf, &amp;Byte(buf, ofs), numbytes);
<span class="c003">  20</span>     caml_enter_blocking_section (); <a id="prog:enterbs"></a>
<span class="c003">  21</span>     ret = write(Int_val(fd), iobuf, numbytes);
<span class="c003">  22</span>     caml_leave_blocking_section (); <a id="prog:leavebs"></a>
<span class="c003">  23</span>     <span class="c006">if</span> (ret == -1) uerror("single_write", Nothing);
<span class="c003">  24</span>   }
<span class="c003">  25</span>   CAMLreturn (Val_int(ret));
<span class="c003">  26</span> }</div><p>The first two lines include standard C headers. The following four
lines include C headers specific to OCaml installed by the
distribution. The <code>unixsupport.h</code> header defines reusable C
functions of the OCaml Unix library.</p><p>The most important line is the call to <code>write</code>. Since the call may
block (if the descriptor is a pipe or a socket) we need to release the
global lock on the OCaml runtime immediately before the call
(line <a href="#prog%3Aenterbs">20</a>) and reacquire it right after
(line <a href="#prog%3Aleavebs">22</a>). This makes the function compatible with the
<code>Thread</code> module (see chapter <a href="threads.html#sec149">7</a>): it allows
other threads to execute during the blocking call. </p><p>During the system call OCaml may perform a garbage collection and
the address of the OCaml string <code>buf</code> may move in memory. To
solve this problem we copy <code>buf</code> into the C string <code>iobuf</code>.
This has an additional cost, but only in the order of magnitude of
10% (and not 50% as one might think) because the overall cost of the
function is dominated by the system call. The size of this C string is
defined in <code>unix_support.h</code>. If an error occurs during the system
call (indicated by a negative return value) it is propagated to
OCaml by the function <code>uerror</code>, defined in the OCaml Unix library.</p><p>To access this code from OCaml, the file <code>unix.mli</code> declares:


</p><div class="mylisting"><span class="c006">external</span> unsafe_single_write :
  file_descr -&gt; string -&gt; int -&gt; int -&gt; int = "caml_single_write"</div><p>But in practice we verify the arguments before calling the function: 
</p><div class="mylisting"><span class="c006">let</span> single_write fd buf ofs len =
  <span class="c006">if</span> ofs &lt; 0 || len &lt; 0 || ofs &gt; String.length buf - len
  <span class="c006">then</span> invalid_arg "Unix.write"
  <span class="c006">else</span> unsafe_single_write fd buf ofs len</div><p>This function has been available in the <code>Unix</code> module since version
<span class="c001">3.08</span>. But if we had written the program above ourselves we would
need to compile it as follows to use it (assuming the OCaml code is
in the files <code>write.mli</code> and <code>write.ml</code>):
</p><div class="mylisting">ocamlc -c single_write.c write.ml
ocamlc -custom -o prog unix.cma single_write.o write.cmo mod1.ml mod2.ml</div><p>It is often more practical to build a library <code>write.cma</code> containing
both the C and the OCaml code:
</p><div class="mylisting">ocamlc -custom -a -o write.cma single_write.o write.cmo</div><p>The library <code>write.cma</code> can then be used like <code>unix.cma</code>:
</p><div class="mylisting">ocamlc -o main.byte unix.cma write.cma main.ml</div><p>The semantics of <code>single_write</code> is as close as possible to the
system call <code>write</code>. The only remaining difference is when the
original string is very long (greater than <code>UNIX_BUFFER_SIZE</code>); the
call may then not write all the data and must be iterated. The
atomicity of <code>write</code> (guaranteed for regular files) is thus not
guaranteed for long writes. This difference is generally insignificant but one should
be aware of it.</p><p>On top of this function we can implement a higher-level function
<code>really_write</code>, analogous to the function <code>really_read</code> of the
multiplexer example, that writes exactly the requested amount of data
(but not atomically).

</p><div class="mylisting"><span class="c006">let rec</span> really_write fd buffer offset len =
  <span class="c006">let</span> n = restart_on_EINTR (single_write fd buffer offset) len <span class="c006">in
  if</span> n &lt; len <span class="c006">then</span> really_write fd buffer (offset + n) (len - n);;</div>
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note7" href="#text7">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">The representation used by these functions is
unspecified but it is guaranteed to be platform-independent for a
particular version of the language.</div>
</dd></dl>
<hr>
<a href="signals.html"><img src="previous_motif.gif" alt="Previous"></a>
<a href="index.html"><img src="contents_motif.gif" alt="Up"></a>
<a href="sockets.html"><img src="next_motif.gif" alt="Next"></a>
</body>
</html>
