<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.01">
<style type="text/css">
.c000{border-spacing:6px;border-collapse:separate;}
.c001{font-family:monospace}
.c002{font-size:small}
.c003{font-size:xx-small}
.c004{font-style:italic}
.c005{font-variant:small-caps}
.c006{font-weight:bold}
.c007{font-weight:bold;font-size:small}
.c008{text-align:center;border:solid 1px;white-space:nowrap}
.c009{text-align:center;white-space:nowrap}
.c010{text-align:left;white-space:nowrap}
.c011{text-align:right;white-space:nowrap}
.c012{vertical-align:top;text-align:left;}
.c013{vertical-align:top;text-align:left;white-space:nowrap}
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding:0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.titlemain{margin:1ex 2ex 2ex 1ex;}
.titlerest{margin:0ex 2ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
*{padding: 0em; border: 0em; margin: 0em;
font-family: georgia, serif; font-weight: normal;
font-size: 100%;}
BODY{margin: 2em 10% 2em 10%;
font-size: 10pt; line-height: 140%; text-align: justify;
background: white; color: black;
max-width: 75ex; min-width: 40ex;}
TT{font-family:monospace;}
TT A{font-family:monospace;}
B{font-weight: bold }
A{color: blue; text-decoration : none }
.titlerest SUP{font-size: 70%; padding-right:0.5ex }
.title{margin:0em; border: 0em; padding: 0em; border-spacing:0px;}
.title *{margin-left:0em; padding-left: 0em; border-style:none}
.titlemain{font-size: 180%;}
.titlerest{text-align: left; margin-top: 1em}
.copyrightnotice{margin-top: 2em; 
			 margin-bottom: 1em;
font-size: 80%;
text-align: left}
.ccimage{vertical-align: text-top;}
.abstract{margin-top: 1em }
UL{padding-top: 1ex; }
LI{padding-top: 1ex; }
.chapter{margin-top:2ex; font-size: 180%; 
		 text-align:left; line-height:130%; }
.chapter A{color: black }
.section{font-size: 140%; margin-top: 1.5em; text-align:left}
.section A{color: black }
.subsection{font-weight: bold; margin-top: 1em; text-align:left}
.paragraph{font-weight: bold; display:inline-block; 
		 padding-top: 1em; padding-right: 1em}
P{padding-top : 1em }
.paragraph + P{padding-top : 0em; display: inline; }
.li-toc A{color: black }
.li-toc A:hover{color: blue }
.toc .li-toc{padding-top: 1.5em}
.toc .li-toc A{font-weight: bold }
.toc .li-toc .toc .li-toc{padding-top: 0.5ex }
.toc .li-toc .toc .li-toc A {margin-left:1.5em; 
	 font-weight: normal }
HR.footnoterule{border-width: 0pt }
HR{margin: 1em 0em 1em 0em; 
	 border-width: thin; 
		border-bottom-style: solid;}
.li-indexenv{list-style-type : none}
.li-indexenv B A{font-weight : bold}
DIV.fancybreak{text-align:center; padding-top:1em }
CODE{font-family:monospace; white-space:pre;}
DIV.mylisting{padding-top : 1em; font-family:monospace;
		 white-space:pre; margin-right:auto;
		 margin-left:0ex; text-align:left;}
.mylisting b{font-family:monospace; font-weight : bold }
.mylisting FONT{font-family:monospace; 
		 font-size: 70% !important;
		 margin-left: -3.1em }
.mylisting A{font-family:monospace; color : #0000A0 }
.mltypecases TD:first-child{padding-left:0em }
.mltypecases TABLE{border-spacing:0px 6px !important; 
		 margin-top: 0em; }
DIV.figure{margin-top:1em;
padding-bottom:1em;
	 border-width: thin; 
		 border-bottom-style: solid;
border-top-style: solid;
text-align: center; }
DIV.table{text-align: center; margin-top: 1em; margin-bottom: 1em}
TABLE{empty-cells:show }
TR{margin-top: 4ex }
TD{padding-left: 2ex; padding-top:1ex }
.hbar{background-color:white;
border-width:thin; 
		 border-top-style: solid; 
		 padding-top: 0em;
		 height:0px;}
.caption{margin-top: 1.5em; }
.image{display: block; text-align: center; margin-top:1em; }
.thebibliography DL{margin-top : 1em;}
.thebibliography DT{margin-top : 1em;}
.thebibliography DD{display : inline; }
.thebibliography FONT{color: black; }
.thebibliography B{font-weight : bold}
.bibsection{font-weight : bold}
</style>
<title>Unix system programming in OCaml
</title>
</head>
<body>
<!--HEVEA command line is: hevea book.hva -I src -o src/ocamlunix.html -fix -O -exec xxdate.exe src/ocamlunix.tex -->
<!--CUT STYLE book--><!--CUT DEF chapter 0 --><table class="title"><tr><td style="padding:1ex"><h1 class="titlemain">Unix system programming in OCaml</h1><h3 class="titlerest">Xavier Leroy and Didier Rémy</h3><h3 class="titlerest">1<sup>st</sup>December
, 2014</h3></td></tr>
</table><div class="copyrightnotice">
© 1991, 1992, 2003, 2004, 2005, 2006, 2008, 2009, 2010 <br>
Xavier Leroy and Didier Rémy, <span class="c005">inria</span> Rocquencourt.<br>
Rights reserved.
Consult the <a href="LICENSE">license.</a> <a href="http://creativecommons.org/licenses/by-nc-sa/2.0/fr/"><img class="ccimage" src="http://i.creativecommons.org/l/by-nc-sa/2.0/fr/80x15.png" alt="CreativeCommons License"></a>
<p><em>Translation by</em> 
Daniel C. Bünzli, 
Eric Cooper,
Eliot Handelman,
Priya Hattiangdi,
Thad Meyer,
Prashanth Mundkur,
Richard Paradies,
Till Varoquaux,
Mark Wong-VanHaren</p><p><em>Proofread by</em>
David Allsopp,
Erik de Castro Lopo,
John Clements,
Anil Madhavapeddy,
Prashanth Mundkur</p><p><em>Translation coordination &amp; layout by</em> Daniel C. Bünzli.</p><p>Please send corrections to <span class="c001">daniel.buenzl i@erratique.ch</span>.
</p></div><p> 
Available as a <a href="ocamlunix.html">monolithic file</a>,
<a href="index.html">by chapters</a>, and in <a href="ocamlunix.pdf">PDF</a>
— 
git <a href="http://github.com/ocaml/ocamlunix/">repository</a>.</p><div class="abstract">
This document is an introductory course on Unix system programming,
with an emphasis on communications between processes. The main novelty
of this work is the use of the OCaml language, a dialect of the
ML language, instead of the C language that is customary in systems
programming. This gives an unusual perspective on systems programming
and on the ML language.
</div><!--TOC chapter id=sec1 Contents-->
<h1 class="chapter" id="sec1">Contents</h1><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#htocintro">Introduction</a>
</li><li class="li-toc"><a href="#sec3"> 1  Generalities</a>
<ul class="toc"><li class="li-toc">
<a href="#sec4">1.1  Modules <span class="c001">Sys</span> and <span class="c001">Unix</span></a>
</li><li class="li-toc"><a href="#sec5">1.2  Interface with the calling program</a>
</li><li class="li-toc"><a href="#sec7">1.3  Error handling</a>
</li><li class="li-toc"><a href="#sec8">1.4  Library functions</a>
</li></ul>
</li><li class="li-toc"><a href="#sec11"> 2  Files</a>
<ul class="toc"><li class="li-toc">
<a href="#sec12">2.1  The file system</a>
</li><li class="li-toc"><a href="#sec13">2.2  File names and file descriptors</a>
</li><li class="li-toc"><a href="#sec14">2.3  Meta-attributes, types and permissions</a>
</li><li class="li-toc"><a href="#sec18">2.4  Operations on directories</a>
</li><li class="li-toc"><a href="#sec20">2.5  Complete example: search in a file hierarchy</a>
</li><li class="li-toc"><a href="#sec25">2.6  Opening a file</a>
</li><li class="li-toc"><a href="#sec28">2.7  Reading and writing</a>
</li><li class="li-toc"><a href="#sec32">2.8  Closing a descriptor</a>
</li><li class="li-toc"><a href="#sec33">2.9  Complete example: file copy</a>
</li><li class="li-toc"><a href="#sec36">2.10  The cost of system calls and buffers</a>
</li><li class="li-toc"><a href="#sec37">2.11  Complete example: a small input/output library</a>
</li><li class="li-toc"><a href="#sec40">2.12  Positioning</a>
</li><li class="li-toc"><a href="#sec44">2.13  Operations specific to certain file types</a>
</li><li class="li-toc"><a href="#sec50">2.14  Locks on files</a>
</li><li class="li-toc"><a href="#sec51">2.15  Complete example: recursive copy of files</a>
</li><li class="li-toc"><a href="#sec54">2.16  Complete example: <span class="c001">T</span>ape <span class="c001">AR</span>chive</a>
</li></ul>
</li><li class="li-toc"><a href="#sec66"> 3  Processes</a>
<ul class="toc"><li class="li-toc">
<a href="#sec67">3.1  Creation of processes</a>
</li><li class="li-toc"><a href="#sec68">3.2  Complete Example: the command <span class="c001">leave</span></a>
</li><li class="li-toc"><a href="#sec69">3.3  Awaiting the termination of a process</a>
</li><li class="li-toc"><a href="#sec71">3.4  Launching a program</a>
</li><li class="li-toc"><a href="#sec75">3.5  Complete example: a mini-shell</a>
</li></ul>
</li><li class="li-toc"><a href="#sec78"> 4  Signals</a>
<ul class="toc"><li class="li-toc">
<a href="#sec79">4.1  Default behavior</a>
</li><li class="li-toc"><a href="#sec80">4.2  Using signals</a>
</li><li class="li-toc"><a href="#sec81">4.3  Changing the effect of a signal</a>
</li><li class="li-toc"><a href="#sec87">4.4  How to mask signals</a>
</li><li class="li-toc"><a href="#sec88">4.5  Signals and system calls</a>
</li><li class="li-toc"><a href="#sec91">4.6  The passage of time</a>
</li><li class="li-toc"><a href="#sec98">4.7  Problems with signals</a>
</li></ul>
</li><li class="li-toc"><a href="#sec99"> 5  Classical inter-process communication: pipes</a>
<ul class="toc"><li class="li-toc">
<a href="#sec100">5.1  Pipes</a>
</li><li class="li-toc"><a href="#sec102">5.2  Complete example: parallel sieve of Eratosthenes</a>
</li><li class="li-toc"><a href="#sec107">5.3  Named pipes</a>
</li><li class="li-toc"><a href="#sec108">5.4  Descriptor redirections</a>
</li><li class="li-toc"><a href="#sec114">5.5  Complete example: composing <span class="c004">N</span> commands</a>
</li><li class="li-toc"><a href="#sec115">5.6  Input/output multiplexing</a>
</li><li class="li-toc"><a href="#sec118">5.7  Miscellaneous: <span class="c001">write</span></a>
</li></ul>
</li><li class="li-toc"><a href="#sec119"> 6  Modern communication: sockets</a>
<ul class="toc"><li class="li-toc">
<a href="#sec120">6.1  Sockets</a>
</li><li class="li-toc"><a href="#sec121">6.2  Socket creation</a>
</li><li class="li-toc"><a href="#sec122">6.3  Addresses</a>
</li><li class="li-toc"><a href="#sec124">6.4  Connection to a server</a>
</li><li class="li-toc"><a href="#sec125">6.5  Disconnecting sockets</a>
</li><li class="li-toc"><a href="#sec126">6.6  Complete example: the universal client</a>
</li><li class="li-toc"><a href="#sec127">6.7  Establishing a service</a>
</li><li class="li-toc"><a href="#sec128">6.8  Tuning sockets</a>
</li><li class="li-toc"><a href="#sec130">6.9  Complete example: the universal server</a>
</li><li class="li-toc"><a href="#sec132">6.10  Communication in connectionless mode</a>
</li><li class="li-toc"><a href="#sec133">6.11  Low level reads and writes</a>
</li><li class="li-toc"><a href="#sec134">6.12  High-level primitives</a>
</li><li class="li-toc"><a href="#sec135">6.13  Examples of protocols</a>
</li><li class="li-toc"><a href="#sec142">6.14  Complete example: <span class="c005">http</span> requests</a>
</li></ul>
</li><li class="li-toc"><a href="#sec149"> 7  Threads</a>
<ul class="toc"><li class="li-toc">
<a href="#sec150">7.1  Introduction</a>
</li><li class="li-toc"><a href="#sec152">7.2  Creation and termination of threads</a>
</li><li class="li-toc"><a href="#sec153">7.3  Waiting</a>
</li><li class="li-toc"><a href="#sec158">7.4  Synchronization among threads: locks</a>
</li><li class="li-toc"><a href="#sec161">7.5  Complete example: <span class="c005">http</span> relay</a>
</li><li class="li-toc"><a href="#sec164">7.6  Conditions</a>
</li><li class="li-toc"><a href="#sec167">7.7  Event-based synchronous communication</a>
</li><li class="li-toc"><a href="#sec170">7.8  Implementation details</a>
</li></ul>
</li><li class="li-toc"><a href="#htocmore">Going further</a>
</li><li class="li-toc"><a href="#htocrefs">References</a>
</li><li class="li-toc"><a href="#htocindex">Index</a>
</li></ul><!--NAME toc.html-->
<!--TOC chapter id=sec2 Introduction-->
<h1 class="chapter" id="sec2"><a id="htocintro">I</a>ntroduction</h1><!--SEC END --><!--NAME intro.html-->
<p>These course notes originate from a system programming course Xavier
Leroy taught in 1994 to the first year students of the Master’s program in
fundamental and applied mathematics and computer science at the École
Normale Supérieure. This earliest version used the
Caml-Light [<a href="#Caml-Light">1</a>] language.
For a Master’s course in computer science at the École Polytechnique
taught from 2003 to 2006, Didier Rémy adapted the notes to use the
OCaml language. During these years, Gilles Roussel, Fabrice Le
Fessant and Maxence Guesdon helped to teach the course and also
contributed to this document. The new version also brought
additions and updates. In ten years, some orders of magnitude have
shifted by a digit and the web has left its infancy. For instance, the
<span class="c005">http</span> relay example, now commonplace, may have been a forerunner in
1994. But, most of all, the OCaml language gained maturity and was
used to program real system applications like Unison [<a href="#Unison">18</a>].</p><p>Tradition dictates that Unix system programming must be done in C. For
this course we found it more interesting to use a higher-level
language, namely OCaml, to explain the fundamentals of Unix system
programming.</p><p>The OCaml interface to Unix system calls is more abstract. Instead
of encoding everything in terms of integers and bit fields as in C,
OCaml uses the whole power of the ML type system to clearly
represent the arguments and return values of system calls. Hence, it
becomes easier to explain the semantics of the calls instead of losing
oneself explaining how the arguments and the results have to be
en/decoded. (See, for example, the presentation of the system call
<code>wait</code>, page <a href="#wait">??</a>.)</p><p>Furthermore, due to the static type system and the clarity of its
primitives, it is safer to program in OCaml than in C. The
experienced C programmer may see these benefits as useless luxury,
however they are crucial for the inexperienced audience of this course.</p><p>A second goal of this exposition of system programming is to show
OCaml performing in a domain out of its usual applications in
theorem proving, compilation and symbolic computation. The outcome of
the experiment is rather positive, thanks to OCaml’s solid
imperative kernel and its other novel aspects like parametric
polymorphism, higher-order functions and exceptions. It also shows
that instead of applicative and imperative programming being mutually
exclusive, their combination makes it possible to integrate in the
same program complex symbolic computations and a good interface with
the operating system.</p><p>These notes assume the reader is familiar with OCaml and Unix shell
commands. For any question about the language, consult the OCaml
System documentation [<a href="#OCaml">2</a>] and for questions about Unix,
read section 1 of the Unix <span class="c001">man</span>ual or introductory books on Unix
like [<a href="#KP">5</a>, <a href="#R1">6</a>].</p><p>This document describes only the programmatic interface to the Unix
system. It presents neither its implementation, neither its internal
architecture. The internal architecture of <span class="c005">bsd</span> 4.3 is
described in [<a href="#BSD">8</a>] and of System <span class="c005">v</span>
in [<a href="#Bach">9</a>]. Tanenbaum’s books [<a href="#T1">13</a>, <a href="#T2">14</a>] give an overall view of
network and operating system architecture.</p><p>The Unix interface presented in this document is part of the
OCaml System available as free software at
<a href="http://caml.inria.fr/ocaml/"><span class="c001">http://caml.inria.fr/ocaml/</span></a>.

</p>
<!--TOC chapter id=sec3 Generalities-->
<h1 class="chapter" id="sec3"> 1  Generalities</h1><!--SEC END --><!--NAME generalities.html-->

<!--TOC section id=sec4 Modules <span class="c001">Sys</span> and <span class="c001">Unix</span>-->
<h2 class="section" id="sec4">1.1  Modules <span class="c001">Sys</span> and <span class="c001">Unix</span></h2><!--SEC END --><p>Functions that give access to the system from OCaml are grouped into two
modules. The first module, <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html"><span class="c001">Sys</span></a>, contains those functions
common to Unix and other operating systems under which OCaml runs.
The second module, <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html"><span class="c001">Unix</span></a>, contains everything specific to
Unix. </p><p>In what follows, we will refer to identifiers from the <code>Sys</code> and
<code>Unix</code> modules without specifying which modules they come from. That is, we
will suppose that we are within the scope of the directives 
<code><span class="c006">open</span> Sys</code> and <code><span class="c006">open</span> Unix</code>. In complete examples, we explicitly write
<code><span class="c006">open</span></code>, in order to be truly complete.</p><p>The <code>Sys</code> and <code>Unix</code> modules can redefine certain
identifiers of the <code>Pervasives</code> module, hiding previous
definitions. For example, <code>Pervasives.stdin</code> is different from 
<code>Unix.stdin</code>. The previous definitions can always be obtained
through a prefix.</p><p>To compile an OCaml program that uses the 
Unix library, do this:
</p><div class="mylisting">ocamlc -o prog unix.cma mod1.ml mod2.ml mod3.ml</div><p>where the program <code>prog</code> is assumed to comprise of the three modules <code>mod1</code>,
<code>mod2</code> and <code>mod3</code>. The modules can also be compiled separately:
</p><div class="mylisting">ocamlc -c mod1.ml
ocamlc -c mod2.ml
ocamlc -c mod3.ml</div><p>and linked with:
</p><div class="mylisting">ocamlc -o prog unix.cma mod1.cmo mod2.cmo mod3.cmo</div><p>In both cases, the argument <code>unix.cma</code> is the <code>Unix</code> library
written in OCaml. To use the native-code compiler rather than the
bytecode compiler, replace <code>ocamlc</code> with <code>ocamlopt</code> and
<code>unix.cma</code> with <code>unix.cmxa</code>.</p><p>If the compilation tool <code>ocamlbuild</code> is used, simply add the
following line to the 
<code>_tags</code> file:
</p><div class="mylisting">&lt;prog.{native,byte}&gt; : use_unix</div><p>The Unix system can also be accessed from the interactive system,
also known as the “toplevel”. If your platform supports dynamic
linking of C libraries, start an <code>ocaml</code> toplevel and type in the
directive:
</p><div class="mylisting"><span class="c006">#</span>load "unix.cma";;</div><p>Otherwise, you will need to create an interactive system containing
the pre-loaded system functions:
</p><div class="mylisting">ocamlmktop -o ocamlunix unix.cma</div><p>This toplevel can be started by:
</p><div class="mylisting">./ocamlunix</div>
<!--TOC section id=sec5 Interface with the calling program-->
<h2 class="section" id="sec5">1.2  Interface with the calling program</h2><!--SEC END --><p>When running a program from a shell (command interpreter), the shell
passes <em>arguments</em> and an <em>environment</em> to the program. The
arguments are words on the command line that follow the name of the
command. The environment is a set of strings of the form
<span class="c001">variable=value</span>, representing the global bindings of environment
variables: bindings set with <span class="c001">setenv var=val</span> for the
<span class="c001">csh</span> shell, or with <span class="c001">var=val; export var</span> for
the <span class="c001">sh</span> shell.</p><p>The arguments passed to the program are in the string array
<code>Sys.argv</code>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html#VALargv">argv</a><a id="hevea_default0"></a> : string array</div><p>The environment of the program is obtained by the function
<code>Unix.environment</code>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALenvironment">environment</a><a id="hevea_default1"></a> : unit -&gt; string array</div><p>A more convenient way of looking up the environment is to use the
function <code>Sys.getenv</code>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html#VALgetenv">getenv</a><a id="hevea_default2"></a> : string -&gt; string</div><p><code>Sys.getenv v</code> returns the value associated with the variable name
<code>v</code> in 
the environment, raising the exception <code>Not_found</code> if this 
variable is not bound.
</p><div class="example">
<!--TOC paragraph id=sec6 Example-->
<h5 class="paragraph" id="sec6">Example</h5><!--SEC END --><p>
As a first example, here is the <code>echo</code> program, which prints a
list of its arguments, as does the Unix command of the same name.
</p><div class="mylisting"><span class="c006">let</span> echo () =
  <span class="c006">let</span> len = Array.length Sys.argv <span class="c006">in
  if</span> len &gt; 1 <span class="c006">then
    begin</span>
      print_string Sys.argv.(1);
      <span class="c006">for</span> i = 2 <span class="c006">to</span> len - 1 <span class="c006">do</span>
        print_char ' ';
        print_string Sys.argv.(i);
      <span class="c006">done</span>;
      print_newline ();
    <span class="c006">end</span>;;
echo ();;</div><div class="fancybreak">* * *</div></div><p>A program can be terminated at any point with a call to <code>exit</code>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALexit">exit</a><a id="hevea_default3"></a> : int -&gt; 'a</div><p>The argument is the return code to send back to the calling program. The
convention is to return 0 if all has gone well, and to return a
non-zero code to signal an error. In conditional constructions, the
<code>sh</code> shell interprets the return code 0 as the boolean
“true”, and all non-zero codes as the boolean “false”.
When a program terminates normally after executing all of the
expressions of which it is composed, it makes an implicit call to
<code>exit 0</code>. When a program terminates prematurely because an
exception was raised but not caught, it makes an implicit call to
<code>exit 2</code>.
The function <code>exit</code> always flushes the buffers of all channels open for
writing. The function <code>at_exit</code> lets one register other actions
to be carried out when the program terminates.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALat_exit">at_exit</a><a id="hevea_default4"></a> : (unit -&gt; unit) -&gt; unit</div><p>The last function to be registered is called first. A function registered with
<code>at_exit</code> cannot be unregistered. However, this is not a
real restriction: we can easily get the same effect with a function
whose execution depends on a global variable.</p>
<!--TOC section id=sec7 Error handling-->
<h2 class="section" id="sec7">1.3  Error handling</h2><!--SEC END --><p>Unless otherwise indicated, all functions in the <code>Unix</code> module
raise the exception <code>Unix_error</code> in case of error.

</p><div class="mylisting"><span class="c006">exception</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#EXCEPTIONUnix_error">Unix_error</a> <span class="c006">of</span> error * string * string</div><p>The second argument of the <code>Unix_error</code> exception is the name of
the system call that raised the error. The third argument identifies,
if possible, the object on which the error occurred; for example, in
the case of a system call taking a file name as an argument, this file name will be
in the third position in <code>Unix_error</code>. Finally, the first argument
of the exception is an error code indicating the nature of the
error. It belongs to the variant type <code>error</code>:
</p><div class="mylisting"><span class="c006">type</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEerror">error</a> = E2BIG | EACCES | EAGAIN | ...  | EUNKNOWNERR <span class="c006">of</span> int</div><p>Constructors of this type have the same names and meanings as those
used in the <span class="c005">posix</span> convention and certain errors from
<span class="c005">unix98</span> and <span class="c005">bsd</span>. All other errors use the constructor <code>EUNKOWNERR</code>.</p><p>Given the semantics of exceptions, an error that is not specifically
foreseen and intercepted by a <code><span class="c006">try</span></code> propagates up to the top of a
program and causes it to terminate prematurely. In small
applications, treating unforeseen errors as fatal is a good practice.
However, it is appropriate to display the error clearly. To do this,
the <code>Unix</code> module supplies the <code>handle_unix_error</code> function:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALhandle_unix_error">handle_unix_error</a><a id="hevea_default5"></a> : ('a -&gt; 'b) -&gt; 'a -&gt; 'b</div><p>The call <code>handle_unix_error f x</code> applies function <code>f</code> to the
argument <code>x</code>. If this raises the exception <code>Unix_error</code>, a
message is displayed describing the error, and the program is
terminated with <code>exit 2</code>. A typical use is
</p><div class="mylisting">handle_unix_error prog ();;</div><p>where the function <code>prog : unit -&gt; unit</code> executes the body of the
program. For reference, here is how <code>handle_unix_error</code> is
implemented.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">open</span> Unix;;
<span class="c003">   2</span> <span class="c006">let</span> handle_unix_error f arg =
<span class="c003">   3</span>   <span class="c006">try</span>
<span class="c003">   4</span>     f arg
<span class="c003">   5</span>   <span class="c006">with</span> Unix_error(err, fun_name, arg) -&gt;
<span class="c003">   6</span>     prerr_string Sys.argv.(0); <a id="prog:argv"></a>
<span class="c003">   7</span>     prerr_string ": \"";
<span class="c003">   8</span>     prerr_string fun_name;
<span class="c003">   9</span>     prerr_string "\" failed";
<span class="c003">  10</span>     <span class="c006">if</span> String.length arg &gt; 0 <span class="c006">then begin</span>
<span class="c003">  11</span>       prerr_string " on \"";
<span class="c003">  12</span>       prerr_string arg;
<span class="c003">  13</span>       prerr_string "\""
<span class="c003">  14</span>     <span class="c006">end</span>;
<span class="c003">  15</span>     prerr_string ": ";
<span class="c003">  16</span>     prerr_endline (error_message err); <a id="prog:errmsg"></a>
<span class="c003">  17</span>     exit 2;;</div><p>Functions of the form <code>prerr_xxx</code> are like the functions
<code>print_xxx</code>, except that they write on the error channel
<code>stderr</code> rather than on the standard output channel <code>stdout</code>.</p><p>The primitive <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALerror_message"><span class="c001">error_message</span></a><a id="hevea_default6"></a>, of type 
<code>error -&gt; string</code>, returns a message describing the error given as an
argument (line <a href="#prog%3Aerrmsg">16</a>). The argument number zero of the
program, namely <code>Sys.argv.(0)</code>, contains the name of the command
that was used to invoke the program (line <a href="#prog%3Aargv">6</a>).</p><p>The function <code>handle_unix_error</code> handles fatal errors, i.e. errors
that stop the program. An advantage of OCaml is that it requires
all errors to be handled, if only at the highest level by
halting the program. Indeed, any error in a system call raises an
exception, and the execution thread in progress is interrupted up to
the level where the exception is explicitly caught and handled. This avoids
continuing the program in an inconsistent state.</p><p>Errors of type <code>Unix_error</code> can, of course, be
selectively matched. We will often see the following
function later on:
</p><div class="mylisting"><span class="c006">let rec</span> restart_on_EINTR f x =
  <span class="c006">try</span> f x <span class="c006">with</span> Unix_error (EINTR, _, _) -&gt; restart_on_EINTR f x</div><p>which is used to execute a function and to restart it automatically
when it executes a system call that is interrupted (see section <a href="#sec88">4.5</a>).</p>
<!--TOC section id=sec8 Library functions-->
<h2 class="section" id="sec8">1.4  Library functions</h2><!--SEC END --><p>As we will see throughout the examples, system programming often
repeats the same patterns. To reduce the code of each application to
its essentials, we will want to define library functions that
factor out the common parts.</p><p>Whereas in a complete program one knows precisely which errors can be
raised (and these are often fatal, resulting in the program being stopped),
we generally do not know the execution context in the case of library functions. We
cannot suppose that all errors are fatal. It is therefore necessary to
let the error return to the caller, which will decide on a suitable
course of action (e.g. stop the program, or handle or ignore the error). However,
the library function in general will not allow the error to simply pass
through, since it must maintain the system in a consistent state. For
example, a library function that opens a file and then applies an
operation to its file descriptor must take care to close the
descriptor in all cases, including those where the processing of the
file causes an error. This is in order to avoid a file descriptor
leak, leading to the exhaustion of file descriptors.</p><p>Furthermore, the operation applied to a file may be defined by a
function that was received as an argument, and we don’t know precisely
when or how it can fail (but the caller in general will know). We are
thus often led to protect the body of the processing with
“finalization” code, which must be executed just before the
function returns, whether normally or exceptionally.</p><p>There is no built-in finalize construct <code><span class="c006">try</span></code> …<code>finalize</code> in
the OCaml language, but it can be easily defined<sup><a id="text1" href="#note1">1</a></sup>:

</p><div class="mylisting"><span class="c006">let</span> try_finalize f x finally y =
  <span class="c006">let</span> res = <span class="c006">try</span> f x <span class="c006">with</span> exn -&gt; finally y; raise exn <span class="c006">in</span>
  finally y;
  res</div><p>This function takes the main body <code>f</code> and the finalizer
<code>finally</code>, each in the form of a function, and two parameters <code>x</code>
and <code>y</code>, which are passed to their respective functions. The body
of the program <code>f x</code> is executed first, and its result is kept
aside to be returned after the execution of the finalizer 
<code>finally</code>. In case the program fails, i.e. raises an exception <code>exn</code>,
the finalizer is run and the exception <code>exn</code> is raised
again. If both the main function and the finalizer fail, the
finalizer’s exception is raised (one could choose to have the main
function’s exception raised instead).</p>
<!--TOC paragraph id=sec9 Note-->
<h5 class="paragraph" id="sec9">Note</h5><!--SEC END --><p>In the rest of this course, we use an auxiliary library <code>Misc</code>
which contains several useful functions like <code>try_finalize</code> that are often
used in the examples. We will introduce them as they are needed. To
compile the examples of the course, the definitions of the <code>Misc</code>
module need to be collected and compiled.</p><p>The <code>Misc</code> module also contains certain functions, added for
illustration purposes, that will not be used in the course. These
simply enrich the <code>Unix</code> library, sometimes by redefining the
behavior of certain functions. The <code>Misc</code> module must thus take
precedence over the <code>Unix</code> module.</p>
<!--TOC paragraph id=sec10 Examples-->
<h5 class="paragraph" id="sec10">Examples</h5><!--SEC END --><p>The course provides numerous examples. They can be compiled with
OCaml, version <span class="c001">4.01.0</span>. Some programs will have to be slightly modified in order to work with 
older versions.</p><p>There are two kinds of examples: “library functions” (very
general functions that can be reused) and small applications. It is
important to distinguish between the two. In the case of library functions, we
want their context of use to be as general as possible. We will thus
carefully specify their interface and attentively treat all
particular cases. In the case of small applications, an error is often
fatal and causes the program to stop executing. It is sufficient to report
the cause of an error, without needing to return to a consistent state, since
the program is stopped immediately thereafter.

</p>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">A
built-in construct would not be less useful.</div>
</dd></dl>
<!--END NOTES-->
<!--TOC chapter id=sec11 Files-->
<h1 class="chapter" id="sec11"> 2  Files</h1><!--SEC END --><!--NAME files.html-->
<p>The term “file” in Unix covers several types of objects:
</p><ul class="itemize"><li class="li-itemize">
standard files: finite sets of bytes containing text or binary
information, often referred to as “ordinary” files,
</li><li class="li-itemize">directories,
</li><li class="li-itemize">symbolic links,
</li><li class="li-itemize">special files (<em>devices</em>), which primarily provide access
to computer peripherals,
</li><li class="li-itemize">named pipes,
</li><li class="li-itemize">sockets named in the Unix domain.
</li></ul><p>
The file concept includes both the data contained in the file and
information about the file itself (also called meta-data) like its
type, its access rights, the latest access times, etc.</p>
<!--TOC section id=sec12 The file system-->
<h2 class="section" id="sec12">2.1  The file system</h2><!--SEC END --><p>To a first approximation, the file system can be considered to be a tree. The root is
represented by <code>'/'</code>. The branches are labeled by (file) names,
which are strings of any characters excluding <code>'\000'</code> and <code>'/'</code>
(but it is good practice to also avoid non-printing characters and
spaces). The non-terminal nodes are <em>directories</em>: these nodes
always contain two branches <code>.</code> and <code>..</code> which respectively
represent the directory itself and the directory’s parent. The other
nodes are sometimes called <em>files</em>, as opposed to directories,
but this is ambiguous, as we can also designate any node as a
“file”. To avoid all ambiguity we refer to them as
<em>non-directory files</em>.</p><p>The nodes of the tree are addressed by paths. If the start of the path
is the root of the file hierarchy, the path is <em>absolute</em>, whereas if the
start is a directory it is <em>relative</em>. More precisely, a <em>relative
path</em> is a string of file names separated by the character
<code>'/'</code>. An <em>absolute path</em> is a relative path preceded by the
the character <code>'/'</code> (note the double use of this character both as
a separator and as the name of the root node).</p><p>The <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html"><span class="c001">Filename</span></a> module handles paths in a portable
manner. In particular, <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALconcat"><span class="c001">concat</span></a> concatenates paths without
referring to the character <code>'/'</code>, allowing the code to function equally
well on other operating systems (for example, the path separator character
under Windows is <code>'\'</code>). Similarly, the <code>Filename</code> module
provides the string values <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALcurrent_dir_name"><span class="c001">current_dir_name</span></a> and
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALparent_dir_name"><span class="c001">parent_dir_name</span></a> to represent the branches
<code>.</code> and <code>..</code> The functions <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALbasename"><span class="c001">basename</span></a> and
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALdirname"><span class="c001">dirname</span></a> return the prefix <code>d</code> and the suffix
<code>b</code> from a path <code>p</code> such that the paths <code>p</code> and
<code>d/b</code> refer to the same file, where <code>d</code> is the directory in
which the file is found and <code>b</code> is the name of the file. The
functions defined in <code>Filename</code> operate only on paths,
independently of their actual existence within the file hierarchy.</p><p>In fact, strictly speaking, the file hierarchy is not a tree. First
the directories <code>.</code> and <code>..</code> allow a directory to refer to
itself and to move up in the hierarchy to define paths leading from a
directory to itself. Moreover, non-directory files can have many
parents (we say that they have many <em>hard links</em>). Finally,
there are also <em>symbolic links</em> which can be seen as
non-directory files containing a path. Conceptually, this path can be
obtained by reading the contents of the symbolic link like an ordinary
file. Whenever a symbolic link occurs in the middle of a path we have
to follow its path transparently. If <code>s</code> is a symbolic link whose
value is the path <code>l</code>, then the path <code>p/s/q</code> represents the file
<code>l/q</code> if <code>l</code> is an absolute path or the file <code>p/l/q</code> if
<code>l</code> is a relative path.</p><p>Figure <a href="#fig%2Fhierarchy">1</a> gives an example of a file hierarchy. The
symbolic link <code>11</code> corresponding to the path <code>/tmp/bar</code> whose
path value is the relative path <code>../gnu</code>, does not refer to any
existing file in the hierarchy (at the moment).</p><div class="figure">
<div class="image"><img src="ocamlunix-image1.png" width="100%"></div>



<a id="fig/hierarchy"></a>
<div class="caption">Figure 1 — An example of a file hierarchy</div></div><p>In general, a recursive traversal of the hierarchy will terminate
if the following rules are respected:
</p><ul class="itemize"><li class="li-itemize">
the directories <code>.</code> and <code>..</code> are ignored.
</li><li class="li-itemize">symbolic links are not followed. 
</li></ul><p>
But if symbolic links are followed we are traversing a graph and
we need to keep track of the nodes we have already visited to avoid loops.</p><p>Each process has a current working directory. It is returned by the
function <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetcwd"><span class="c001">getcwd</span></a><a id="hevea_default7"></a> and can be changed with
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALchdir"><span class="c001">chdir</span></a><a id="hevea_default8"></a>. It is also possible to constrict the
view of the file hierarchy by calling 
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALchroot"><span class="c001">chroot</span></a><a id="hevea_default9"></a> <code>p</code>. This makes the node <code>p</code>, which 
should be a directory, the root of the restricted view of the
hierarchy. Absolute file paths are then
interpreted according to this new root <code>p</code> (and of course <code>..</code> at the
new root is <code>p</code> itself).</p>
<!--TOC section id=sec13 File names and file descriptors-->
<h2 class="section" id="sec13">2.2  File names and file descriptors</h2><!--SEC END --><p>There are two ways to access a file. The first is by its <em>file
name</em> (or <em>path name</em>) in the file system hierarchy. Due to
hard links, a file can have many different names. Names are values of
type <code>string</code>. For example the system calls <a href="http://www.opengroup.org/onlinepubs/009696799/functions/unlink.html"><span class="c001">unlink</span></a><a id="hevea_default10"></a>,
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/link.html"><span class="c001">link</span></a><a id="hevea_default11"></a>, <a href="http://www.opengroup.org/onlinepubs/009696799/functions/symlink.html"><span class="c001">symlink</span></a><a id="hevea_default12"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/rename.html"><span class="c001">rename</span></a><a id="hevea_default13"></a> all operate at
the file name level.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALunlink">unlink</a> : string -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlink">link</a> : string -&gt; string -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsymlink">symlink</a> : string -&gt; string -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrename">rename</a> : string -&gt; string -&gt; unit</div><p>Their effect is as follows:
</p><ul class="itemize"><li class="li-itemize">
<code>unlink f</code> erases the file <code>f</code> like the Unix command
<code>rm -f f</code>.
</li><li class="li-itemize"><code>link f1 f2</code> creates a hard link named <code>f2</code> to
the file <code>f1</code> like the command <code>ln f1 f2</code>.
</li><li class="li-itemize"><code>symlink f1 f2</code> creates a symbolic link named <code>f2</code> to the file 
<code>f1</code> like the command <code>ln -s f1 f2</code>. 
</li><li class="li-itemize"><code>rename f1 f2</code> renames the file <code>f1</code> to <code>f2</code> 
like the command <code>mv f1 f2</code>.
</li></ul><p>The second way of accessing a file is by a file descriptor. A
descriptor represents a pointer to a file along with other information
like the current read/write position in the file, the access rights of
the file (is it possible to read? write?) and flags which control the
behavior of reads and writes (blocking or non-blocking, overwrite,
append, etc.). File descriptors are values of the abstract type
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_descr"><span class="c001">file_descr</span></a>.</p><p>Access to a file via its descriptor is independent from the
access via its name. In particular whenever we get a file descriptor,
the file can be destroyed or renamed but the descriptor still points
on the original file.</p><p>When a program is executed, three descriptors are allocated and 
tied to the variables <code>stdin</code>, <code>stdout</code> and <code>stderr</code> of the
<code>Unix</code> module:

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstdin">stdin</a><a id="hevea_default14"></a> : file_descr
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstdout">stdout</a><a id="hevea_default15"></a> : file_descr
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstderr">stderr</a><a id="hevea_default16"></a> : file_descr</div><p>They correspond, respectively, to the standard input, standard output
and standard error of the process.</p><p>When a program is executed on the command line without any
redirections, the three descriptors refer to the terminal. But if,
for example, the input has been redirected using the shell expression
<code>cmd &lt; f</code>, then the descriptor <code>stdin</code> refers to the file named <code>f</code>
during the execution of the command <code>cmd</code>. Similarly, <code>cmd &gt; f</code>
and <code>cmd 2&gt; f</code> respectively bind the descriptors <code>stdout</code> and
<code>stderr</code> to the file named <code>f</code> during the execution of the
command.</p>
<!--TOC section id=sec14 Meta-attributes, types and permissions-->
<h2 class="section" id="sec14">2.3  Meta-attributes, types and permissions</h2><!--SEC END --><p>The system calls <a href="http://www.opengroup.org/onlinepubs/009696799/functions/stat.html"><span class="c001">stat</span></a><a id="hevea_default17"></a>, <a href="http://www.opengroup.org/onlinepubs/009696799/functions/lstat.html"><span class="c001">lstat</span></a><a id="hevea_default18"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/fstat.html"><span class="c001">fstat</span></a><a id="hevea_default19"></a>
return the meta-attributes of a file; that is, information about
the node itself rather than its content. Among other things, this
information contains the identity of the file, the type of file, the
access rights, the time and date of last access and other information.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstat">stat</a>  : string -&gt; stats
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlstat">lstat</a> : string -&gt; stats
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfstat">fstat</a> : file_descr -&gt; stats</div><p>The system calls <code>stat</code> and <code>lstat</code> take a file name as an
argument while <code>fstat</code> takes a previously opened descriptor and
returns information about the file it points to. <code>stat</code> and
<code>lstat</code> differ on symbolic links : <code>lstat</code> returns information
about the symbolic link itself, while <code>stat</code> returns information
about the file that the link points to. The result of these three
calls is a record of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEstats"><span class="c001">stats</span></a> whose fields are
described in table <a href="#fig%2Fstats">1</a>.
</p><div class="table">
<table class="c000 cellpading0"><tr><td class="c013">Field name</td><td class="c012">Description </td></tr>
<tr><td class="hbar" colspan=2></td></tr>
<tr><td class="c013"><code>st_dev : int</code></td><td class="c012">The id of the device on which the file is stored. </td></tr>
<tr><td class="c013"><code>st_ino : int</code></td><td class="c012">The id of the file (inode number) in its partition. 
The pair <code>(st_dev, st_ino)</code> uniquely identifies the file
within the file system. </td></tr>
<tr><td class="c013"><code>st_kind : file_kind</code></td><td class="c012">The file type. The type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_kind"><span class="c001">file_kind</span></a> is an enumerated type
whose constructors are: 
<div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>S_REG</code></td><td class="c010">Regular file </td></tr>
<tr><td class="c010"><code>S_DIR</code></td><td class="c010">Directory </td></tr>
<tr><td class="c010"><code>S_CHR</code></td><td class="c010">Character device </td></tr>
<tr><td class="c010"><code>S_BLK</code></td><td class="c010">Block device </td></tr>
<tr><td class="c010"><code>S_LNK</code></td><td class="c010">Symbolic link </td></tr>
<tr><td class="c010"><code>S_FIFO</code></td><td class="c010">Named pipe </td></tr>
<tr><td class="c010"><code>S_SOCK</code></td><td class="c010">Socket 
</td></tr>
</table>
</div>
</td></tr>
<tr><td class="c013"><code>st_perm : int</code></td><td class="c012">Access rights for the file </td></tr>
<tr><td class="c013"><code>st_nlink : int</code></td><td class="c012">For a directory: the number of entries in the directory. For others:
the number of hard links to this file. </td></tr>
<tr><td class="c013"><code>st_uid : int</code></td><td class="c012">The id of the file’s user owner. </td></tr>
<tr><td class="c013"><code>st_gid : int</code></td><td class="c012">The id of the file’s group owner. </td></tr>
<tr><td class="c013"><code>st_rdev : int</code></td><td class="c012">The id of the associated peripheral (for special files). </td></tr>
<tr><td class="c013"><code>st_size : int</code></td><td class="c012">The file size, in bytes. </td></tr>
<tr><td class="c013"><code>st_atime : int</code></td><td class="c012">Last file content access date (in seconds from
January 1st 1970, midnight, <span class="c005">gmt</span>). </td></tr>
<tr><td class="c013"><code>st_mtime : int</code></td><td class="c012">Last file content modification date (idem).</td></tr>
<tr><td class="c013"><code>st_ctime : int</code></td><td class="c012">Last file state modification date: either a
write to the file or a change in access rights, user or group owner,
or number of links.
<br>
</td></tr>
<tr><td class="hbar" colspan=2></td></tr>
</table>

<a id="fig/stats"></a>
<div class="caption">Table 1 — Fields of the <code>stats</code> structure</div></div><!--TOC subsection id=sec15 Identification-->
<h3 class="subsection" id="sec15">Identification</h3><!--SEC END --><p>A file is uniquely identified by the pair made of its device number
(typically the disk partition where it is located) <code>st_dev</code> and its
inode number <code>st_ino</code>.</p><!--TOC subsection id=sec16 Owners-->
<h3 class="subsection" id="sec16">Owners</h3><!--SEC END --><p>A file has one user owner <code>st_uid</code> and one group owner
<code>st_gid</code>. All the users and groups 
on the machine are usually described in the 
<code>/etc/passwd</code> and <code>/etc/groups</code> files. We can look up them by
name in a portable manner with the functions <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getpwnam.html"><span class="c001">getpwnam</span></a><a id="hevea_default20"></a> and 
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/getgrnam.html"><span class="c001">getgrnam</span></a><a id="hevea_default21"></a> or by id with 
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/getpwuid.html"><span class="c001">getpwuid</span></a><a id="hevea_default22"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getgrgid.html"><span class="c001">getgrgid</span></a><a id="hevea_default23"></a>.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetpwnam">getpwnam</a> : string -&gt; passwd_entry
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetgrnam">getgrnam</a> : string -&gt; group_entry
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetpwuid">getpwuid</a> : int -&gt; passwd_entry
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetgrgid">getgrgid</a> : int -&gt; group_entry</div><p>The name of the user of a running process and all the groups
to which it belongs can be retrieved with the commands
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/getlogin.html"><span class="c001">getlogin</span></a><a id="hevea_default24"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getgroups.html"><span class="c001">getgroups</span></a><a id="hevea_default25"></a>.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetlogin">getlogin</a> : unit -&gt; string
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetgroups">getgroups</a> : unit -&gt; int array</div><p>The call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/chown.html"><span class="c001">chown</span></a><a id="hevea_default26"></a> changes the owner (second argument) and the
group (third argument) of a file (first argument). If we have a file
descriptor, <a href="http://www.opengroup.org/onlinepubs/009696799/functions/fchown.html"><span class="c001">fchown</span></a><a id="hevea_default27"></a> can be used instead. Only the super user
can change this information arbitrarily.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALchown">chown</a> : string -&gt; int -&gt; int -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfchown">fchown</a> : file_descr -&gt; int -&gt; int -&gt; unit</div><!--TOC subsection id=sec17 Access rights-->
<h3 class="subsection" id="sec17">Access rights</h3><!--SEC END --><p>Access rights are encoded as bits in an integer, and the type
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_perm"><span class="c001">file_perm</span></a> is just an abbreviation for the type
<code>int</code>. They specify special bits and read, write and
execution rights for the user owner, the group owner and the other
users as vector of bits:
</p><div class="center">
<table class="cellpadding1" border=1 style="border-spacing:0;"><tr><td class="c008" colspan=3><span class="c001">S</span>pecial</td><td class="c008" colspan=3><span class="c001">U</span>ser</td><td class="c008" colspan=3><span class="c001">G</span>roup</td><td class="c008" colspan=3><span class="c001">O</span>ther </td></tr>
<tr><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td><td class="c008">–</td></tr>
<tr><td class="c008" colspan=12><code>OoSUGO</code>
</td></tr>
</table>
</div><p>

where in each of the user, group and other fields, the order of bits
indicates read (<code>r</code>), write (<code>w</code>) and execute (<code>x</code>) rights.
The permissions on a file are the union of all these individual
rights, as shown in table <a href="#sec17">2</a>.</p><div class="table">
<table class="c000 cellpading0"><tr><td class="c010">Bit (octal)</td><td class="c009">Notation <code>ls -l</code></td><td class="c010">Access right </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c010"><code>0o100</code></td><td class="c009"><code>--x------</code></td><td class="c010">executable by the user owner </td></tr>
<tr><td class="c010"><code>0o200</code></td><td class="c009"><code>-w-------</code></td><td class="c010">writable by the user owner </td></tr>
<tr><td class="c010"><code>0o400</code></td><td class="c009"><code>r--------</code></td><td class="c010">readable by the user owner </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c010"><code>0o10</code></td><td class="c009"><code>-----x---</code></td><td class="c010"> executable by members of the group owner </td></tr>
<tr><td class="c010"><code>0o20</code></td><td class="c009"><code>----w----</code></td><td class="c010"> writable by members of the group owner </td></tr>
<tr><td class="c010"><code>0o40</code></td><td class="c009"><code>---r----</code></td><td class="c010"> readable by members of the group owner </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c010"><code>0o1</code></td><td class="c009"><code>--------x</code></td><td class="c010">executable by other users</td></tr>
<tr><td class="c010"><code>0o2</code></td><td class="c009"><code>-------w-</code></td><td class="c010">writable by other users </td></tr>
<tr><td class="c010"><code>0o4</code></td><td class="c009"><code>------r--</code></td><td class="c010">readable by other users </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c010"><code>0o1000</code></td><td class="c009"><code>--------t</code></td><td class="c010">the bit <code>t</code> on the group (sticky bit)</td></tr>
<tr><td class="c010"><code>0o2000</code></td><td class="c009"><code>-----s---</code></td><td class="c010">the bit <code>s</code> on the group (<code>set-gid</code>)</td></tr>
<tr><td class="c010"><code>0o4000</code></td><td class="c009"><code>--s------</code></td><td class="c010">the bit <code>s</code> on the user (<code>set-uid</code>)</td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>

<div class="caption">Table 2 — Permission bits</div></div><p>For files, the meaning of read, write and execute permissions is
obvious. For a directory, the execute permission means the right to
enter it (to <code>chdir</code> to it) and read permission the right to list
its contents. Read permission on a directory is however not needed to
read its files or sub-directories (but we then need to know their
names).</p><p>The special bits do not have meaning unless the <code>x</code> bit is set (if
present without <code>x</code> set, they do not give additional rights). This
is why their representation is superimposed on the bit <code>x</code> and
the letters <code>S</code> and <code>T</code> are used instead of <code>s</code> and <code>t</code>
whenever <code>x</code> is not set. The bit <code>t</code> allows sub-directories to
inherit the permissions of the parent directory. On a directory, 
the bit <code>s</code> allows the use of the directory’s <code>uid</code> or <code>gid</code> rather
than the user’s to create directories. For an executable file, 
the bit <code>s</code> allows the changing at execution time of the user’s
effective identity or group with the system calls <a href="http://www.opengroup.org/onlinepubs/009696799/functions/setuid.html"><span class="c001">setuid</span></a><a id="hevea_default28"></a> 
and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/setgid.html"><span class="c001">setgid</span></a><a id="hevea_default29"></a>.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetuid">setuid</a> : int -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetgid">setgid</a> : int -&gt; unit</div><p>The process also preserves its original identities unless 
it has super user privileges, in which case <code>setuid</code> and
<code>setgid</code> change both its effective and original user and group
identities. The original identity is preserved to allow 
the process to subsequently recover it as its effective identity
without needing further privileges. The system calls <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getuid.html"><span class="c001">getuid</span></a><a id="hevea_default30"></a> and 
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/getgid.html"><span class="c001">getgid</span></a><a id="hevea_default31"></a> return the original identities and 
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/geteuid.html"><span class="c001">geteuid</span></a><a id="hevea_default32"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getegid.html"><span class="c001">getegid</span></a><a id="hevea_default33"></a> return the effective identities.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetuid">getuid</a> : unit -&gt; int
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgeteuid">geteuid</a> : unit -&gt; int
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetgid">getgid</a> : unit -&gt; int
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetegid">getegid</a> : unit -&gt; int</div><p>A process also has a file creation mask encoded the same way file
permissions are. As its name suggests, the mask specifies prohibitions
(rights to remove): during file creation a bit set to 1 in the
mask is set to 0 in the permissions of the created file. The mask
can be consulted and changed with the system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/umask.html"><span class="c001">umask</span></a><a id="hevea_default34"></a>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALumask">umask</a> : int -&gt; int</div><p>Like many system calls that modify system variables, the modifying
function returns the old value of the variable. Thus, to just look up
the value we need to call the function twice. Once with an arbitrary
value to get the mask and a second time to put it back. For example:

</p><div class="mylisting"><span class="c006">let</span> m = umask 0 <span class="c006">in</span> ignore (umask m); m</div><p>File access permissions can be modified with the system calls
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/chmod.html"><span class="c001">chmod</span></a><a id="hevea_default35"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/fchmod.html"><span class="c001">fchmod</span></a><a id="hevea_default36"></a>:

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALchmod">chmod</a> : string -&gt; file_perm -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfchmod">fchmod</a> : file_descr -&gt; file_perm -&gt; unit</div><p>and they can be tested “dynamically” with the system 
call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/access.html"><span class="c001">access</span></a><a id="hevea_default37"></a>:
</p><div class="mylisting"><span class="c006">type</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEaccess_permission">access_permission</a> = R_OK | W_OK | X_OK | F_OK
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALaccess">access</a> : string -&gt; access_permission list -&gt; unit</div><p>where requested access rights to the file are specified by a list of
values of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEaccess_permission"><span class="c001">access_permission</span></a> whose meaning is 
obvious except for <code>F_OK</code> which just checks for the file’s
existence (without checking for the other rights). The function
raises an error if the access rights are not granted.</p><p>Note that the information inferred by <code>access</code> may be more
restrictive than the information returned by <code>lstat</code> because a file
system may be mounted with restricted rights — for example in
read-only mode. In that case <code>access</code> will deny a write permission
on a file whose meta-attributes would allow it. This is why we
distinguish between “dynamic” (what a process can actually do)
and “static” (what the file system specifies) information.</p>
<!--TOC section id=sec18 Operations on directories-->
<h2 class="section" id="sec18">2.4  Operations on directories</h2><!--SEC END --><p>Only the kernel can write in directories (when files are
created). Thus opening a directory in write mode is prohibited. In
certain versions of Unix a directory may be opened in read only mode
and read with <span class="c001">read</span><a id="hevea_default38"></a>, but other versions prohibit
it. However, even if this is possible, it is preferable not to do so
because the format of directory entries vary between Unix versions and
is often complex. The following functions allow reading a directory
sequentially in a portable manner:

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALopendir">opendir</a>   : string -&gt; dir_handle
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALreaddir">readdir</a>   : dir_handle -&gt; string
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrewinddir">rewinddir</a> : dir_handle -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALclosedir">closedir</a>  : dir_handle -&gt; unit</div><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/opendir.html"><span class="c001">opendir</span></a><a id="hevea_default39"></a> returns a directory descriptor for a
directory. <a href="http://www.opengroup.org/onlinepubs/009696799/functions/readdir.html"><span class="c001">readdir</span></a><a id="hevea_default40"></a> reads the next entry of a descriptor, and
returns a file name relative to the directory or raises the exception
<code>End_of_file</code> if the end of the directory is
reached. <a href="http://www.opengroup.org/onlinepubs/009696799/functions/rewinddir.html"><span class="c001">rewinddir</span></a><a id="hevea_default41"></a> repositions the descriptor at the
beginning of the directory and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/closedir.html"><span class="c001">closedir</span></a><a id="hevea_default42"></a> closes the directory
descriptor.</p><div class="example">
<!--TOC paragraph id=sec19 Example-->
<h5 class="paragraph" id="sec19">Example</h5><!--SEC END --><p>
The following library function, in <code>Misc</code>, iterates a
function <code>f</code> over the entries of the directory <code>dirname</code>.


</p><div class="mylisting"><span class="c006">let</span> iter_dir f dirname =
  <span class="c006">let</span> d = opendir dirname <span class="c006">in
  try while true do</span> f (readdir d) <span class="c006">done
  with</span> End_of_file -&gt; closedir d</div><div class="fancybreak">* * *</div></div><p>To create a directory or remove an empty directory, we have
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/mkdir.html"><span class="c001">mkdir</span></a><a id="hevea_default43"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/rmdir.html"><span class="c001">rmdir</span></a><a id="hevea_default44"></a>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALmkdir">mkdir</a> : string -&gt; file_perm -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrmdir">rmdir</a> : string -&gt; unit</div><p>The second argument of <code>mkdir</code> determines the access rights of the
new directory. Note that we can only remove a directory that is
already empty. To remove a directory and its contents, it is thus
necessary to first recursively empty the contents of the directory and
then remove the directory.</p>
<!--TOC section id=sec20 Complete example: search in a file hierarchy-->
<h2 class="section" id="sec20">2.5  Complete example: search in a file hierarchy</h2><!--SEC END --><p>The Unix command <code>find</code> lists the files of a hierarchy matching
certain criteria (file name, type and permissions etc.). In this
section we develop a library function <code>Findlib.find</code> which
implements these searches and a command <code>find</code> that provides a version
of the Unix command <code>find</code> that supports the options <code>-follow</code>
and <code>-maxdepth</code>.</p><p>We specify the following interface for <code>Findlib.find</code>:
</p><div class="mylisting"><span class="c006">val</span> find :
  (Unix.error * string * string -&gt; unit) -&gt;
  (string -&gt; Unix.stats -&gt; bool) -&gt; bool -&gt; int -&gt; string list -&gt;
  unit</div><p>The function call
</p><div class="mylisting">find handler action follow depth roots</div><p>traverses the file hierarchy starting from the roots specified in the
list <code>roots</code> (absolute or relative to the current directory of the
process when the call is made) up to a maximum depth <code>depth</code> and following
symbolic links if the flag <code>follow</code> is set. The paths found under
the root <code>r</code> include <code>r</code> as a prefix. Each found path <code>p</code> is
given to the function <code>action</code> along with the data returned by
<code>Unix.lstat p</code> (or <code>Unix.stat p</code> if <code>follow</code> is <code><span class="c006">true</span></code>).
The function <code>action</code> returns a boolean indicating, for
directories, whether the search should continue for its contents (<code><span class="c006">true</span></code>)
or not (<code><span class="c006">false</span></code>).</p><p>The <code>handler</code> function reports traversal errors of type
<code>Unix_error</code>. Whenever an error occurs the arguments of the
exception are given to the handler function and the traversal
continues. However when an exception is raised by the functions
<code>action</code> or <code>handler</code> themselves, we immediately stop the
traversal and let it propagate to the caller. To propagate an
<code>Unix_error</code> exception without catching it like a traversal error,
we wrap these exceptions in the <code>Hidden</code> exception (see
<code>hide_exn</code> and <code>reveal_exn</code>).
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">open</span> Unix;;
<span class="c003">   2</span> 
<span class="c003">   3</span> <span class="c006">exception</span> Hidden <span class="c006">of</span> exn
<span class="c003">   4</span> <span class="c006">let</span> hide_exn f x = <span class="c006">try</span> f x <span class="c006">with</span> exn -&gt; raise (Hidden exn);;
<span class="c003">   5</span> <span class="c006">let</span> reveal_exn f x = <span class="c006">try</span> f x <span class="c006">with</span> Hidden exn -&gt; raise exn;;
<span class="c003">   6</span> 
<span class="c003">   7</span> <span class="c006">let</span> find on_error on_path follow depth roots =
<span class="c003">   8</span>   <span class="c006">let rec</span> find_rec depth visiting filename =
<span class="c003">   9</span>     <span class="c006">try</span>
<span class="c003">  10</span>       <span class="c006">let</span> infos = (<span class="c006">if</span> follow <span class="c006">then</span> stat <span class="c006">else</span> lstat) filename <span class="c006">in</span>
<span class="c003">  11</span>       <span class="c006">let</span> continue = hide_exn (on_path filename) infos <span class="c006">in</span>
<span class="c003">  12</span>       <span class="c006">let</span> id = infos.st_dev, infos.st_ino <span class="c006">in</span> <a id="prog:did"></a>
<span class="c003">  13</span>       <span class="c006">if</span> infos.st_kind = S_DIR &amp;&amp; depth &gt; 0 &amp;&amp; continue &amp;&amp;
<span class="c003">  14</span>         (not follow || not (List.mem id visiting))
<span class="c003">  15</span>       <span class="c006">then</span>
<span class="c003">  16</span>         <span class="c006">let</span> process_child child =
<span class="c003">  17</span>           <span class="c006">if</span> (child &lt;&gt; Filename.current_dir_name &amp;&amp;
<span class="c003">  18</span>               child &lt;&gt; Filename.parent_dir_name) <span class="c006">then</span>
<span class="c003">  19</span>             <span class="c006">let</span> child_name = Filename.concat filename child <span class="c006">in</span>
<span class="c003">  20</span>             <span class="c006">let</span> visiting =
<span class="c003">  21</span>               <span class="c006">if</span> follow <span class="c006">then</span> id :: visiting <span class="c006">else</span> visiting <span class="c006">in</span> <a id="prog:follow"></a>
<span class="c003">  22</span>             find_rec (depth-1) visiting child_name <span class="c006">in</span>
<span class="c003">  23</span>         Misc.iter_dir process_child filename
<span class="c003">  24</span>     <span class="c006">with</span> Unix_error (e, b, c) -&gt; hide_exn on_error (e, b, c) <span class="c006">in</span>
<span class="c003">  25</span>   reveal_exn (List.iter (find_rec depth [])) roots;;</div><p>A directory is identified by the <code>id</code> pair (line <a href="#prog%3Adid">12</a>)
made of its device and inode number. The list <code>visiting</code> keeps
track of the directories that have already been visited. In fact
this information is only needed if symbolic links are followed
(line <a href="#prog%3Afollow">21</a>).</p><p>It is now easy to program the <code>find</code> command. The essential part of
the code parses the command line arguments with the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Arg.html"><span class="c001">Arg</span></a>
module.
</p><div class="mylisting"><span class="c006">let</span> find () =
  <span class="c006">let</span> follow = <span class="c006">ref false in
  let</span> maxdepth = <span class="c006">ref</span> max_int <span class="c006">in
  let</span> roots = <span class="c006">ref</span> [] <span class="c006">in
  let</span> usage_string  =
    ("Usage: " ^ Sys.argv.(0) ^ " [files...] [options...]") <span class="c006">in
  let</span> opt_list =  [
    "-maxdepth", Arg.Int ((:=) maxdepth), "max depth search";
    "-follow", Arg.Set follow, "follow symbolic links";
  ] <span class="c006">in</span>
  Arg.parse opt_list (<span class="c006">fun</span> f -&gt; roots := f :: !roots) usage_string;
  <span class="c006">let</span> action p infos = print_endline p; <span class="c006">true in
  let</span> errors = <span class="c006">ref false in
  let</span> on_error (e, b, c) =
    errors := <span class="c006">true</span>; prerr_endline (c ^ ": " ^ Unix.error_message e) <span class="c006">in</span>
  Findlib.find on_error action !follow !maxdepth
    (<span class="c006">if</span> !roots = [] <span class="c006">then</span> [ Filename.current_dir_name ]
     <span class="c006">else</span> List.rev !roots);
  <span class="c006">if</span> !errors <span class="c006">then</span> exit 1;;

Unix.handle_unix_error find ();;</div><p>
Although our <code>find</code> command is quite limited, the library
function <code>FindLib.find</code> is far more general, as the following
exercise shows.
</p><div class="exercise">
<!--TOC paragraph id=sec21 Exercise 1-->
<h5 class="paragraph" id="sec21">Exercise 1</h5><!--SEC END --><p><a id="ex1"></a>
Use the function <code>FindLib.find</code> to write a command
<code>find_but_CVS</code> equivalent to the Unix command:
</p><div class="mylisting">find . -<span class="c006">type</span> d -name CVS -prune -o -print</div><p>which, starting from the current directory, recursively prints
files without printing or entering directories whose name is <code>CVS</code>.
<a href="#exans1">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 1</arg>-->
<!--NAME exercise1.html-->
<div class="answer">
<!--TOC paragraph id=sec22 Answer of exercise 1-->
<h5 class="paragraph" id="sec22">Answer of <a href="#ex1">exercise 1</a></h5><!--SEC END --><p>
<a id="exans1"></a>

</p><div class="mylisting"><span class="c006">let</span> main () =
  <span class="c006">let</span> action p infos =
    <span class="c006">let</span> b = not (infos.st_kind = S_DIR || Filename.basename p = "CVS") <span class="c006">in
    if</span> b <span class="c006">then</span> print_endline p; b <span class="c006">in
  let</span> errors = <span class="c006">ref false in
  let</span> error (e,c,b) =
    errors:= <span class="c006">true</span>; prerr_endline (b ^ ": " ^ error_message e) <span class="c006">in</span>
  Findlib.find error action <span class="c006">false</span> max_int [ "." ];;
handle_unix_error main ()</div><div class="fancybreak">* * *</div></div><!--END FLOW-->
<div class="exercise">
<!--TOC paragraph id=sec23 Exercise 2-->
<h5 class="paragraph" id="sec23">Exercise 2</h5><!--SEC END --><p><a id="ex2"></a>
The function <code>getcwd</code> is not a system call but is defined in the
<code>Unix</code> module. Give a “primitive” implementation of
<code>getcwd</code>. First describe the principle of your algorithm with words
and then implement it (you should avoid repeating the same system
call).
<a href="#exans2">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 2</arg>-->
<!--NAME exercise2.html-->
<div class="answer">
<!--TOC paragraph id=sec24 Answer of exercise 2-->
<h5 class="paragraph" id="sec24">Answer of <a href="#ex2">exercise 2</a></h5><!--SEC END --><p>
<a id="exans2"></a>
Here are some hints. We move up from the current position towards the
root and construct backwards the path we are looking for. The root can
be detected as the only directory node whose parent is equal to itself
(relative to the root <code>.</code> and <code>..</code> are equal). To find the name
of a directory <code>r</code> we need to list the contents of its parent
directory and detect the file that corresponds to <code>r</code>.
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id=sec25 Opening a file-->
<h2 class="section" id="sec25">2.6  Opening a file</h2><!--SEC END --><p>The <code>openfile</code> function allows us to obtain a descriptor for
a file of a given name (the corresponding system call
is <a href="http://www.opengroup.org/onlinepubs/009696799/functions/open.html"><span class="c001">open</span></a><a id="hevea_default45"></a>, however <code><span class="c006">open</span></code> is a keyword in OCaml).

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALopenfile">openfile</a> :
 string -&gt; open_flag list -&gt; file_perm -&gt; file_descr</div><p>The first argument is the name of the file to open. The second
argument, a list of flags from the enumerated type
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEopen_flag"><span class="c001">open_flag</span></a>, describes the mode in which the file should
be opened and what to do if it does not exist. The third argument of
type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_perm"><span class="c001">file_perm</span></a> defines the file’s access rights,
should the file be created. The result is a file descriptor for the
given file name with the read/write position set to the beginning of the
file.</p><p>The flag list must contain exactly one of the following flags:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>O_RDONLY</code></td><td class="c010">Open in read-only mode. </td></tr>
<tr><td class="c010"><code>O_WRONLY</code></td><td class="c010">Open in write-only mode. </td></tr>
<tr><td class="c010"><code>O_RDWR</code></td><td class="c010">Open in read and write mode.
</td></tr>
</table>
</div><p>
These flags determine whether read or write calls can be done on the
descriptor. The call <code>openfile</code> fails if a process requests an open
in write (resp. read) mode on a file on which it has no right to
write (resp. read). For this reason <code>O_RDWR</code> should not be used
systematically.</p><p>The flag list can also contain one or more of the following values:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>O_APPEND</code></td><td class="c010">Open in append mode. </td></tr>
<tr><td class="c010"><code>O_CREAT</code></td><td class="c010">Create the file if it does not exist. </td></tr>
<tr><td class="c010"><code>O_TRUNC</code></td><td class="c010">Truncate the file to zero if it already exists. </td></tr>
<tr><td class="c010"><code>O_EXCL</code></td><td class="c010">Fail if the file already exists.
</td></tr>
</table>
</div><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>O_NONBLOCK</code></td><td class="c010">Open in non-blocking mode. </td></tr>
<tr><td class="c010"><code>O_NOCTTY</code></td><td class="c010">Do not function in console mode.
</td></tr>
</table>
</div><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>O_SYNC</code></td><td class="c010">Perform the writes in synchronous mode. </td></tr>
<tr><td class="c010"><code>O_DSYNC</code></td><td class="c010">Perform the data writes in synchronous mode. </td></tr>
<tr><td class="c010"><code>O_RSYN</code></td><td class="c010">Perform the reads in synchronous mode. 
</td></tr>
</table>
</div><p>
The first group defines the behavior to follow if
the file exists or not. With:
</p><ul class="itemize"><li class="li-itemize">
<code>O_APPEND</code>, the read/write position will be set at the end of
the file before each write. Consequently any written data will be
added at the end of file. Without <code>O_APPEND</code>, writes occur at the
current read/write position (initially, the beginning of the file).</li><li class="li-itemize"><code>O_TRUNC</code>, the file is truncated when it
is opened. The length of the file is set to zero and the bytes
contained in the file are lost, and writes start from an empty file. 
Without <code>O_TRUNC</code>, the writes are made at the start of the file
overwriting any data that may already be there.</li><li class="li-itemize"><code>O_CREAT</code>, creates the file if it does not exist. The created
file is empty and its access rights are specified by the third argument 
and the creation mask of the process (the mask can be retrieved 
and changed with <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALumask"><span class="c001">umask</span></a>).</li><li class="li-itemize"><code>O_EXCL</code>, <code>openfile</code> fails if the file already exists.
This flag, used in conjunction with <code>O_CREAT</code> allows to use
files as <a id="page/lock"></a><em>locks</em><sup><a id="text2" href="#note2">1</a></sup>. A process
which wants to take the lock calls <code>openfile</code> on the file with
<code>O_EXCL</code> and <code>O_CREAT</code>. If the file already exists, this means
that another process already holds the lock and <code>openfile</code> raises
an error. If the file does not exist <code>openfile</code> returns without
error and the file is created, preventing other processes from
taking the lock. To release the lock the process calls
<code>unlink</code> on it. The creation of a file is an atomic operation: if
two processes try to create the same file in parallel with the
options <code>O_EXCL</code> and <code>O_CREAT</code>, at most one of them can
succeed. The drawbacks of this technique is that a process must
busy wait to acquire a lock that is currently held and
the abnormal termination of a process holding a lock may never
release it.
</li></ul><div class="example">
<!--TOC paragraph id=sec26 Example-->
<h5 class="paragraph" id="sec26">Example</h5><!--SEC END --><p> 
Most programs use <code>0o666</code> for the third argument
to <code>openfile</code>. This means <code>rw-rw-rw-</code> in symbolic notation. 
With the default creation mask of <code>0o022</code>, the
file is thus created with the permissions <code>rw-r--r--</code>. With a more 
lenient mask of <code>0o002</code>, the file is created with the permissions 
<code>rw-rw-r--</code>.
  </p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec27 Example-->
<h5 class="paragraph" id="sec27">Example</h5><!--SEC END --><p> 
To read from a file:
</p><div class="mylisting">openfile filename [O_RDONLY] 0</div><p>The third argument can be anything as <code>O_CREAT</code> is not specified, 0
is usually given.</p><p>To write to an empty a file without caring about any previous content:
</p><div class="mylisting">openfile filename [O_WRONLY; O_TRUNC; O_CREAT] 0o666</div><p>If the file will contain executable code (e.g. files
created by <code>ld</code>, scripts, etc.), we create it with execution permissions:
</p><div class="mylisting">openfile filename [O_WRONLY; O_TRUNC; O_CREAT] 0o777</div><p>If the file must be confidential (e.g. “mailbox” files where
<code>mail</code> stores read messages), we create it with write permissions
only for the user owner:
</p><div class="mylisting">openfile filename [O_WRONLY; O_TRUNC; O_CREAT] 0o600</div><p>To append data at the end of an existing file or create it if it 
doesn’t exist:
</p><div class="mylisting">openfile filename [O_WRONLY; O_APPEND; O_CREAT] 0o666</div><div class="fancybreak">* * *</div></div><p>The <code>O_NONBLOCK</code> flag guarantees that if the file is a named pipe
or a special file then the file opening and subsequent reads and
writes will be non-blocking.</p><p>The <code>O_NOCTYY</code> flag guarantees that if the file is a control
terminal (keyboard, window, etc.), it won’t become the controlling
terminal of the calling process. </p><p>The last group of flags specifies how to synchronize 
read and write operations. By default these operations are not
synchronized. With:
</p><ul class="itemize"><li class="li-itemize">
<code>O_DSYNC</code>, the data is written synchronously such that
the process is blocked until all the writes have been done
physically on the media (usually a disk). 
</li><li class="li-itemize"><code>O_SYNC</code>, the file data and its meta-attributes are written 
synchronously.
</li><li class="li-itemize"><code>O_RSYNC</code>, with <code>O_DSYNC</code> specifies that the data reads are
also synchronized: it is guaranteed that all current writes
(requested but not necessarily performed) to the file are really
written to the media before the next read. If <code>O_RSYNC</code> is
provided with <code>O_SYNC</code> the above also applies to meta-attributes
changes.
</li></ul>
<!--TOC section id=sec28 Reading and writing-->
<h2 class="section" id="sec28">2.7  Reading and writing</h2><!--SEC END --><p>The system calls <a href="http://www.opengroup.org/onlinepubs/009696799/functions/read.html"><span class="c001">read</span></a><a id="hevea_default46"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/write.html"><span class="c001">write</span></a><a id="hevea_default47"></a> read and write
bytes in a file. For historical reasons, the system
call <code>write</code> is provided in OCaml under the name
<code>single_write</code>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALread">read</a>  : file_descr -&gt; string -&gt; int -&gt; int -&gt; int
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsingle_write">single_write</a> : file_descr -&gt; string -&gt; int -&gt; int -&gt; int</div><p>The two calls <code>read</code> and <code>single_write</code> have the same
interface. The first argument is the file descriptor to act on. The
second argument is a string which will hold the read bytes (for
<code>read</code>) or the bytes to write (for <code>single_write</code>). The third
argument is the position in the string of the first byte to be written
or read. The fourth argument is the number of the bytes to be read or
written. In fact the third and fourth argument define a sub-string of
the second argument (the sub-string should be valid, <code>read</code> and
<code>single_write</code> do not check this).
</p><div class="image"><img src="ocamlunix-image2.png" width="85%"></div><p>


<code>read</code> and <code>single_write</code> return the number of bytes actually
read or written.</p><p>Reads and write calls are performed from the file descriptor’s current
read/write position (if the file was opened in <code>O_APPEND</code> mode,
this position is set at the end of the file prior to any
write). After the system call, the current position is advanced by
the number of bytes read or written.</p><p>For writes, the number of bytes actually written is usually the number
of bytes requested. However there are exceptions: (i) if it is not
possible to write the bytes (e.g. if the disk is full) (ii) the
descriptor is a pipe or a socket open in non-blocking mode (iii) due to
OCaml, if the write is too large.</p><p>The reason for (iii) is that internally OCaml uses auxiliary
buffers whose size is bounded by a maximal value. If this value is
exceeded the write will be partial. To work around this problem
OCaml also provides the function <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALwrite"><span class="c001">write</span></a> which
iterates the writes until all the data is written or an error occurs.
The problem is that in case of error there’s no way to know the number
of bytes that were actually written. Hence <code>single_write</code> should be
preferred because it preserves the atomicity of writes (we know
exactly what was written) and it is more faithful to the original Unix
system call (note that the implementation of <code>single_write</code> is
described in section <a href="#sec118">5.7</a>).</p><div class="example">
<!--TOC paragraph id=sec29 Example-->
<h5 class="paragraph" id="sec29">Example</h5><!--SEC END --><p> 
Assume <code>fd</code> is a descriptor open in write-only mode. 
</p><div class="mylisting">write fd "Hello world!" 3 7</div><p>writes the characters <code>"lo worl"</code> in the corresponding file,
and returns 7.
</p><div class="fancybreak">* * *</div></div><p>For reads, it is possible that the number bytes actually read is
smaller than the number of requested bytes. For example when the end
of file is near, that is when the number of bytes between the current
position and the end of file is less than the number of requested
bytes. In particular, when the current position is at the end of file,
<code>read</code> returns zero. The convention “zero equals end of
file” also holds for special files, pipes and sockets. For example,
<code>read</code> on a terminal returns zero if we issue a <code>ctrl-D</code> on the
input.</p><p>Another example is when we read from a terminal. In that case,
<code>read</code> blocks until an entire line is available. If the line length
is smaller than the requested bytes <code>read</code> returns immediately with
the line without waiting for more data to reach the number of
requested bytes. (This is the default behavior for terminals, but it
can be changed to read character-by-character instead of
line-by-line, see section <a href="#sec47">2.13</a> and the type
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEterminal_io"><span class="c001">terminal_io</span></a> for more details.)</p><div class="example">
<!--TOC paragraph id=sec30 Example-->
<h5 class="paragraph" id="sec30">Example</h5><!--SEC END --><p> 
The following expression reads at most 100 characters from standard
input and returns them as a string.
</p><div class="mylisting"><span class="c006">let</span> buffer = String.create 100 <span class="c006">in
let</span> n = read stdin buffer 0 100 <span class="c006">in</span>
  String.sub buffer 0 n</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec31 Example-->
<h5 class="paragraph" id="sec31">Example</h5><!--SEC END --><p> 
The function <code>really_read</code> below has the same interface as
<code>read</code>, but makes additional read attempts to try to get
the number of requested bytes. It raises the exception
<code>End_of_file</code> if the end of file is reached while doing this.
</p><div class="mylisting"><span class="c006">let rec</span> really_read fd buffer start length =
  <span class="c006">if</span> length &lt;= 0 <span class="c006">then</span> () <span class="c006">else
  match</span> read fd buffer start length <span class="c006">with</span>
  | 0 -&gt; raise End_of_file
  | r -&gt; really_read fd buffer (start + r) (length - r);;</div><div class="fancybreak">* * *</div></div>
<!--TOC section id=sec32 Closing a descriptor-->
<h2 class="section" id="sec32">2.8  Closing a descriptor</h2><!--SEC END --><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/close.html"><span class="c001">close</span></a><a id="hevea_default48"></a> closes a file descriptor.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALclose">close</a> : file_descr -&gt; unit</div><p>Once a descriptor is closed, all attempts to read, write, or do
anything else with the descriptor will fail. Descriptors should be
closed when they are no longer needed; but it is not mandatory. In
particular, and in contrast to <code>Pervasives</code>’
channels, a file descriptor doesn’t need to be closed to ensure that
all pending writes have been performed as write requests made with
<code>write</code> are immediately transmitted to the kernel. On the other
hand, the number of descriptors allocated by a process is limited by
the kernel (from several hundreds to thousands). Doing a <code>close</code> on
an unused descriptor releases it, so that the process does not run out
of descriptors.</p>
<!--TOC section id=sec33 Complete example: file copy-->
<h2 class="section" id="sec33">2.9  Complete example: file copy</h2><!--SEC END --><p>We program a command <code>file_copy</code> which, given two arguments 
<code>f1</code> and <code>f2</code>, copies to the file <code>f2</code> the bytes contained 
in <code>f1</code>.
</p><div class="mylisting"><span class="c006">open</span> Unix;;

<span class="c006">let</span> buffer_size = 8192;;
<span class="c006">let</span> buffer = String.create buffer_size;;

<span class="c006">let</span> file_copy input_name output_name =
  <span class="c006">let</span> fd_in = openfile input_name [O_RDONLY] 0 <span class="c006">in
  let</span> fd_out = openfile output_name [O_WRONLY; O_CREAT; O_TRUNC] 0o666 <span class="c006">in
  let rec</span> copy_loop () = <span class="c006">match</span> read fd_in buffer 0 buffer_size <span class="c006">with</span>
    |  0 -&gt; ()
    | r -&gt; ignore (write fd_out buffer 0 r); copy_loop ()
  <span class="c006">in</span>
  copy_loop ();
  close fd_in;
  close fd_out;;</div><div class="mylisting"><span class="c006">let</span> copy () =
  <span class="c006">if</span> Array.length Sys.argv = 3 <span class="c006">then begin</span>
    file_copy Sys.argv.(1) Sys.argv.(2);
    exit 0
  <span class="c006">end else begin</span>
    prerr_endline
      ("Usage: " ^ Sys.argv.(0) ^ " &lt;input_file&gt; &lt;output_file&gt;");
    exit 1
  <span class="c006">end</span>;;

handle_unix_error copy ();;</div><p>The bulk of the work is performed by the the function <code>file_copy</code>.
First we open a descriptor in read-only mode on the input file and
another in write-only mode on the output file. </p><p>If the output file already exists, it is truncated (option
<code>O_TRUNC</code>) and if it does not exist it is created (option
<code>O_CREAT</code>) with the permissions <code>rw-rw-rw-</code> modified by the creation
mask. (This is unsatisfactory: if we copy an executable file, we would
like the copy to be also executable. We will see later how to give
a copy the same permissions as the original.)</p><p>In the <code>copy_loop</code> function we do the copy by blocks of
<code>buffer_size</code> bytes. We request <code>buffer_size</code> bytes to read. If
<code>read</code> returns zero, we have reached the end of file and the copy
is over. Otherwise we write the <code>r</code> bytes we have read in the
output file and start again.</p><p>Finally, we close the two descriptors. The main program <code>copy</code>
verifies that the command received two arguments and passes them to
the function <code>file_copy</code>.</p><p>Any error occurring during the copy results in a <code>Unix_error</code>
caught and displayed by <code>handle_unix_error</code>. Example of errors
include inability to open the input file because it does not
exist, failure to read because of restricted permissions, failure to
write because the disk is full, etc.</p><div class="exercise">
<!--TOC paragraph id=sec34 Exercise 3-->
<h5 class="paragraph" id="sec34">Exercise 3</h5><!--SEC END --><p><a id="ex3"></a> 
Add an option <code>-a</code> to the program, such that 
<code>file_copy -a f1 f2</code> appends the contents of <code>f1</code> to the end of
the file <code>f2</code>. 
<a href="#exans3">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 3</arg>-->
<!--NAME exercise3.html-->
<div class="answer">
<!--TOC paragraph id=sec35 Answer of exercise 3-->
<h5 class="paragraph" id="sec35">Answer of <a href="#ex3">exercise 3</a></h5><!--SEC END --><p>
<a id="exans3"></a>
If the option <code>-a</code> is supplied, we need to do 
</p><div class="mylisting">openfile output_name [O_WRONLY; O_CREAT; O_APPEND] 0o666</div><p>instead of
</p><div class="mylisting">openfile output_name [O_WRONLY; O_CREAT; O_TRUNC] 0o666</div><p>Parsing the new option from the command line is left to the reader. 
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id=sec36 The cost of system calls and buffers-->
<h2 class="section" id="sec36">2.10  The cost of system calls and buffers</h2><!--SEC END --><p>In the example <code>file_copy</code>, reads were made in blocks of 8192
bytes. Why not read byte per by byte, or megabyte per by megabyte?
The reason is efficiency.</p><p>Figure <a href="#fig%2Fcopy-speed">2</a> shows the copy speed of <code>file_copy</code>, in
bytes per second, against the size of blocks (the value
<code>buffer_size</code>). The amount of data transferred is the same
regardless of the size of the blocks.
</p><div class="figure">
<div class="image"><img src="ocamlunix-image3.png" width="100%"></div>



<a id="fig/copy-speed"></a>
<div class="caption">Figure 2 — Copy speed as a function of block size</div></div><p>
For small block sizes, the copy speed is almost proportional to the
block size. Most of the time is spent not in data transfers but in the
execution of the loop <code>copy_loop</code> and in the calls to <code>read</code> and
<code>write</code>. By profiling more carefully we can see that most of the
time is spent in the calls to <code>read</code> and <code>write</code>. We conclude
that a system call, even if it has not much to do, takes a minimum of
about 4 micro-seconds (on the machine that was used for the test — a
2.8 GHz Pentium 4 ), let us say from 1 to 10 microseconds. For small
input/output blocks, the duration of the system call dominates.</p><p>For larger blocks, between 4KB and 1MB, the copy speed is constant and
maximal. Here, the time spent in system calls and the loop is small
relative to the time spent on the data transfer. Also, the buffer
size becomes bigger than the cache sizes used by the system and the
time spent by the system to make the transfer dominates the cost of a
system call<sup><a id="text3" href="#note3">2</a></sup>.</p><p>Finally, for very large blocks (8MB and more) the speed is slightly
under the maximum. Coming into play here is the time needed to
allocate the block and assign memory pages to it as it fills up.</p><p>The moral of the story is that, a system call, even if it does very little work,
costs dearly — much more than a normal function call: roughly, 2 to
20 microseconds for each system call, depending on the
architecture. It is therefore important to minimize the number of
system calls. In particular, read and write operations should be made
in blocks of reasonable size and not character by character.</p><p>In examples like <code>file_copy</code>, it is not difficult to do
input/output with large blocks. But other types of programs are more
naturally written with character by character input or output (e.g.
reading a line from a file, lexical analysis, displaying a number etc.).
To satisfy the needs of these programs, most systems provide
input/output libraries with an additional layer of software between
the application and the operating system. For example, in OCaml the
<code>Pervasives</code> module defines the abstract types
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEin_channel"><span class="c001">in_channel</span></a> and
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEout_channel"><span class="c001">out_channel</span></a>, similar to file descriptors, and
functions on these types like <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinput_char"><span class="c001">input_char</span></a>,
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinput_line"><span class="c001">input_line</span></a>,
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALoutput_char"><span class="c001">output_char</span></a>, or
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALoutput_string"><span class="c001">output_string</span></a>. This layer uses buffers to
group sequences of character by character reads or writes into a
single system call to read or write. This results in better
performance for programs that proceed character by character.
Moreover this additional layer makes programs more portable: we just
need to implement this layer with the system calls provided by another
operating system to port all the programs that use this library on
this new platform.</p>
<!--TOC section id=sec37 Complete example: a small input/output library-->
<h2 class="section" id="sec37">2.11  Complete example: a small input/output library</h2><!--SEC END --><p>To illustrate the buffered input/output techniques, we implement a fragment
of OCaml <code>Pervasives</code> library. Here is the interface:
</p><div class="mylisting"><span class="c006">exception</span> End_of_file

<span class="c006">type</span> in_channel
<span class="c006">val</span> open_in : string -&gt; in_channel
<span class="c006">val</span> input_char : in_channel -&gt; char
<span class="c006">val</span> close_in : in_channel -&gt; unit

<span class="c006">type</span> out_channel
<span class="c006">val</span> open_out : string -&gt; out_channel
<span class="c006">val</span> output_char : out_channel -&gt; char -&gt; unit
<span class="c006">val</span> close_out : out_channel -&gt; unit</div><p>We start with the “input” part. The abstract type 
<code>in_channel</code> is defined as follows: 
</p><div class="mylisting"><span class="c006">open</span> Unix;;

<span class="c006">type</span> in_channel =
  { in_buffer: string;
    in_fd: file_descr;
    <span class="c006">mutable</span> in_pos: int;
    <span class="c006">mutable</span> in_end: int };;
<span class="c006">exception</span> End_of_file</div><p>The character string of the <code>in_buffer</code> field is, literally, the
buffer. The field <code>in_fd</code> is a (Unix) file descriptor, opened on
the file to read. The field <code>in_pos</code> is the current read position
in the buffer. The field <code>in_end</code> is the number of valid
characters preloaded in the buffer.
</p><div class="image"><img src="ocamlunix-image4.png" width="85%"></div><p>


The fields <code>in_pos</code> and <code>in_end</code> will be modified in place during 
read operations; we therefore declare them as <code><span class="c006">mutable</span></code>.
</p><div class="mylisting"><span class="c006">let</span> buffer_size = 8192;;
<span class="c006">let</span> open_in filename =
  { in_buffer = String.create buffer_size;
    in_fd = openfile filename [O_RDONLY] 0;
    in_pos = 0;
    in_end = 0 };;</div><p>When we open a file for reading, we create a buffer of reasonable size
(large enough so as not to make too many system calls; small enough so
as not to waste memory). We then initialize the field <code>in_fd</code> with
a Unix file descriptor opened in read-only mode on the given file. The
buffer is initially empty (it does not contain any character from the
file); the field <code>in_end</code> is therefore initialized to zero.
</p><div class="mylisting"><span class="c006">let</span> input_char chan =
  <span class="c006">if</span> chan.in_pos &lt; chan.in_end <span class="c006">then begin
    let</span> c =  chan.in_buffer.[chan.in_pos] <span class="c006">in</span>
      chan.in_pos &lt;- chan.in_pos + 1;
      c
  <span class="c006">end else begin
    match</span> read chan.in_fd chan.in_buffer 0 buffer_size
    <span class="c006">with</span> 0 -&gt; raise End_of_file
       | r -&gt; chan.in_end &lt;- r;
              chan.in_pos &lt;- 1;
              chan.in_buffer.[0]
  <span class="c006">end</span>;;</div><p>To read a character from an <code>in_channel</code>, we do one of two
things. Either there is at least one unread character in the buffer;
that is to say, the field <code>in_pos</code> is less than the field
<code>in_end</code>. We then return this character located at <code>in_pos</code>, and
increment <code>in_pos</code>. Or the buffer is empty and we call <code>read</code> to
refill the buffer. If <code>read</code> returns zero, we have reached the end
of the file and we raise the exception <code>End_of_file</code>. Otherwise, we
put the number of characters read in the field <code>in_end</code> (we may
receive less characters than we requested, thus the buffer may be
only partially refilled) and we return the first character read.
</p><div class="mylisting"><span class="c006">let</span> close_in chan =
  close chan.in_fd;;</div><p>Closing an <code>in_channel</code> just closes the underlying Unix file descriptor. </p><p>The “output” part is very similar to the “input”
part. The only asymmetry is that the buffer now contains incomplete
writes (characters that have already been buffered but not written to
the file descriptor), and not reads in advance (characters that have
buffered, but not yet read).</p><div class="image"><img src="ocamlunix-image5.png" width="85%"></div><div class="mylisting"><span class="c006">type</span> out_channel =
  { out_buffer: string;
    out_fd: file_descr;
    <span class="c006">mutable</span> out_pos: int };;

<span class="c006">let</span> open_out filename =
  { out_buffer = String.create 8192;
    out_fd = openfile filename [O_WRONLY; O_TRUNC; O_CREAT] 0o666;
    out_pos = 0 };;

<span class="c006">let</span> output_char chan c =
  <span class="c006">if</span> chan.out_pos &lt; String.length chan.out_buffer <span class="c006">then begin</span>
    chan.out_buffer.[chan.out_pos] &lt;- c;
    chan.out_pos &lt;- chan.out_pos + 1
  <span class="c006">end else begin</span>
    ignore (write chan.out_fd chan.out_buffer 0 chan.out_pos);
    chan.out_buffer.[0] &lt;- c;
    chan.out_pos &lt;- 1
  <span class="c006">end</span>;;

<span class="c006">let</span> close_out chan =
  ignore (write chan.out_fd chan.out_buffer 0 chan.out_pos);
  close chan.out_fd;;</div><p>To write a character on an <code>out_channel</code>, we do one of two things.
Either the buffer is not full and we just store the character in the
buffer at the position <code>out_pos</code> and increment that value. Or the
buffer is full and we empty it with a call to <code>write</code> and then
store the character at the beginning of the buffer.</p><p>When we close an <code>out_channel</code>, we must not forget to write the
buffer contents (the characters from 0 to <code>out_pos - 1</code>) to the
file otherwise the writes made on the channel since the last time
the buffer was emptied would be lost.</p><div class="exercise">
<!--TOC paragraph id=sec38 Exercise 4-->
<h5 class="paragraph" id="sec38">Exercise 4</h5><!--SEC END --><p><a id="ex4"></a> 
Implement the function:
</p><div class="mylisting"><span class="c006">val</span> output_string : out_channel -&gt; string -&gt; unit</div><p>which behaves like a sequence of <code>output_char</code> on each 
character of the string, but is more efficient.
 <a href="#exans4">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 4</arg>-->
<!--NAME exercise4.html-->
<div class="answer">
<!--TOC paragraph id=sec39 Answer of exercise 4-->
<h5 class="paragraph" id="sec39">Answer of <a href="#ex4">exercise 4</a></h5><!--SEC END --><p>
<a id="exans4"></a>
The idea is to copy the string to output into the buffer. We need to
take into account the case where there is not enough space in the
buffer (in that case the buffer needs to emptied), and also the case
where the string is longer than the buffer (in that case it can 
be written directly). Here is a possible solution.

</p><div class="mylisting"><span class="c006">let</span> output_string chan s =
  <span class="c006">let</span> avail = String.length chan.out_buffer - chan.out_pos <span class="c006">in
  if</span> String.length s &lt;= avail <span class="c006">then begin</span>
    String.blit s 0 chan.out_buffer chan.out_pos (String.length s);
    chan.out_pos &lt;- chan.out_pos + String.length s
  <span class="c006">end
  else if</span> chan.out_pos = 0 <span class="c006">then begin</span>
    ignore (write chan.out_fd s 0 (String.length s))
  <span class="c006">end
  else begin</span>
    String.blit s 0 chan.out_buffer chan.out_pos avail;
    <span class="c006">let</span> out_buffer_size = String.length chan.out_buffer <span class="c006">in</span>
    ignore (write chan.out_fd chan.out_buffer 0 out_buffer_size);
    <span class="c006">let</span> remaining = String.length s - avail <span class="c006">in
    if</span> remaining &lt; out_buffer_size <span class="c006">then begin</span>
      String.blit s avail chan.out_buffer 0 remaining;
      chan.out_pos &lt;- remaining
    <span class="c006">end else begin</span>
      ignore (write chan.out_fd s avail remaining);
      chan.out_pos &lt;- 0
    <span class="c006">end
  end</span>;;</div><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id=sec40 Positioning-->
<h2 class="section" id="sec40">2.12  Positioning</h2><!--SEC END --><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/lseek.html"><span class="c001">lseek</span></a><a id="hevea_default49"></a> allows to set the current read/write
position of a file descriptor.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlseek">lseek</a> : file_descr -&gt; int -&gt; seek_command -&gt; int</div><p>The first argument is the file descriptor and the second one the
desired position. The latter is interpreted according to the value
of the third argument of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEseek_command"><span class="c001">seek_command</span></a>. This
enumerated type specifies the kind of position:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c013"><code>SEEK_SET</code></td><td class="c012">Absolute position. The second argument specifies
the character number to point to. The first character of a file is at
position zero.</td></tr>
<tr><td class="c013"><code>SEEK_CUR</code></td><td class="c012">Position relative to the current position. 
The second argument is an offset relative to the 
current position. A positive value moves forward and a negative value
moves backwards.</td></tr>
<tr><td class="c013"><code>SEEK_END</code></td><td class="c012">Position relative to the end of file. The 
second argument is an offset relative to the end of file.
As for <code>SEEK_CUR</code>, the offset may be positive or negative.
</td></tr>
</table>
</div><p>
The value returned by <code>lseek</code> is the resulting absolute
read/write position.</p><p>An error is raised if a negative absolute position is
requested. The requested position can be located after the end
of file. In that case, a <code>read</code> returns zero (end of
file reached) and a <code>write</code> extends the file with zeros until 
that position and then writes the supplied data.</p><div class="example">
<!--TOC paragraph id=sec41 Example-->
<h5 class="paragraph" id="sec41">Example</h5><!--SEC END --><p> 
To position the cursor on the 1000th character of a file:
</p><div class="mylisting">lseek fd 1000 SEEK_SET</div><p>To rewind by one character:
</p><div class="mylisting">lseek fd (-1) SEEK_CUR</div><p>To find out the size of a file:
</p><div class="mylisting"><span class="c006">let</span> file_size = lseek fd 0 SEEK_END <span class="c006">in</span> ...</div><div class="fancybreak">* * *</div></div><p>For descriptors opened in <code>O_APPEND</code> mode, the read/write position
is automatically set at the end of the file before each write. Thus
a call <code>lseek</code> is useless to set the write position, it may however
be useful to set the read position. </p><p>The behavior of <code>lseek</code> is undefined on certain type of files for
which absolute access is meaningless: communication devices (pipes,
sockets) but also many special files like the terminal.
In most Unix implementations a call to <code>lseek</code> on these files is
simply ignored: the read/write position is set but read/write
operations ignore it. In some implementations, <code>lseek</code> on a pipe or
a socket triggers an error.</p><div class="exercise">
<!--TOC paragraph id=sec42 Exercise 5-->
<h5 class="paragraph" id="sec42">Exercise 5</h5><!--SEC END --><p><a id="ex5"></a>
The command <code>tail</code> displays the last <span class="c004">n</span> lines of a file.
How can it be implemented efficiently on regular files? What can we 
do for the other kind of files? How can the option <code>-f</code> be
implemented (cf. <code>man tail</code>)?
 <a href="#exans5">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 5</arg>-->
<!--NAME exercise5.html-->
<div class="answer">
<!--TOC paragraph id=sec43 Answer of exercise 5-->
<h5 class="paragraph" id="sec43">Answer of <a href="#ex5">exercise 5</a></h5><!--SEC END --><p>
<a id="exans5"></a>
A naive implementation of <code>tail</code> is to read the file sequentially
from the beginning, keeping the last <span class="c004">n</span> lines read in a circular
buffer. When we reach the end of file, we display the buffer.
When the data comes from a pipe or a special file which
does not implement <code>lseek</code>, there is no better way.</p><p>However if the data is coming from a normal file, it is better to read
the file from the end. With <code>lseek</code>, we read the last 4096
characters. We scan them for the end of lines. If there are at least
<span class="c004">n</span> of them, we output and display the corresponding lines.
Otherwise, we start again by adding the next preceding 4096
characters, etc.</p><p>To add the option <code>-f</code>, we first proceed as above and then we go
back at the end of the file and try to <code>read</code> from there. If
<code>read</code> returns data we display it immediately and start again. If it
returns <code>0</code> we wait some time (<code>sleep 1</code>) and try again.
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id=sec44 Operations specific to certain file types-->
<h2 class="section" id="sec44">2.13  Operations specific to certain file types</h2><!--SEC END --><p>In Unix, data communication is done via file descriptors representing
either permanent files (files, peripherals) or volatile ones (pipes
and sockets, see chapters <a href="#sec99">5</a> and <a href="#sec119">6</a>). File
descriptors provide a uniform and media-independent interface for data
communication. Of course the actual implementation of the operations
on a file descriptor depends on the underlying media.</p><p>However this uniformity breaks when we need to access all the
features provided by a given media. General operations (opening,
writing, reading, etc.) remain uniform on most descriptors but even,
on certain special files, these may have an ad hoc behavior defined
by the kind of peripheral and its parameters. There are also
operations that work only with certain kind of media.</p><!--TOC subsection id=sec45 Normal files-->
<h3 class="subsection" id="sec45">Normal files</h3><!--SEC END --><p>We can shorten a normal file with the system calls
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/truncate.html"><span class="c001">truncate</span></a><a id="hevea_default50"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/ftruncate.html"><span class="c001">ftruncate</span></a><a id="hevea_default51"></a>.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtruncate">truncate</a>  : string -&gt; int -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALftruncate">ftruncate</a> : file_descr -&gt; int -&gt; unit</div><p>The first argument is the file to truncate and the second the desired
size. All the data after this position is lost.</p><!--TOC subsection id=sec46 Symbolic links-->
<h3 class="subsection" id="sec46">Symbolic links</h3><!--SEC END --><p>Most operations on files “follow” symbolic links in the sense
that they do not apply to the link itself but to the file on which the
link points (for example <span class="c001">openfile</span><a id="hevea_default52"></a>,
<span class="c001">stat</span><a id="hevea_default53"></a>, <span class="c001">truncate</span><a id="hevea_default54"></a>, <span class="c001">opendir</span><a id="hevea_default55"></a>, etc.). </p><p>The two system calls <a href="http://www.opengroup.org/onlinepubs/009696799/functions/symlink.html"><span class="c001">symlink</span></a><a id="hevea_default56"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/readlink.html"><span class="c001">readlink</span></a><a id="hevea_default57"></a> operate
specifically on symbolic links:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsymlink">symlink</a>  : string -&gt; string -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALreadlink">readlink</a> : string -&gt; string</div><p>The call <code>symlink f1 f2</code> creates the file <code>f2</code> as a symbolic
link to <code>f1</code> (like the Unix command <code>ln -s f1 f2</code>). The call
<code>readlink</code> returns the content of a symbolic link, i.e. the name of
the file to which the link points.</p><!--TOC subsection id=sec47 Special files-->
<h3 class="subsection" id="sec47">Special files</h3><!--SEC END --><p>Special files can be of “character” or “block” type.
The former are character streams: we can read or write characters only
sequentially. These are the terminals, sound devices, printers, etc.
The latter, typically disks, have a permanent medium: characters can
be read by blocks and even seeked relative to the current position.</p><p>Among the special files, we may distinguish:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c013"><code>/dev/null</code></td><td class="c012">This is the black hole which swallows
everything we put into and from which nothing comes out. This is
extremely useful for ignoring the results of a process: we redirect
its output to <code>/dev/null</code> (see chapter <a href="#sec99">5</a>).</td></tr>
<tr><td class="c013"><code>/dev/tty*</code></td><td class="c012">These are the control terminals. </td></tr>
<tr><td class="c013"><code>/dev/pty*</code></td><td class="c012">These are the pseudo-terminals: they are not real
terminals but simulate them (they provide the same interface). </td></tr>
<tr><td class="c013"><code>/dev/hd*</code></td><td class="c012">These are the disks. </td></tr>
<tr><td class="c013"><code>/proc</code></td><td class="c012">Under Linux, system parameters organized as a
file system. They allow reads and writes.
</td></tr>
</table>
</div><p>The usual file system calls on special files can behave differently.
However, most special files (terminals, tape drives, disks, etc.)
respond to <code>read</code> and <code>write</code> in the obvious manner (but
sometimes with restrictions on the number of bytes written or read),
but many ignore <span class="c001">lseek</span><a id="hevea_default58"></a>.</p><p>In addition to the usual file system calls, special files which
represent peripherals must be commanded and/or configured
dynamically. For example, for a tape drive, rewind or fast forward the
tape; for a terminal, choice of the line editing mode, behavior of
special characters, serial connection parameters (speed, parity,
etc.). These operations are made in Unix with the system call
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/ioctl.html"><span class="c001">ioctl</span></a><a id="hevea_default59"></a> which group together all the particular
cases. However, this system call is not provided by OCaml; it is
ill-defined and cannot be treated in a uniform way.</p><!--TOC subsection id=sec48 Terminals-->
<h3 class="subsection" id="sec48">Terminals</h3><!--SEC END --><p>Terminals and pseudo-terminals are special files of type character
which can be configured from OCaml. The system call
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcgetattr.html"><span class="c001">tcgetattr</span></a><a id="hevea_default60"></a> takes a file descriptor open on a special file
and returns a structure of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEterminal_io"><span class="c001">terminal_io</span></a> which
describes the status of the terminal according to the <span class="c005">posix</span> 
standard.

</p><div class="mylisting"><span class="c006">type</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEterminal_io">terminal_io</a> =
  { c_ignbrk : bool; c_brk_int : bool; ...;  c_vstop : char }</div><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcgetattr">tcgetattr</a> : file_descr -&gt; terminal_io</div><p>This structure can be modified and given to the function 
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcsetattr.html"><span class="c001">tcsetattr</span></a><a id="hevea_default61"></a> to change the attributes of the peripheral.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcsetattr">tcsetattr</a> : file_descr -&gt; setattr_when -&gt; terminal_io -&gt; unit</div><p>The first argument is the file descriptor of the peripheral. The last
argument is a structure of type <code>terminal_io</code> describing the
parameters of the peripheral as we want them. The second argument is a
value of the enumerated type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsetattr_when"><span class="c001">setattr_when</span></a> that
indicates when the change must be done: immediately (<code>TCSANOW</code>),
after having transmitted all written data (<code>TCSADRAIN</code>) or after
having read all the received data (<code>TCAFLUSH</code>). <code>TCSADRAIN</code> is
recommended for changing write parameters and <code>TCSAFLUSH</code> for read
parameters.</p><div class="example">
<!--TOC paragraph id=sec49 Example-->
<h5 class="paragraph" id="sec49">Example</h5><!--SEC END --><p>
When a password is read, characters entered by the user should not be
echoed if the standard input is connected to a terminal or a
pseudo-terminal.

</p><div class="mylisting"><span class="c006">let</span> read_passwd message =
  <span class="c006">match
    try
      let</span> default = tcgetattr stdin <span class="c006">in
      let</span> silent =
        { default <span class="c006">with</span>
          c_echo = <span class="c006">false</span>;
          c_echoe = <span class="c006">false</span>;
          c_echok = <span class="c006">false</span>;
          c_echonl = <span class="c006">false</span>;
        } <span class="c006">in</span>
      Some (default, silent)
    <span class="c006">with</span> _ -&gt; None
  <span class="c006">with</span>
  | None -&gt; input_line Pervasives.stdin
  | Some (default, silent) -&gt;
      print_string message;
      flush Pervasives.stdout;
      tcsetattr stdin TCSANOW silent;
      <span class="c006">try
        let</span> s = input_line Pervasives.stdin <span class="c006">in</span>
        tcsetattr stdin TCSANOW default; s
      <span class="c006">with</span> x -&gt;
        tcsetattr stdin TCSANOW default; raise x;;</div><p>The <code>read_passwd</code> function starts by getting the current settings
of the terminal connected to <code>stdin</code>. Then it defines a modified
version of these in which characters are not echoed. If this fails the
standard input is not a control terminal and we just read a
line. Otherwise we display a message, change the terminal settings, read the
password and put the terminal back in its initial state. Care must be
taken to set the terminal back to its initial state even after a read
failure.
</p><div class="fancybreak">* * *</div></div><p>
Sometimes a program needs to start another and connect its standard input
to a terminal (or pseudo-terminal). OCaml does not provide any
support for this<sup><a id="text4" href="#note4">3</a></sup>. To achieve that, we must manually look among the
pseudo-terminals (in general, they are files with names in the form of
<code>/dev/tty[a-z][a-f0-9]</code>) and find one that is not already open. We
can then open this file and start the program with this file on its
standard input.</p><p>Four other functions control the stream of data of a terminal
(flush waiting data, wait for the end of transmission and restart
communication).
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcsendbreak">tcsendbreak</a> : file_descr -&gt; int -&gt; unit</div><p>The function <a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcsendbreak.html"><span class="c001">tcsendbreak</span></a><a id="hevea_default62"></a> sends an interrupt to the 
peripheral. The second argument is the duration of the interrupt
(<code>0</code> is interpreted as the default value for the 
peripheral).
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcdrain">tcdrain</a> : file_descr -&gt; unit</div><p>The function <a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcdrain.html"><span class="c001">tcdrain</span></a><a id="hevea_default63"></a> waits for all written data to
be transmitted.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcflush">tcflush</a> : file_descr -&gt; flush_queue -&gt; unit</div><p>Depending on the value of the second argument, a call to the
function <a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcflush.html"><span class="c001">tcflush</span></a><a id="hevea_default64"></a> discards the data written but not yet
transmitted (<code>TCIFLUSH</code>), or the data received but not yet read
(<code>TCOFLUSH</code>) or both (<code>TCIOFLUSH</code>).

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtcflow">tcflow</a> : file_descr -&gt; flow_action -&gt; unit</div><p>Depending on the value of the second argument, a call to the
function <a href="http://www.opengroup.org/onlinepubs/009696799/functions/tcflow.html"><span class="c001">tcflow</span></a><a id="hevea_default65"></a> suspends the data transmission
(<code>TCOOFF</code>), restarts the transmission (<code>TCOON</code>), sends a control
character <span class="c005">stop</span> or <span class="c005">start</span> to request the
transmission to be suspended (<code>TCIOFF</code>) or restarted (<code>TCION</code>).
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetsid">setsid</a> : unit -&gt; int</div><p>The function <a href="http://www.opengroup.org/onlinepubs/009696799/functions/setsid.html"><span class="c001">setsid</span></a><a id="hevea_default66"></a> puts the process in a new
session and detaches it from the terminal.</p>
<!--TOC section id=sec50 Locks on files-->
<h2 class="section" id="sec50">2.14  Locks on files</h2><!--SEC END --><p>Two processes can modify the same file in parallel; however, their
writes may collide and result in inconsistent data. In some cases data
is always written at the end and opening the file with <code>O_APPEND</code>
prevents this. This is fine for <code>log</code> files but it does not
work for files that store, for example, a database because writes are
performed at arbitrary positions. In that case processes using the
file must collaborate in order not to step on each others toes. A
lock on the whole file can be implemented with an auxiliary file (see
page <a href="#page%2Flock">??</a>) but the system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/lockf.html"><span class="c001">lockf</span></a><a id="hevea_default67"></a> allows
for finer synchronization patterns by locking only parts of a file.

</p><div class="mylisting"> <span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlockf">lockf</a> : file_descr -&gt; lock_command -&gt; int -&gt; unit</div>
<!--TOC section id=sec51 Complete example: recursive copy of files-->
<h2 class="section" id="sec51">2.15  Complete example: recursive copy of files</h2><!--SEC END --><p>We extend the function <code>file_copy</code> (section <a href="#sec33">2.9</a>) to
support symbolic links and directories in addition to normal files.
For directories, we recursively copy their contents.</p><p>To copy normal files we reuse the function <code>file_copy</code> we already
defined.
</p><div class="mylisting"><span class="c006">open</span> Unix
...
<span class="c006">let</span> file_copy input_name output_name =
...</div><p>The function <code>set_infos</code> below modifies the owner, the 
access rights and the last dates of access/modification
of a file. We use it to preserve this information for copied files.

</p><div class="mylisting"><span class="c006">let</span> set_infos filename infos =
  utimes filename infos.st_atime infos.st_mtime;
  chmod filename infos.st_perm;
  <span class="c006">try</span>
    chown filename infos.st_uid infos.st_gid
  <span class="c006">with</span> Unix_error(EPERM,_,_) -&gt; ()</div><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/utime.html"><span class="c001">utime</span></a><a id="hevea_default68"></a> modifies the dates of access and 
modification. We use <code>chmod</code> and <code>chown</code> to re-establish 
the access rights and the owner. For normal users, there are 
a certain number of cases where <code>chown</code> will fail with a
“permission denied” error. We catch this error and ignore it.</p><p>Here’s the main recursive function. 
</p><div class="mylisting"><span class="c006">let rec</span> copy_rec source dest =
  <span class="c006">let</span> infos = lstat source <span class="c006">in
  match</span> infos.st_kind <span class="c006">with</span>
  | S_REG -&gt;
      file_copy source dest;
      set_infos dest infos
  | S_LNK -&gt;
      <span class="c006">let</span> link = readlink source <span class="c006">in</span>
      symlink link dest
  | S_DIR -&gt;
      mkdir dest 0o200;
      Misc.iter_dir
        (<span class="c006">fun</span> file -&gt;
          <span class="c006">if</span> file &lt;&gt; Filename.current_dir_name
              &amp;&amp; file &lt;&gt; Filename.parent_dir_name
          <span class="c006">then</span>
            copy_rec
              (Filename.concat source file)
              (Filename.concat dest file))
        source;
      set_infos dest infos
  | _ -&gt;
      prerr_endline ("Can't cope with special file " ^ source)</div><p>We begin by reading the information of the <code>source</code> file. If it is
a normal file, we copy its contents with <code>file_copy</code> and its
information with <code>set_infos</code>. If it is a symbolic link, we read
where it points to and create a link pointing to the same object. If
it is a directory, we create a destination directory, then we read the
directory’s entries (ignoring the entries about the directory itself
or its parent) and recursively call <code>copy_rec</code> for each entry. All
other file types are ignored, with a warning.</p><p>The main program is straightforward:

</p><div class="mylisting"><span class="c006">let</span> copyrec () =
  <span class="c006">if</span> Array.length Sys.argv &lt;&gt; 3 <span class="c006">then begin</span>
    prerr_endline ("Usage: " ^Sys.argv.(0)^ " &lt;source&gt; &lt;destination&gt;");
    exit 2
  <span class="c006">end else begin</span>
    copy_rec Sys.argv.(1) Sys.argv.(2);
    exit 0
  <span class="c006">end</span>
;;
handle_unix_error copyrec ();;</div><div class="exercise">
<!--TOC paragraph id=sec52 Exercise 6-->
<h5 class="paragraph" id="sec52">Exercise 6</h5><!--SEC END --><p><a id="ex6"></a> 
<a id="ex/copyrec"></a>
Copy hard links cleverly. As written above <code>copy_rec</code> creates <span class="c004">n</span>
duplicates of the same file whenever a file occurs under <span class="c004">n</span> different
names in the hierarchy to copy. Try to detect this situation, copy
the file only once and make hard links in the destination hierarchy.
<a href="#exans6">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 6</arg>-->
<!--NAME exercise6.html-->
<div class="answer">
<!--TOC paragraph id=sec53 Answer of exercise 6-->
<h5 class="paragraph" id="sec53">Answer of <a href="#ex6">exercise 6</a></h5><!--SEC END --><p>
<a id="exans6"></a>
For the files that have already been copied we keep a map from their
identity <code>(st_dev, st_ino)</code> to their destination file name. Before
each copy we consult the map to see if a file with the same identity
was already copied. If that’s the case we do a hard link on the
destination file name instead of redoing the copy. To minimize the
size of the map we remember only the files which have more than one
name, i.e. those for which <code>st_nlink &gt; 1</code>.

</p><div class="mylisting"><span class="c006">let</span> copied_files = (Hashtbl.create 53 : ((int * int), string) Hashtbl.t)

<span class="c006">let rec</span> copy source dest =
  <span class="c006">let</span> infos = lstat source <span class="c006">in
  match</span> infos.st_kind <span class="c006">with</span>
    S_REG -&gt;
      <span class="c006">if</span> infos.st_nlink &gt; 1 <span class="c006">then begin
        try
          let</span> dest' =
            Hashtbl.find copied_files (infos.st_dev, infos.st_ino)
          <span class="c006">in</span> link dest' dest
        <span class="c006">with</span> Not_found -&gt;
          Hashtbl.add copied_files (infos.st_dev, infos.st_ino) dest;
          file_copy source dest;
          set_infos dest infos
      <span class="c006">end else begin</span>
        file_copy source dest;
        set_infos dest infos
      <span class="c006">end</span></div><div class="mylisting">  | S_LNK -&gt; ...</div><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id=sec54 Complete example: <span class="c001">T</span>ape <span class="c001">AR</span>chive-->
<h2 class="section" id="sec54">2.16  Complete example: <span class="c001">T</span>ape <span class="c001">AR</span>chive</h2><!--SEC END --><p>The <code>tar</code> file format (for <code>t</code>ape <code>ar</code>chive) can store a file
hierarchy into a single file. It can be seen as a mini file system.</p><p>In this section we define functions to read and write <code>tar</code>
files. We also program a command <code>readtar</code> such that <code>readtar a</code>
displays the name of the files contained in the archive <code>a</code> and
<code>readtar a f</code> extracts the contents of the file <code>f</code> contained in
<code>a</code>. Extracting the whole file hierarchy of an archive and
generating an archive for a file hierarchy is left as an exercise.</p>
<!--TOC paragraph id=sec55 File format specification-->
<h5 class="paragraph" id="sec55">File format specification</h5><!--SEC END --><p>A <code>tar</code> archive is a set of records. Each record represents a
file; it starts with a header which encodes the information
about the file (its name, type, size, owners, etc.) and is followed by 
the contents of the file. The header is a block of 512 bytes structured as
shown in table <a href="#fig%2Ftar">3</a>.</p><div class="table">
<table class="c000 cellpading0"><tr><td class="c011">Offset</td><td class="c011">Length</td><td class="c010">Code Type</td><td class="c010">Name</td><td class="c010">Description </td></tr>
<tr><td class="hbar" colspan=5></td></tr>
<tr><td class="c011"> 0</td><td class="c011">100</td><td class="c010">string</td><td class="c010"><code>name</code></td><td class="c010">File name </td></tr>
<tr><td class="c011">100</td><td class="c011">8</td><td class="c010">octal</td><td class="c010"><code>perm</code></td><td class="c010">File permissions</td></tr>
<tr><td class="c011">108</td><td class="c011">8</td><td class="c010">octal</td><td class="c010"><code>uid</code></td><td class="c010">Id of user owner</td></tr>
<tr><td class="c011">116</td><td class="c011">8</td><td class="c010">octal</td><td class="c010"><code>gid</code></td><td class="c010">Id of group owner</td></tr>
<tr><td class="c011">124</td><td class="c011">12</td><td class="c010">octal</td><td class="c010"><code>size</code></td><td class="c010">File size (in bytes)</td></tr>
<tr><td class="c011">136</td><td class="c011">12</td><td class="c010">octal</td><td class="c010"><code>mtime</code></td><td class="c010">Date of last modification</td></tr>
<tr><td class="c011">148</td><td class="c011">8</td><td class="c010">octal</td><td class="c010"><code>checksum</code></td><td class="c010">Header checksum </td></tr>
<tr><td class="c011">156</td><td class="c011">1</td><td class="c010">character</td><td class="c010"><code>kind</code></td><td class="c010">File type </td></tr>
<tr><td class="c011">157</td><td class="c011">100</td><td class="c010">octal</td><td class="c010"><code>link</code></td><td class="c010">Link</td></tr>
<tr><td class="c011">257</td><td class="c011">8</td><td class="c010">string</td><td class="c010"><code>magic</code></td><td class="c010">Signature (<code>"ustar\032\032\0"</code>)</td></tr>
<tr><td class="c011">265</td><td class="c011">32</td><td class="c010">string</td><td class="c010"><code>user</code></td><td class="c010">Name of user owner</td></tr>
<tr><td class="c011">297</td><td class="c011">32</td><td class="c010">string</td><td class="c010"><code>group</code></td><td class="c010">Name of group owner</td></tr>
<tr><td class="c011">329</td><td class="c011">8</td><td class="c010">octal</td><td class="c010"><code>major</code></td><td class="c010">Peripheral major number</td></tr>
<tr><td class="c011">337</td><td class="c011">8</td><td class="c010">octal</td><td class="c010"><code>minor</code></td><td class="c010">Peripheral minor number</td></tr>
<tr><td class="c011">345</td><td class="c011">167</td><td class="c010">&nbsp;</td><td class="c010">&nbsp;</td><td class="c010">Padding <br>
</td></tr>
<tr><td class="hbar" colspan=5></td></tr>
</table>
<div class="flushleft">
<span class="c002"><span class="c006">Note.</span>  Field lengths are in number of
bytes. All fields are encoded with character strings terminated with
the null character <code>'\000'</code>; except the fields <code>kind</code> and
<code>size</code> in which <code>'\000'</code> optional.
</span></div>


<a id="fig/tar"></a>
<div class="caption">Table 3 — Header structure</div></div><p>
The file contents is stored right after the header, its size is
rounded to a multiple of 512 bytes (the extra space is filled with
zeros). Records are stored one after the other. If needed, the file is
padded with empty blocks to reach at least 20 blocks.</p><p>Since tar archives are also designed to be written on brittle media
and reread many years later, the header contains a <code>checksum</code>
field which allows to detect when the header is damaged. Its value is
the sum of all the bytes of the header (to compute that sum we assume
that the <code>checksum</code> field itself is made of zeros).</p><p>The <code>kind</code> header field encodes the file type in a byte as follows<sup><a id="text5" href="#note5">4</a></sup>:
</p><div class="center">
<table class="c000 cellpading0"><tr><td class="c009"><code>'\0'</code> or <code>'0'</code></td><td class="c009"><code>'1'</code></td><td class="c009"><code>'2'</code></td><td class="c009"><code>'3'</code></td><td class="c009"><code>'4'</code></td><td class="c009"><code>'5'</code></td><td class="c009"><code>'6'</code></td><td class="c009"><code>'7'</code></td></tr>
<tr><td class="hbar" colspan=8></td></tr>
<tr><td class="c009"><code>REG</code></td><td class="c009"><code>LINK</code></td><td class="c009"><code>LNK</code></td><td class="c009"><code>CHR</code></td><td class="c009"><code>BLK</code></td><td class="c009"><code>DIR</code></td><td class="c009"><code>FIFO</code></td><td class="c009"><code>CONT</code>
</td></tr>
</table>
</div><p>
Most of the cases correspond to the values of the Unix file type
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_kind"><span class="c001">file_kind</span></a> stored in the <code>st_kind</code> field of the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEstats"><span class="c001">stats</span></a> structure. <code>LINK</code> is for hard links which
must lead to another file already stored within the archive. <code>CONT</code>
is for ordinary file, but stored in a contiguous area of memory (this
is a feature of some file systems, we can treat it like an ordinary
file).</p><p>The <code>link</code> header field stores the link when <code>kind</code> is <code>LNK</code>
or <code>LINK</code>. The fields <code>major</code> and <code>minor</code> contain the major
and minor numbers of the peripheral when <code>kind</code> is <code>CHR</code> or
<code>BLK</code>. These three fields are not used in other cases.</p><p>The value of the <code>kind</code> field is naturally represented by a
variant type and the header by a record:

</p><div class="mylisting"><span class="c006">type</span> kind =
  | REG | LNK <span class="c006">of</span> string | LINK <span class="c006">of</span> string | CHR <span class="c006">of</span> int * int
  | BLK <span class="c006">of</span> int * int | DIR | FIFO | CONT

<span class="c006">type</span> header =
    { name : string; perm : int; uid : int; gid : int; size : int;
      mtime : int; kind : kind; user : string; group : string }</div>
<!--TOC paragraph id=sec56 Reading a header-->
<h5 class="paragraph" id="sec56">Reading a header</h5><!--SEC END --><p>
Reading a header is not very interesting, but it cannot be ignored.
</p><div class="mylisting"><span class="c006">exception</span> Error <span class="c006">of</span> string * string
<span class="c006">let</span> error err mes = raise (Error (err, mes));;
<span class="c006">let</span> handle_error f s =
  <span class="c006">try</span> f s <span class="c006">with</span>
  | Error (err, mes) -&gt;
      Printf.eprintf "Error: %s: %s" err mes;
      exit 2

<span class="c006">let</span> substring s offset len =
  <span class="c006">let</span> max_length = min (offset + len + 1) (String.length s) <span class="c006">in
  let rec</span> real_length j =
    <span class="c006">if</span> j &lt; max_length &amp;&amp; s.[j] &lt;&gt; '\000' <span class="c006">then</span> real_length (succ j)
    <span class="c006">else</span> j - offset <span class="c006">in</span>
  String.sub s offset (real_length offset);;

<span class="c006">let</span> integer_of_octal nbytes s offset =
  <span class="c006">let</span> i = int_of_string ("0o" ^ substring s offset nbytes) <span class="c006">in
  if</span> i &lt; 0 <span class="c006">then</span> error "Corrupted archive" "integer too large" <span class="c006">else</span> i;;

<span class="c006">let</span> kind s i = <span class="c006">match</span> s.[i] <span class="c006">with</span>
  | '\000' | '0' -&gt; REG
  | '1' -&gt; LINK (substring s (succ i) 99)
  | '2' -&gt; LNK (substring s (succ i) 99)
  | '3' -&gt; CHR (integer_of_octal 8 s 329, integer_of_octal 8 s 329)
  | '4' -&gt; BLK (integer_of_octal 8 s 329, integer_of_octal 8 s 337)
  | '5' -&gt; DIR | '6' -&gt; FIFO | '7' -&gt; CONT
  | _ -&gt; error "Corrupted archive" "kind"

<span class="c006">let</span> header_of_string s =
  { name = substring s 0 99;
    perm = integer_of_octal 8 s 100;
    uid = integer_of_octal 8 s 108;
    gid = integer_of_octal 8 s 116;
    size = integer_of_octal 12 s 124;
    mtime = integer_of_octal 12 s 136;
    kind = kind s 156;
    user = substring s 265 32;
    group = substring s 297 32; }

<span class="c006">let</span> block_size = 512;;
<span class="c006">let</span> total_size size =
  block_size + ((block_size -1 + size) / block_size) * block_size;;</div><p>An archive ends either at the end of file where a new record would
start or on a complete, but empty, block. To read a header we thus try
to read a block which must be either empty or complete. For that we
reuse the <code>really_read</code> function defined earlier. The end of file
should not be reached when we try to read a block.

</p><div class="mylisting"><span class="c006">let</span> buffer_size = block_size;;
<span class="c006">let</span> buffer = String.create buffer_size;;

<span class="c006">let</span> end_of_file_error () =
  error "Corrupted archive" "unexpected end of file"
<span class="c006">let</span> without_end_of_file f x =
  <span class="c006">try</span> f x <span class="c006">with</span> End_of_file -&gt; end_of_file_error ()

<span class="c006">let</span> read_header fd =
  <span class="c006">let</span> len = read fd buffer 0 buffer_size <span class="c006">in
  if</span> len = 0 ||  buffer.[0] = '\000' <span class="c006">then</span> None
  <span class="c006">else begin
    if</span> len &lt; buffer_size <span class="c006">then</span>
      without_end_of_file (really_read fd buffer len) (buffer_size - len);
    Some (header_of_string buffer)
  <span class="c006">end</span>;;</div>
<!--TOC paragraph id=sec57 Reading an archive-->
<h5 class="paragraph" id="sec57">Reading an archive</h5><!--SEC END --><p>
To perform an operation in an archive, we need to read the records
sequentially until we find the target of the operation. Usually we
just need to read the header of each record without its contents but
sometimes we also need to get back to a previous one to read its
contents. As such we keep, for each record, its header and its location
in the archive:
</p><div class="mylisting"><span class="c006">type</span> record = { header : header; offset : int; descr : file_descr };;</div><p>We define a general iterator that reads and accumulates the records
of an archive (without their contents). To remain general, the
accumulating function <code>f</code> is abstracted. This allows to use the 
same iterator function to display records, destroy them, etc. 
</p><div class="mylisting"><span class="c006">let</span> fold f initial fd  =
  <span class="c006">let rec</span> fold_aux offset accu =
    ignore (without_end_of_file (lseek fd offset) SEEK_SET);
    <span class="c006">match</span> without_end_of_file read_header fd <span class="c006">with</span>
      Some h -&gt;
        <span class="c006">let</span> r =
          { header = h; offset = offset + block_size; descr = fd } <span class="c006">in</span>
        fold_aux (offset + total_size h.size) (f r accu)
    | None -&gt; accu <span class="c006">in</span>
  fold_aux 0 initial;;</div><p>The function <code>fold_aux</code> starts from a position <code>offset</code> with a
partial result <code>accu</code>. It moves to <code>offset</code> where a record
should start, reads a header, constructs the record <code>r</code> and starts
again at the end of the record with the new (less partial) result
<code>f r accu</code>. It stops when there’s no header: the end of the archive
was reached.</p>
<!--TOC paragraph id=sec58 Display the record names-->
<h5 class="paragraph" id="sec58">Display the record names</h5><!--SEC END --><p>
We just display the name of records without keeping them:
</p><div class="mylisting"><span class="c006">let</span> list tarfile =
  <span class="c006">let</span> fd = openfile tarfile [ O_RDONLY ] 0o0 <span class="c006">in
  let</span> add r () = print_string r.header.name; print_newline () <span class="c006">in</span>
  fold add () fd;
  close fd</div>
<!--TOC paragraph id=sec59 Display the contents of a record-->
<h5 class="paragraph" id="sec59">Display the contents of a record</h5><!--SEC END --><p>
The command <code>readtar a f</code> must look for the file <code>f</code> in the
archive and, if it is a regular file, display its contents. If <code>f</code>
is a hard link on <code>g</code> in the archive, we follow the link and
display <code>g</code> since even though <code>f</code> and <code>g</code> are represented
differently in the archive they represent the same file. The fact that
<code>g</code> or <code>f</code> is a link on the other or vice versa depends only on
the order in which the files were traversed when the archive was
created. For now we do not follow symbol links.</p><p>Hard link resolution is done by the following mutually recursive
functions:
</p><div class="mylisting"><span class="c006">let rec</span> find_regular r list = <span class="c006">match</span> r.header.kind <span class="c006">with</span>
  | REG | CONT -&gt; r
  | LINK name -&gt; find_file name list
  | _ -&gt; error r.header.name "Not a regular file"

<span class="c006">and</span> find_file name list = <span class="c006">match</span> list <span class="c006">with</span>
  | r :: rest -&gt;
      <span class="c006">if</span> r.header.name = name <span class="c006">then</span> find_regular r rest
      <span class="c006">else</span> find_file name rest
  | [] -&gt; error name "Link not found (corrupted archive)";;</div><p>The function <code>find_regular</code> finds the regular file corresponding to
the record <code>r</code>. If <code>r</code> is a regular file itself, <code>r</code> is
returned. If <code>r</code> is a hard link the function looks for the regular
file in the archive’s previous records stored in <code>list</code> with the
function <code>find_file</code>. In all other cases, the function aborts.</p><p>Once the record is found we just need to display its contents. After
positioning the descriptor at the start of the record’s contents this
operation is very similar to the <code>file_copy</code> example.
</p><div class="mylisting"><span class="c006">let</span> copy_file file output =
  ignore (lseek file.descr file.offset SEEK_SET);
  <span class="c006">let rec</span> copy_loop len =
    <span class="c006">if</span> len &gt; 0 <span class="c006">then
      match</span> read file.descr buffer 0 (min buffer_size len) <span class="c006">with</span>
      | 0 -&gt; end_of_file_error ()
      | r -&gt; ignore (write output buffer 0 r); copy_loop (len-r) <span class="c006">in</span>
  copy_loop file.header.size</div><p>We now just need to combine these functions correctly.
</p><div class="mylisting"><span class="c006">exception</span> Done
<span class="c006">let</span> find_and_copy tarfile filename =
  <span class="c006">let</span> fd = openfile tarfile [ O_RDONLY ] 0o0 <span class="c006">in
  let</span> found_or_collect r accu =
    <span class="c006">if</span> r.header.name = filename <span class="c006">then begin</span>
      copy_file (find_regular r accu) stdout;
      raise Done
    <span class="c006">end else</span> r :: accu <span class="c006">in
  try</span>
     ignore (fold found_or_collect [] fd);
     error "File not found" filename
  <span class="c006">with</span>
  | Done -&gt; close fd</div><p>We read the records in the archive (but not their contents) until we
find the record with the target name. We then call the function
<code>find_regular</code> to find the record that actually contains the file.
This second, backward, search must succeed if the archive is
well-formed. The first search may however fail if the target name is
not in the archive. In case of failure, the program takes care to
distinguish between these two cases.</p><p>Here is the main function which implements the command <code>readtar</code>:

</p><div class="mylisting"><span class="c006">let</span> readtar () =
  <span class="c006">let</span> nargs = Array.length Sys.argv <span class="c006">in
  if</span> nargs = 2 <span class="c006">then</span> list Sys.argv.(1)
  <span class="c006">else if</span> nargs = 3 <span class="c006">then</span> find_and_copy Sys.argv.(1) Sys.argv.(2)
  <span class="c006">else</span>
    prerr_endline ("Usage: " ^Sys.argv.(0)^ " &lt;tarfile&gt; [ &lt;source&gt; ]");;

handle_unix_error (handle_error readtar) ();;</div><div class="exercise">
<!--TOC paragraph id=sec60 Exercise 7-->
<h5 class="paragraph" id="sec60">Exercise 7</h5><!--SEC END --><p><a id="ex7"></a><a id="ex/readtar"></a>
Extend the command <code>readtar</code> so that it follows symbolic links in
the sense that if the link points to a file of the archive that file’s
contents should be extracted. 
<a href="#exans7">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 7</arg>-->
<!--NAME exercise7.html-->
<div class="answer">
<!--TOC paragraph id=sec61 Answer of exercise 7-->
<h5 class="paragraph" id="sec61">Answer of <a href="#ex7">exercise 7</a></h5><!--SEC END --><p>
<a id="exans7"></a>
Behind this apparently trivial requirement are hidden difficulties.
Symbolic links are arbitrary paths, they can point on directories
(which is not allowed for hard links) and they may not correspond to
files contained in the archive.</p><p>A simple solution is to recreate, in memory, the file hierarchy
contained in the archive.

</p><div class="mylisting"><span class="c006">type</span> info = File | Link <span class="c006">of</span> string list | Dir <span class="c006">of</span> (string * inode) list
<span class="c006">and</span> inode = { <span class="c006">mutable</span> record : record option; <span class="c006">mutable</span> info : info;}</div><p>Nodes of this in-memory file system are described by the <code>inode</code>
type. The <code>info</code> field describes the file type, limited to ordinary
files, symbolic links and directories. Paths are represented by lists
of strings and directories by lists that associate a node to each file
name in the directory. The <code>record</code> field stores the <code>tar</code>
record associated to the node. This field is optional because
intermediate directories are not always present in the archive; it is
mutable because a file may appear more than once in the archive and
the last occurrence takes precedence over the other.
</p><div class="mylisting"><span class="c006">let</span> root () =
  <span class="c006">let rec</span> i =
    { record = None; info = Dir [ Filename.current_dir_name, i ] }
  <span class="c006">in</span> i
<span class="c006">let</span> link inode name nod = <span class="c006">match</span> inode.info <span class="c006">with</span>
  | File | Link _ -&gt; error name "Not a directory"
  | Dir list -&gt;
      <span class="c006">try let</span> _ = List.assoc name list <span class="c006">in</span> error name "Already exists"
      <span class="c006">with</span> Not_found -&gt; inode.info &lt;- Dir ((name, nod) :: list)

<span class="c006">let</span> mkfile inode name r =
  <span class="c006">let</span> f =  { record = r; info = File } <span class="c006">in</span>
  link inode name f; f
<span class="c006">let</span> symlink inode name r path =
  <span class="c006">let</span> s =  { record = r; info = Link path } <span class="c006">in</span>
  link inode name s; s
<span class="c006">let</span> mkdir inode name r =
  <span class="c006">let</span> d = mkfile inode name r <span class="c006">in</span>
  d.info &lt;-
    Dir [ Filename.current_dir_name, d; Filename.parent_dir_name, inode ];
  d</div><p>As in Unix, each directory contains a link to itself and 
to its parent, except for the root directory (in contrast to Unix
where it is its own parent). This allows us to detect and
forbid any access outside the hierarchy contained in the archive.
</p><div class="mylisting"><span class="c006">let rec</span> find link inode path = <span class="c006">match</span> inode.info, path <span class="c006">with</span>
  | _, [] -&gt; inode
  | Dir list, name :: rest -&gt;
      <span class="c006">let</span> subnode = List.assoc name list <span class="c006">in
      let</span> subnode =
        <span class="c006">match</span> subnode.info <span class="c006">with</span>
          Link q -&gt;
            <span class="c006">if</span> link &amp;&amp; rest = [] <span class="c006">then</span> subnode <span class="c006">else</span> find <span class="c006">false</span> inode q
        | _ -&gt; subnode  <span class="c006">in</span>
      find link subnode rest
  | _, _ -&gt; raise Not_found;;</div><p>The function <code>find</code> finds in the archive the node corresponding to
<code>path</code> by starting from the initial node <code>inode</code>. If the search
result is a link, the flag <code>link</code> indicates whether the link itself
should be returned (true) or the file pointed by the link (false).
</p><div class="mylisting"><span class="c006">let rec</span> mkpath inode path =
  <span class="c006">match</span> inode.info, path <span class="c006">with</span>
  | _, [] -&gt; inode
  | Dir list, name :: rest -&gt;
      <span class="c006">let</span> subnode =
        <span class="c006">try</span> List.assoc name list
        <span class="c006">with</span> Not_found -&gt;  mkdir inode name None <span class="c006">in</span>
      mkpath subnode rest
  | _, _ -&gt; raise Not_found;;</div><p>The function <code>mkpath</code> traverses the path <code>path</code> creating missing
nodes along the path. 
</p><div class="mylisting"><span class="c006">let</span> explode f =
  <span class="c006">let rec</span> dec f p =
    <span class="c006">if</span> f = Filename.current_dir_name <span class="c006">then</span> p
    <span class="c006">else</span> dec (Filename.dirname f) (Filename.basename f :: p) <span class="c006">in</span>
  dec (<span class="c006">if</span> Filename.basename f = "" <span class="c006">then</span> Filename.dirname f <span class="c006">else</span> f) [];;</div><p>The function <code>explode</code> parses a Unix path into a list of strings. 
It removes the end “<code>/</code>” of directory names which are allowed 
in archives. 

</p><div class="mylisting"><span class="c006">let</span> add archive r =
  <span class="c006">match</span> r.header.kind <span class="c006">with</span>
  | CHR (_,_) | BLK (_,_) | FIFO -&gt; ()
  | kind -&gt;
      <span class="c006">match</span> List.rev (explode r.header.name) <span class="c006">with</span>
      | []  -&gt; ()
      | name :: parent_rev -&gt;
          <span class="c006">let</span> inode = mkpath archive (List.rev parent_rev) <span class="c006">in
          match</span> kind <span class="c006">with</span>
          | DIR -&gt; ignore (mkdir inode name (Some r))
          | REG | CONT -&gt; ignore (mkfile inode name (Some r))
          | LNK f -&gt; ignore (symlink inode name (Some r) (explode f))
          | LINK f -&gt; link inode name (find <span class="c006">true</span> archive (explode f))
          | _ -&gt; <span class="c006">assert false</span>;;</div><p>The function <code>add</code> adds the record <code>r</code> to
the archive. The archive, represented by its root node, is modified by a 
side effect. 
</p><div class="mylisting"><span class="c006">let</span> find_and_copy tarfile filename =
  <span class="c006">let</span> fd = openfile tarfile [ O_RDONLY ] 0 <span class="c006">in
  let</span> records = List.rev (fold (<span class="c006">fun</span> x y -&gt; x :: y) [] fd) <span class="c006">in
  let</span> archive = root () <span class="c006">in</span>
  List.iter (add archive) records;
  <span class="c006">let</span> inode =
    <span class="c006">try</span> find <span class="c006">false</span> archive (explode filename)
    <span class="c006">with</span> Not_found -&gt; error filename "File not found" <span class="c006">in
  begin match</span> inode.record <span class="c006">with</span>
  | Some ({ header = { kind = (REG | CONT) }} <span class="c006">as</span> r) -&gt; copy_file r stdout
  | Some _ -&gt; error filename "Not a regular file"
  | None -&gt; error filename "Not found"
  <span class="c006">end</span>;
  close fd;;</div><p>We end as before. 
</p><div class="mylisting"><span class="c006">let</span> readtar () =
  <span class="c006">let</span> nargs = Array.length Sys.argv <span class="c006">in
  if</span> nargs = 2 <span class="c006">then</span> list Sys.argv.(1)
  <span class="c006">else if</span> nargs = 3 <span class="c006">then</span> find_and_copy Sys.argv.(1) Sys.argv.(2)
  <span class="c006">else</span> prerr_endline ("Usage: " ^Sys.argv.(0)^ " &lt;tarfile&gt; [ &lt;source&gt; ]");;

Printexc.print (handle_unix_error (handle_error readtar)) ();;</div><div class="fancybreak">* * *</div></div><!--END FLOW-->
<div class="exercise">
<!--TOC paragraph id=sec62 Exercise 8-->
<h5 class="paragraph" id="sec62">Exercise 8</h5><!--SEC END --><p><a id="ex8"></a><a id="ex/untar"></a>
Write a command <code>untar</code> such that <code>untar a</code> extracts and creates 
all the files in the archive <code>a</code> (except special files) 
restoring if possible the information about the files
(owners, permissions) as found in the archive.</p><p>The file hierarchy should be reconstructed in the current working
directory of the <code>untar</code> command. If the archive tries to create
files outside a sub-directory of the current working directory this
should be detected and prohibited. Nonexistent directories not explicitly
mentioned in the archive should be created with the user’s default
permissions.
<a href="#exans8">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 8</arg>-->
<!--NAME exercise8.html-->
<div class="answer">
<!--TOC paragraph id=sec63 Answer of exercise 8-->
<h5 class="paragraph" id="sec63">Answer of <a href="#ex8">exercise 8</a></h5><!--SEC END --><p>
<a id="exans8"></a>
This exercise combines the previous exercise (exercise <a href="#ex%2Freadtar">2.16</a>)
and the recursive file copy (exercise <a href="#ex%2Fcopyrec">2.15</a>).</p><p>One small difficulty is the management of permissions: we must create
the archive’s directories with write permission and set them to their
actual value only after all the files were extracted.</p><p>Let us first write an auxiliary function for <code>mkpath p m</code> that
creates the missing directories along the path <code>p</code> with permissions
<code>m</code> (and such that <code>p</code> may be terminated by a
superfluous “<code>/</code>”).

</p><div class="mylisting"><span class="c006">let</span> warning mes = prerr_string mes;prerr_newline ();;
<span class="c006">open</span> Filename
<span class="c006">let</span> mkpath p perm =
  <span class="c006">let</span> normal_path =
    <span class="c006">if</span> basename p = "" <span class="c006">then</span> dirname p <span class="c006">else</span> p <span class="c006">in
  let</span> path_to_dir = dirname normal_path <span class="c006">in
  let rec</span> make p =
    <span class="c006">try</span> ignore (stat p)
    <span class="c006">with</span> Unix_error (ENOENT, _, _) -&gt;
      <span class="c006">if</span> p = current_dir_name <span class="c006">then</span> ()
      <span class="c006">else if</span> p = parent_dir_name <span class="c006">then</span>
        warning "Ill formed archive: path contains \"..\""
      <span class="c006">else begin</span>
        make (dirname p);
        mkdir p perm
      <span class="c006">end in</span>
  make path_to_dir;;</div><p>We also define a function <code>set_infos</code> similar to the one
used to copy files (section <a href="#sec51">2.15</a>):
</p><div class="mylisting"><span class="c006">let</span> set_infos header =
  chmod header.name header.perm;
  <span class="c006">let</span> mtime = float header.mtime <span class="c006">in</span>
  utimes header.name mtime mtime;
  <span class="c006">begin match</span> header.kind <span class="c006">with</span>
  | LNK f -&gt; ()
  | _ -&gt;  chmod header.name header.perm
  <span class="c006">end</span>;
  <span class="c006">try</span> chown header.name  header.uid header.gid
  <span class="c006">with</span> Unix_error(EPERM,_,_) -&gt; ();;</div><p>The main function of the program is <code>untar_file_collect_dirs</code> which 
processes a single record and accumulates directories explicitly
created by the archive:
</p><div class="mylisting"><span class="c006">let</span> verbose = <span class="c006">ref true</span>;;
<span class="c006">let</span> default_dir_perm = 0o777;;
<span class="c006">let</span> default_file_perm = 0o666;;

<span class="c006">let</span> protect f x g y = <span class="c006">try</span> f x; g y <span class="c006">with</span> z -&gt; g y; raise z
<span class="c006">let</span> file_exists f = <span class="c006">try</span> ignore (stat f); <span class="c006">true with</span> _ -&gt; <span class="c006">false</span>;;

<span class="c006">let</span> untar_file_collect_dirs file dirs =
  <span class="c006">let</span> fh = file.header <span class="c006">in
  if</span> !verbose <span class="c006">then begin</span> print_string fh.name; print_newline () <span class="c006">end</span>;
  <span class="c006">match</span> fh.kind <span class="c006">with</span>
  | CHR (_,_) | BLK(_,_) | FIFO -&gt;
      warning (fh.name ^ "Ignoring special files");
      dirs
  | DIR -&gt;
      mkpath fh.name default_dir_perm;
      <span class="c006">if</span> file_exists fh.name <span class="c006">then</span> dirs
      <span class="c006">else begin</span> mkdir fh.name default_dir_perm; fh :: dirs <span class="c006">end</span>
  | x -&gt;
      mkpath fh.name default_dir_perm;
      <span class="c006">begin match</span> x <span class="c006">with</span>
      | REG | CONT -&gt;
          <span class="c006">let</span> flags = [ O_WRONLY; O_TRUNC; O_CREAT; ] <span class="c006">in
          let</span> out = openfile fh.name flags default_file_perm <span class="c006">in</span>
          protect (copy_file file) out close out
      | LNK f -&gt;
          symlink f fh.name
      | LINK f -&gt;
          <span class="c006">begin
            try if</span> (stat fh.name).st_kind = S_REG <span class="c006">then</span> unlink fh.name
            <span class="c006">with</span> Unix_error(_,_,_) -&gt; ();
          <span class="c006">end</span>;
          Unix.link f fh.name;
      | _ -&gt; <span class="c006">assert false
      end</span>;
      set_infos fh;
      dirs;;</div><p>The body of the program just iterates <code>untar_file_collect_dirs</code> on
the records and finally updates the directories with the correct access
rights. 
</p><div class="mylisting"><span class="c006">let</span> extract tarfile =
  <span class="c006">let</span> fd = openfile tarfile [ O_RDONLY ] 0 <span class="c006">in
  let</span> new_directories =
    fold untar_file_collect_dirs [] fd <span class="c006">in</span>
  List.iter set_infos new_directories;
  close fd;;</div><div class="mylisting"><span class="c006">let</span> untar () =
  <span class="c006">let</span> nargs = Array.length Sys.argv <span class="c006">in
  if</span> nargs = 2 <span class="c006">then</span> extract Sys.argv.(1)
  <span class="c006">else</span> prerr_endline ("Usage: " ^ Sys.argv.(0) ^ " &lt;tarfile&gt;");;
handle_unix_error untar ();;</div><div class="fancybreak">* * *</div></div><!--END FLOW-->
<div class="exercise">
<!--TOC paragraph id=sec64 Exercise 9-->
<h5 class="paragraph" id="sec64">Exercise 9</h5><!--SEC END --><p><a id="ex9"></a>
<a id="ex/maketar"></a>
Write a program <code>tar</code> such that <code>tar -xvf a f1 f2 ...</code>
constructs the archive <code>a</code> containing the list of files <code>f1</code>,
<code>f2</code>, etc. and their sub-directories. 
<a href="#exans9">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 9</arg>-->
<!--NAME exercise9.html-->
<div class="answer">
<!--TOC paragraph id=sec65 Answer of exercise 9-->
<h5 class="paragraph" id="sec65">Answer of <a href="#ex9">exercise 9</a></h5><!--SEC END --><p>
<a id="exans9"></a>
We reuse the data structures already defined above and collect them in
a <code>Tarlib</code> module. We define a warning function which does not stop
the program or alter the return code of the program.
</p><div class="mylisting"><span class="c006">open</span> Sys
<span class="c006">open</span> Unix
<span class="c006">open</span> Tarlib

<span class="c006">let</span> warning path message =  prerr_endline (path ^ ": " ^ message)</div><p>We start with the function that writes a record header in a
buffer. It’s a tedious function but it must be done with care as a
single error in a header can corrupt the entire archive. In particular
we must pay attention to the limits imposed by the file format. For
example the size of paths is limited to 99 bytes (There are extensions
to the format to handle longer path but it’s not the goal of this
project). 
</p><div class="mylisting"><span class="c006">let</span> write_header_to_buffer source infos kind =
  <span class="c006">let</span> size = <span class="c006">if</span> kind = REG <span class="c006">then</span> infos.st_size <span class="c006">else</span> 0 <span class="c006">in</span>
  String.fill buffer 0 block_size '\000';
  <span class="c006">let</span> put len string offset =
    String.blit string 0 buffer offset (min (String.length string) len) <span class="c006">in
  let</span> put_int8 x = put 7 (Printf.sprintf "%07o" x) <span class="c006">in
  let</span> put_int12 x = put 11 (Printf.sprintf "%011o" x) <span class="c006">in
  let</span> put_char c offset = buffer.[offset] &lt;- c <span class="c006">in
  let</span> put_path s offset =
    <span class="c006">if</span> String.length s &lt;= 99 <span class="c006">then</span> put 99 s offset
    <span class="c006">else</span> raise (Error ("path too long", s)) <span class="c006">in</span>
  put_path (<span class="c006">if</span> kind = DIR <span class="c006">then</span> source ^ "/" <span class="c006">else</span> source) 0;
  put_int8 infos.st_perm 100;
  put_int8 infos.st_uid 108;
  put_int8 infos.st_gid 116;
  put_int12 size 124;
  put_int12 (int_of_float infos.st_mtime) 136;
  put 7 "ustar  " 257;
  put 31 (getpwuid infos.st_uid).pw_name 265;
  put 31 (getgrgid infos.st_gid).gr_name 297;
  <em>(* Fields dev and rdev are only used for special files, which we omit *)</em>
  put_char
    <span class="c006">begin match</span> kind <span class="c006">with</span>
    | REG -&gt; '0'
    | LINK s -&gt; put_path s 157; '1'
    | LNK s -&gt;  put_path s 157; '2'
    | DIR -&gt; '5'
    | _ -&gt; failwith "Special files not implemented"
    <span class="c006">end</span> 156;
  <span class="c006">let rec</span> sum s i =
    <span class="c006">if</span> i &lt; 0 <span class="c006">then</span> s <span class="c006">else</span> sum (s + Char.code buffer.[i]) (pred i) <span class="c006">in
  let</span> checksum = sum (Char.code ' ' * 8) (block_size - 1)  <span class="c006">in</span>
  put 8 (Printf.sprintf "%06o\000 " checksum) 148;;</div><p>The following function creates a record header for a file. <code>source</code> is
the file name, <code>infos</code> is the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEstats"><span class="c001">stats</span></a> information of
the file and <code>kind</code> is the type of file. 
</p><div class="mylisting"><span class="c006">let</span> header source infos kind = {
  name = source;
  size = <span class="c006">if</span> kind = REG <span class="c006">then</span> infos.st_size <span class="c006">else</span> 0;
  perm = infos.st_perm;
  mtime = int_of_float infos.st_mtime;
  uid = infos.st_uid;
  gid = infos.st_gid;
  user = (getpwuid infos.st_uid).pw_name;
  group = (getgrgid infos.st_gid).gr_name;
  kind = kind }</div><p>To write a file in the archive, we define a variant of <code>file_copy</code>
which takes as an argument the number of bytes to copy and verifies
that the end of file corresponds to that size. Otherwise, an error is
raised: this handles the abnormal case where a file is modified during
the archival process. To limit the archive’s corruption to a single
file we do not write beyond that size. 
</p><div class="mylisting"><span class="c006">let</span> write_file len source fdout =
  <span class="c006">let</span> fdin = openfile source [O_RDONLY] 0 <span class="c006">in
  let</span> error () = raise (Error ("File changed size", source)) <span class="c006">in
  let rec</span> copy_loop len =
    <span class="c006">match</span> read fdin buffer 0 buffer_size <span class="c006">with</span>
      0 -&gt;
        close fdin; <span class="c006">if</span> len &gt; 0 <span class="c006">then</span> error ()
    | r -&gt;
        <span class="c006">let</span> len = len - r  <span class="c006">in
        if</span> len &lt; 0 <span class="c006">then</span> (close fdin; error ());
        ignore (write fdout buffer 0 r); copy_loop len <span class="c006">in</span>
  copy_loop len;;

<span class="c006">let</span> padding fd len =
  <span class="c006">if</span> len &gt; 0 <span class="c006">then</span> ignore (write fd (String.make len '\000') 0 len);;</div><p>We now tackle the creation of the archive. The files already written
in the archive are stored in a hashtable with their path so that they
are not copied more than once. We also store the directories that were
already written so as not to copy them again: it can happen that the
archival root is already contained in another and we don’t want to
copy it again (even though that would be harmless). </p><p>The data needed to write an archive is a file descriptor pointing on
the file to write, the file and directory cache (see above) and a size
variable that remembers the current archive size (to pad it to a
minimal size if needed). The <code>archive</code> type collects all this
information in a record:
</p><div class="mylisting"><span class="c006">type</span> archive =
    { regfiles : (int * int, string) Hashtbl.t;
      dirfiles : (int * int, bool) Hashtbl.t;
      fd : file_descr; st : stats; <span class="c006">mutable</span> size : int }

<span class="c006">let</span> try_new_dir archive dir =
  <span class="c006">try</span> Hashtbl.find archive.dirfiles dir
  <span class="c006">with</span> Not_found -&gt; Hashtbl.add archive.dirfiles dir <span class="c006">false</span>; <span class="c006">true</span></div><p>Here is the main function that writes an entire hierarchy starting
from a <code>file</code> path given on the command line. This function is not
difficult but needs some care with pathological cases. In particular
we saw how to detect when a file is modified the archival. A sub case
of this when the archive is being archived itself…</p><div class="mylisting"><span class="c006">let</span> verbose = <span class="c006">ref true</span>;;

<span class="c006">let</span> write_from archive file =
  <span class="c006">if</span> not (Filename.is_relative file) <span class="c006">then</span>
    raise (Error ("absolute path", file));
  <span class="c006">let rec</span> write_rec archive file =
    <span class="c006">let</span> source =
      <span class="c006">if</span> Filename.basename file = "" <span class="c006">then</span> Filename.dirname file <span class="c006">else</span> file <span class="c006">in
    if</span> !verbose <span class="c006">then begin</span> prerr_endline source <span class="c006">end</span>;
    <span class="c006">let</span> st = lstat source <span class="c006">in
    if</span> st.st_ino = archive.st.st_ino &amp;&amp; st.st_dev = archive.st.st_dev
    <span class="c006">then</span> warning source "Skipping archive itself!"
    <span class="c006">else
      let</span> write_header kind =
        write_header_to_buffer source st kind;
        ignore (write archive.fd buffer 0 block_size) <span class="c006">in
      match</span> st.st_kind <span class="c006">with</span>
        S_REG -&gt;
          <span class="c006">begin try
            if</span> st.st_nlink = 1 <span class="c006">then</span> raise Not_found;
            <span class="c006">let</span> path =
              Hashtbl.find archive.regfiles (st.st_ino, st.st_dev) <span class="c006">in</span>
            write_header (LINK path);
          <span class="c006">with</span> Not_found -&gt;
            <span class="c006">if</span> st.st_nlink &gt; 1 <span class="c006">then</span>
              Hashtbl.add archive.regfiles (st.st_ino, st.st_dev) source;
            write_header REG;
            write_file st.st_size source archive.fd;
            <span class="c006">let</span> t =
              (block_size-1 + st.st_size) / block_size * block_size <span class="c006">in</span>
            padding archive.fd (t - st.st_size);
            archive.size &lt;- archive.size + t + block_size;
          <span class="c006">end</span>
      | S_LNK -&gt;
          write_header (LNK (readlink source));
      | S_DIR <span class="c006">when</span> try_new_dir archive (st.st_ino, st.st_dev) -&gt;
          write_header DIR;
          Misc.iter_dir
            <span class="c006">begin
              fun</span> file -&gt;
                <span class="c006">if</span> file = Filename.current_dir_name <span class="c006">then</span> ()
                <span class="c006">else if</span> file = Filename.parent_dir_name <span class="c006">then</span> ()
                <span class="c006">else</span> write_rec archive (source ^ "/" ^ file)
            <span class="c006">end</span>
            source
      | S_DIR -&gt;
          warning source "Ignoring directory already in archive."
      | _ -&gt;
          prerr_endline ("Can't cope with special file " ^ source) <span class="c006">in</span>
  write_rec archive file;;</div><p>We keep track of regular files that may have hard links in the
<code>regfiles</code> table. It’s not necessary for files that have a single
link.</p><p>Here’s the main function. In case of error, it is better to remove the
erroneous archive.
</p><div class="mylisting"><span class="c006">let</span> min_archive_size = 20 * block_size;;

<span class="c006">let</span> build tarfile files =
  <span class="c006">let</span> fd, remove =
    <span class="c006">if</span> tarfile = "-" <span class="c006">then</span> stdout, ignore
    <span class="c006">else</span> openfile tarfile [ O_WRONLY; O_CREAT; O_TRUNC ] 0o666, unlink <span class="c006">in
  try
    let</span> arch =
         { regfiles = Hashtbl.create 13; dirfiles = Hashtbl.create 13;
           st = fstat fd; fd = fd; size =0 } <span class="c006">in</span>
    Array.iter (write_from arch) files;
    padding fd (min_archive_size - arch.size);
    close fd
  <span class="c006">with</span> z -&gt;
    remove tarfile; close fd; raise z;;</div><p>We end by parsing the command line arguments. 
</p><div class="mylisting"><span class="c006">let</span> usage () =
  prerr_endline "Usage: tar -cvf tarfile file1 [ file2 ... ] ";
  exit 2;;

<span class="c006">let</span> tar () =
  <span class="c006">let</span> argn = Array.length Sys.argv <span class="c006">in
  if</span> argn &gt; 3 &amp;&amp; Sys.argv.(1) = "-cvf" <span class="c006">then</span>
    build Sys.argv.(2) (Array.sub Sys.argv 3 (argn-3))
  <span class="c006">else</span> usage ();;

<span class="c006">let</span> _ =
  <span class="c006">try</span> handle_unix_error tar ()
  <span class="c006">with</span> Error (mes, s) -&gt;
    prerr_endline ("Error: " ^ mes ^ ": " ^ s); exit 1;;</div><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note2" href="#text2">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">This is not 
possible if the lock file
is located on a <span class="c005">nfs</span> partition, because <span class="c005">nfs</span> does
not implement the option <code>O_CREAT</code> of <code><span class="c006">open</span></code> correctly.</div>
</dd><dt class="dt-thefootnotes"><a id="note3" href="#text3">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">In fact, OCaml limits the size of data
transfers to 16KB (in the current version) and repeats <code>write</code>
system calls to make the complete transfer — see the discussion in
section <a href="#sec118">5.7</a>. But this limit is bigger than the
size of system caches and it is not observable.</div>
</dd><dt class="dt-thefootnotes"><a id="note4" href="#text4">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">The Cash library [<a href="#Cash">3</a>] supplies
such functions.</div>
</dd><dt class="dt-thefootnotes"><a id="note5" href="#text5">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">This field can 
also take different values to encode
pathological cases, for example when the value of a field exceeds
its size or in extensions of the
<code>tar</code> format.</div>
</dd></dl>
<!--END NOTES-->
<!--TOC chapter id=sec66 Processes-->
<h1 class="chapter" id="sec66"> 3  Processes</h1><!--SEC END --><!--NAME processes.html-->
<p>A process is a program executing on the operating system. It
consists of a program (machine code) and a state of the program
(current control point, variable values, call stack, open file
descriptors, etc.).</p><p>This section presents the Unix system calls to create new processes
and make them run other programs.</p>
<!--TOC section id=sec67 Creation of processes-->
<h2 class="section" id="sec67">3.1  Creation of processes</h2><!--SEC END --><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/fork.html"><span class="c001">fork</span></a><a id="hevea_default69"></a> creates a process.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfork">fork</a> : unit -&gt; int</div><p>The new <em>child process</em> is a nearly perfect clone of the
<em>parent process</em> which called <code>fork</code>. Both processes execute
the same code, are initially at the same control point (the return
from <code>fork</code>), attribute the same values to all variables, have
identical call stacks, and hold open the same file descriptors to
the same files. The only thing which distinguishes the two processes
is the return value from <code>fork</code>: zero in the child process,
and a non-zero integer in the parent. By checking the return value
from <code>fork</code>, a program can thus determine if it is in the parent
process or the child and behave accordingly: 
</p><div class="mylisting"><span class="c006">match</span> fork () <span class="c006">with</span>
| 0 -&gt;   <em>(* code run only in the child  *)</em>
| pid -&gt; <em>(* code run only in the parent *)</em></div><p>The non-zero integer returned by <code>fork</code> in the parent process
is the <em>process id</em> of the child. The process id is used by
the kernel to uniquely identify each process. A process can obtain
its process id by calling <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetpid"><span class="c001">getpid</span></a><a id="hevea_default70"></a>.</p><p>The child process is initially in the same state as the parent process
(same variable values, same open file descriptors). This state is not
shared between the parent and the child, but merely duplicated at the
moment of the <code>fork</code>. For example, if one variable is bound to a
reference before the <code>fork</code>, a copy of that reference and its
current contents is made at the moment of the <code>fork</code>; after the
<code>fork</code>, each process independently modifies its “own”
reference without affecting the other process.</p><p>Similarly, the open file descriptors are copied at the moment of the
<code>fork</code>: one may be closed and the other kept open. On the other
hand, the two descriptors designate the same entry in the file table
(residing in system memory) and share their current position: if one
reads and then the other, each will read a different part of the file;
likewise, changes in the read/write position by one process with <code>lseek</code> are
immediately visible to the other. </p>
<!--TOC section id=sec68 Complete Example: the command <span class="c001">leave</span>-->
<h2 class="section" id="sec68">3.2  Complete Example: the command <span class="c001">leave</span></h2><!--SEC END --><p>The command <code>leave hhmm</code> exits immediately, but
forks a background process which, at the time <code>hhmm</code>, reports that
it is time to leave.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">open</span> Unix;;
<span class="c003">   2</span> 
<span class="c003">   3</span> <span class="c006">let</span> leave () =
<span class="c003">   4</span>  <span class="c006">let</span> hh = int_of_string (String.sub Sys.argv.(1) 0 2)
<span class="c003">   5</span>  <span class="c006">and</span> mm = int_of_string (String.sub Sys.argv.(1) 2 2) <span class="c006">in</span>
<span class="c003">   6</span>  <span class="c006">let</span> now = localtime(time ()) <span class="c006">in</span>
<span class="c003">   7</span>  <span class="c006">let</span> delay = (hh - now.tm_hour) * 3600 + (mm - now.tm_min) * 60 <span class="c006">in</span>
<span class="c003">   8</span> <a id="prog:delay"></a>
<span class="c003">   9</span>  <span class="c006">if</span> delay &lt;= 0 <span class="c006">then begin</span>
<span class="c003">  10</span>    print_endline "Hey! That time has already passed!";
<span class="c003">  11</span>    exit 0
<span class="c003">  12</span>  <span class="c006">end</span>;
<span class="c003">  13</span>  <span class="c006">if</span> fork () &lt;&gt; 0 <span class="c006">then</span> exit 0;
<span class="c003">  14</span>  sleep delay;
<span class="c003">  15</span>  print_endline "\007\007\007Time to leave!";
<span class="c003">  16</span>  exit 0;;
<span class="c003">  17</span> 
<span class="c003">  18</span> handle_unix_error leave ();;</div><p>The program begins with a rudimentary parsing of the command line,
in order to extract the time provided. It then calculates the delay
in seconds (line <a href="#prog%3Adelay">8</a>). The <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtime"><span class="c001">time</span></a><a id="hevea_default71"></a>
call returns the current date, in seconds from the epoch (January 1st
1970, midnight). The function <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlocaltime"><span class="c001">localtime</span></a><a id="hevea_default72"></a> splits
this duration into years, months, days, hours, minutes and seconds.
It then creates a new process using <code>fork</code>. The parent process
(whose return value from <code>fork</code> is a non-zero integer) terminates
immediately. The shell which launched <code>leave</code> thereby returns
control to the user. The child process (whose return value from
<code>fork</code> is zero) continues executing. It does nothing during the
indicated time (the call to <code>sleep</code>), then displays its message and
terminates.</p>
<!--TOC section id=sec69 Awaiting the termination of a process-->
<h2 class="section" id="sec69">3.3  Awaiting the termination of a process</h2><!--SEC END --><p>The system call <code>wait</code> waits for one of the child processes created
by <code>fork</code> to terminate and returns information about how it did.
It provides a parent-child synchronization mechanism and a very
rudimentary form of communication from the child to the parent.
<a id="wait"></a>

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALwait">wait</a><a id="hevea_default73"></a> : unit -&gt; int * process_status
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALwaitpid">waitpid</a> : wait_flag list -&gt; int -&gt; int * process_status</div><p>The primitive system call is <a href="http://www.opengroup.org/onlinepubs/009696799/functions/waitpid.html"><span class="c001">waitpid</span></a><a id="hevea_default74"></a> and the function
<code>wait ()</code> is merely a shortcut for the expression <code>waitpid [] (-1)</code>.
The behavior of <code>waitpid [] p</code> depends on the value of <code>p</code>:
</p><ul class="itemize"><li class="li-itemize">
If <code>p</code> &gt; 0, it awaits the termination of the child with id
equal to <code>p</code>.
</li><li class="li-itemize">If <code>p</code> = 0, it awaits any child with the same group id as the
calling process. 
</li><li class="li-itemize">If <code>p</code> = −1, it awaits any process.
</li><li class="li-itemize">If <code>p</code> &lt;−1, it awaits a child process with group id equal
to <code>-p</code>.
</li></ul><p>
The first component of the result is the process id of the child
caught by <code>wait</code>. The second component of the result is a value of type 
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEprocess_status"><span class="c001">process_status</span></a>:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c013"><code>WEXITED r</code></td><td class="c012">The child process terminated normally via
<code>exit</code> or by reaching the end of the program; <code>r</code> is the return
code (the argument passed to <code>exit</code>).</td></tr>
<tr><td class="c013"><code>WSIGNALED s</code></td><td class="c012">The child process was killed by a signal
(ctrl-C, <code>kill</code>, etc., see chapter <a href="#sec78">4</a>
for more information about signals); <code>s</code> identifies the signal.</td></tr>
<tr><td class="c013"><code>WSTOPPED s</code></td><td class="c012">The child process was halted by the signal
<code>s</code>; this occurs only in very special cases where a process
(typically a debugger) is currently monitoring the execution of
another (by calling <code>ptrace</code>).
</td></tr>
</table>
</div><p>
If one of the child processes has already terminated by the time the
parent calls <code>wait</code>, the call returns immediately. Otherwise, the
parent process blocks until some child process terminates (a behavior
called “rendezvous”). To wait for <span class="c004">n</span> child processes, one must
call <code>wait</code> <span class="c004">n</span> times.</p><p>The command <code>waitpid</code> accepts two optional flags for its first
argument: the flag <code>WNOHANG</code> indicates not to wait if there is
a child that responds to the request but has not yet terminated.
In that case, the first result is <code>0</code> and the second undefined.
The flag <code>WUNTRACED</code> returns the child processes that have been
halted by the signal <code>sigstop</code>. The command raises the exception
<code>ECHILD</code> if no child processes match <code>p</code> (in particular, if
<code>p</code> is <code>-1</code> and the current process has no more children).</p><div class="example">
<!--TOC paragraph id=sec70 Example-->
<h5 class="paragraph" id="sec70">Example</h5><!--SEC END --><p>
<a id="ex/forksearch"></a>
The function <code>fork_search</code> below performs a linear search in an 
array with two processes. It relies on the function <code>simple_search</code>
to perform the linear search.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">open</span> Unix;;
<span class="c003">   2</span> <span class="c006">exception</span> Found;;
<span class="c003">   3</span> 
<span class="c003">   4</span> <span class="c006">let</span> simple_search cond v =
<span class="c003">   5</span>  <span class="c006">try</span>
<span class="c003">   6</span>    <span class="c006">for</span> i = 0 <span class="c006">to</span> Array.length v - 1 <span class="c006">do</span>
<span class="c003">   7</span>      <span class="c006">if</span> cond v.(i) <span class="c006">then</span> raise Found
<span class="c003">   8</span>    <span class="c006">done</span>;
<span class="c003">   9</span>    <span class="c006">false</span>
<span class="c003">  10</span>  <span class="c006">with</span> Found -&gt; <span class="c006">true</span>;;
<span class="c003">  11</span> 
<span class="c003">  12</span> <span class="c006">let</span> fork_search cond v =
<span class="c003">  13</span>  <span class="c006">let</span> n = Array.length v <span class="c006">in</span>
<span class="c003">  14</span>  <span class="c006">match</span> fork () <span class="c006">with</span>
<span class="c003">  15</span>  | 0 -&gt;
<span class="c003">  16</span>      <span class="c006">let</span> found = simple_search cond (Array.sub v (n/2) (n-n/2)) <span class="c006">in</span> <a id="prog:found"></a>
<span class="c003">  17</span>      exit (<span class="c006">if</span> found <span class="c006">then</span> 0 <span class="c006">else</span> 1) <a id="prog:searchexit"></a>
<span class="c003">  18</span>  | _ -&gt;
<span class="c003">  19</span>      <span class="c006">let</span> found = simple_search cond (Array.sub v 0 (n/2)) <span class="c006">in</span>
<span class="c003">  20</span>      <span class="c006">match</span> wait () <span class="c006">with</span>
<span class="c003">  21</span>      | (pid, WEXITED retcode) -&gt; found || (retcode = 0) <a id="prog:wexit"></a>
<span class="c003">  22</span>      | (pid, _)               -&gt; failwith "fork_search";;<a id="prog:wwexit"></a></div><p>After the <code>fork</code>, the child process traverses the upper half of
the table, and exits with the return code 1 if it found an element
satisfying the predicate <code>cond</code>, or 0 otherwise
(lines <a href="#prog%3Afound">16</a> and <a href="#prog%3Asearchexit">17</a>). The parent process
traverses the lower half of the table, then calls <code>wait</code> to
sync with the child process (lines <a href="#prog%3Awexit">21</a>
and <a href="#prog%3Awwexit">22</a>). If the child terminated normally, it combines
its return code with the boolean result of the search in the lower
half of the table. Otherwise, something horrible happened, and the
function <code>fork_search</code> fails.
</p><div class="fancybreak">* * *</div></div><p>In addition to the synchronization between processes, the <code>wait</code>
call also ensures recovery of all resources used by the child
processes. When a process terminates, it moves into a “zombie”
state, where most, but not all, of its resources (memory, etc.) have
been freed. It continues to occupy a slot in the process table to
transmit its return value to the parent via the <code>wait</code> call.
Once the parent calls <code>wait</code>, the zombie process is removed from
the process table. Since this table is of fixed size, it is important
to call <code>wait</code> on each forked process to avoid leaks.</p><p><a id="double-fork"></a>
If the parent process terminates before the child, the child is
given the process number 1 (usually <code>init</code>) as parent. This
process contains an infinite loop of <code>wait</code> calls, and will
therefore make the child process disappear once it finishes. This
leads to the useful “double fork” technique if you cannot
easily call <code>wait</code> on each process you create (because you cannot
afford to block on termination of the child process,
for example).
</p><div class="mylisting"><span class="c006">match</span> fork () <span class="c006">with</span>
| 0 -&gt; <span class="c006">if</span> fork () &lt;&gt; 0 <span class="c006">then</span> exit 0;
      <em>(* do whatever the child should do *)</em>
| _ -&gt; wait ();
      <em>(* do whatever the parent should do *)</em></div><p>The child terminates via <code>exit</code> just after the second <code>fork</code>.
The grandson becomes an orphan, and is adopted by <code>init</code>. In this
way, it leaves no zombie processes. The parent immediately calls
<code>wait</code> to reap the child. This <code>wait</code> will not block for long
since the child terminates very quickly.</p><p><br>
</p>
<!--TOC section id=sec71 Launching a program-->
<h2 class="section" id="sec71">3.4  Launching a program</h2><!--SEC END --><p>The system calls <a href="http://www.opengroup.org/onlinepubs/009696799/functions/execve.html"><span class="c001">execve</span></a><a id="hevea_default75"></a>, <a href="http://www.opengroup.org/onlinepubs/009696799/functions/execv.html"><span class="c001">execv</span></a><a id="hevea_default76"></a>, and
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/execvp.html"><span class="c001">execvp</span></a><a id="hevea_default77"></a> launch a program within the current process.
Except in case of error, these calls never return: they halt the progress
of the current program and switch to the new program.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecve">execve</a> : string -&gt; string array -&gt; string array -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecv">execv</a>  : string -&gt; string array -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecvp">execvp</a> : string -&gt; string array -&gt; unit</div><p>The first argument is the name of the file containing the program to
execute. In the case of <code>execvp</code>, this name is looked for in the
directories of the search path (specified in the environment variable
<code>PATH</code>).</p><p>The second argument is the array of command line arguments with which
to execute the program; this array will be the <code>Sys.argv</code> array 
of the executed program.</p><p>In the case of <code>execve</code>, the third argument is the environment
given to the executed program; <code>execv</code> and <code>execvp</code>
give the current environment unchanged.</p><p>The calls <code>execve</code>, <code>execv</code>, and <code>execvp</code> never return a
result: either everything works without errors and the process starts
the requested program or an error occurs (file not found, etc.), and
the call raises the exception <code>Unix_error</code> in the calling program.</p><div class="example">
<!--TOC paragraph id=sec72 Example-->
<h5 class="paragraph" id="sec72">Example</h5><!--SEC END --><p>
The following three forms are equivalent:
</p><div class="mylisting">execve "/bin/ls" [|"ls"; "-l"; "/tmp"|] (environment ())
execv  "/bin/ls" [|"ls"; "-l"; "/tmp"|]
execvp "ls"      [|"ls"; "-l"; "/tmp"|]</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec73 Example-->
<h5 class="paragraph" id="sec73">Example</h5><!--SEC END --><p>
Here is a “wrapper” around the command <code>grep</code> which
adds the option <code>-i</code> (to ignore case) to the list of arguments:
</p><div class="mylisting"><span class="c006">open</span> Sys;;
<span class="c006">open</span> Unix;;
<span class="c006">let</span> grep () =
 execvp "grep"
   (Array.concat
      [ [|"grep"; "-i"|];
        (Array.sub Sys.argv 1 (Array.length Sys.argv - 1)) ])
;;
handle_unix_error grep ();;</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec74 Example-->
<h5 class="paragraph" id="sec74">Example</h5><!--SEC END --><p>
Here’s a “wrapper” around the command <code>emacs</code> which
changes the terminal type:
</p><div class="mylisting"><span class="c006">open</span> Sys;;
<span class="c006">open</span> Unix;;
<span class="c006">let</span> emacs () =
 execve "/usr/bin/emacs" Sys.argv
   (Array.concat [ [|"TERM=hacked-xterm"|]; (environment ()) ]);;
handle_unix_error emacs ();;</div><div class="fancybreak">* * *</div></div><p>The process which calls <code>exec</code> is the same one that executes the
new program. As a result, the new program inherits some features of
the execution environment of the program which called <code>exec</code>:
</p><ul class="itemize"><li class="li-itemize">
the same process id and parent process
</li><li class="li-itemize">same standard input, standard output and standard error
</li><li class="li-itemize">same ignored signals (see chapter <a href="#sec78">4</a>)
</li></ul>
<!--TOC section id=sec75 Complete example: a mini-shell-->
<h2 class="section" id="sec75">3.5  Complete example: a mini-shell</h2><!--SEC END --><p>The following program is a simplified command interpreter: it reads
lines from standard input, breaks them into words, launches the
corresponding command, and repeats until the end of file on the
standard input. We begin with the function which splits a string into
a list of words. Please, no comments on this horror.</p><div class="mylisting"><span class="c006">open</span> Unix;;
<span class="c006">open</span> Printf;;

<span class="c006">let</span> split_words s =
 <span class="c006">let rec</span> skip_blanks i =
   <span class="c006">if</span> i &lt; String.length s &amp; s.[i] = ' '
   <span class="c006">then</span> skip_blanks (i+1)
   <span class="c006">else</span> i <span class="c006">in
 let rec</span> split start i =
   <span class="c006">if</span> i &gt;= String.length s <span class="c006">then</span>
     [String.sub s start (i-start)]
   <span class="c006">else if</span> s.[i] = ' ' <span class="c006">then
     let</span> j = skip_blanks i <span class="c006">in</span>
     String.sub s start (i-start) :: split j j
   <span class="c006">else</span>
     split start (i+1) <span class="c006">in</span>
 Array.of_list (split 0 0);;</div><p>We now move on to the main loop of the interpreter.
</p><div class="mylisting"><span class="c006">let</span> exec_command cmd =
 <span class="c006">try</span> execvp cmd.(0) cmd
 <span class="c006">with</span> Unix_error(err, _, _) -&gt;
   printf "Cannot execute %s : %s\n%!"
     cmd.(0) (error_message err);
   exit 255

<span class="c006">let</span> print_status program status =
 <span class="c006">match</span> status <span class="c006">with</span>
 | WEXITED 255 -&gt; ()
 | WEXITED status -&gt;
     printf "%s exited with code %d\n%!" program status;
 | WSIGNALED signal -&gt;
     printf "%s killed by signal %d\n%!" program signal;
 | WSTOPPED signal -&gt;
     printf "%s stopped (???)\n%!" program;;</div><p>The function <code>exec_command</code> executes a command and handles errors.
The return code 255 indicates that the command could not be executed.
(This is not a standard convention; we just hope that few commands
terminate with a return code of 255.) The function
<code>print_status</code> decodes and prints the status information returned
by a process, ignoring the return code of 255.
</p><div class="mylisting"><span class="c006">let</span> minishell () =
 <span class="c006">try
   while true do
     let</span> cmd = input_line Pervasives.stdin <span class="c006">in
     let</span> words = split_words cmd <span class="c006">in
     match</span> fork () <span class="c006">with</span>
     | 0 -&gt; exec_command words
     | pid_son -&gt;
         <span class="c006">let</span> pid, status = wait () <span class="c006">in</span>
         print_status "Program" status
   <span class="c006">done
 with</span> End_of_file -&gt; ()
;;

handle_unix_error minishell ();;</div><p>Each time through the loop, we read a line from <code>stdin</code> with the
function <code>input_line</code>. This function raises the <code>End_of_file</code>
exception when the end of file is reached, causing the loop to
exit. We split the line into words, and then call <code>fork</code>. The
child process uses <code>exec_command</code> to execute the command. The
parent process calls <code>wait</code> to wait for the command to finish and
prints the status information returned by <code>wait</code>.</p><div class="exercise">
<!--TOC paragraph id=sec76 Exercise 10-->
<h5 class="paragraph" id="sec76">Exercise 10</h5><!--SEC END --><p><a id="ex10"></a>
<a id="shell"></a>
Add the ability to execute commands in the background if they are
followed by <code>&amp;</code>.
<a href="#exans10">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 10</arg>-->
<!--NAME exercise10.html-->
<div class="answer">
<!--TOC paragraph id=sec77 Answer of exercise 10-->
<h5 class="paragraph" id="sec77">Answer of <a href="#ex10">exercise 10</a></h5><!--SEC END --><p>
<a id="exans10"></a>
If the command line ends with <code>&amp;</code>, we do not call <code>wait</code> in
the parent process and immediately continue with the next iteration
of the loop. But there is one difficulty: the parent may now have
multiple children executing at the same time (the commands in the
background which haven’t terminated yet, plus the last synchronous
command), and <code>wait</code> could synchronize with any of these children.
Thus, for synchronous command, <code>wait</code> must be repeated until the
recovered child is the one actually executing that command.

</p><div class="mylisting">   <span class="c006">while true do
     let</span> cmd = input_line Pervasives.stdin <span class="c006">in
     let</span> words, ampersand = parse_command_line cmd <span class="c006">in
     match</span> fork () <span class="c006">with</span>
     | 0 -&gt; exec_command words
     | pid_son -&gt;
         <span class="c006">if</span> ampersand <span class="c006">then</span> ()
         <span class="c006">else
           let rec</span> wait_for_son () =
             <span class="c006">let</span> pid, status = wait () <span class="c006">in
             if</span> pid = pid_son <span class="c006">then</span>
               print_status "Program" status
             <span class="c006">else
               let</span> p = "Background program " ^ (string_of_int pid) <span class="c006">in</span>
               print_status p status;
               wait_for_son () <span class="c006">in</span>
           wait_for_son ()
   <span class="c006">done</span></div><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC chapter id=sec78 Signals-->
<h1 class="chapter" id="sec78"> 4  Signals</h1><!--SEC END --><!--NAME signals.html-->
<p>Signals, or software interrupts, are external, asynchronous events
used to alter the course of a program. These may occur at any
time during the execution of a program. Because of this,
they differ from other methods of inter-process communication, where
two processes must be explicitly directed to wait for external messages;
for example, by calling <span class="c001">read</span><a id="hevea_default78"></a> on a pipe (see 
chapter <a href="#sec99">5</a>).</p><p>The amount of information transmitted via a signal is minimal, just
the type of signal, and although they were not originally
intended for communication between processes, they do make it
possible to transmit atomic information about the state of an
external entity (e.g. the state of the system or another process). </p>
<!--TOC section id=sec79 Default behavior-->
<h2 class="section" id="sec79">4.1  Default behavior</h2><!--SEC END --><p>When a process receives a signal, there are four possible outcomes:
</p><ul class="itemize"><li class="li-itemize">
The signal terminates the process. Additionally, the system may write
an image of the process state in a core file (a <em>core dump</em>, which
may be later examined with a debugger).
</li><li class="li-itemize">The signal suspends process execution, but retains it in memory. The
parent process (usually the shell) is not terminated, and so may
choose to continue the process or restart it in the background by
sending the process additional signals.
</li><li class="li-itemize">Nothing occurs: the signal is completely ignored.
</li><li class="li-itemize">The signal triggers the execution of an associated function in the
receiving process. Normal execution of the process resumes after the
function returns.
</li></ul><p>There are several types of signals, each associated with a particular event. 
Table <a href="#tab%2Fsignals">4</a> lists some of them with their default behaviors.
</p><div class="table">
<table class="c000 cellpading0"><tr><td class="c010">Name</td><td class="c010">Event</td><td class="c010">Default Behavior </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c010"><code>sighup</code></td><td class="c010">Hang-up (end of connection)</td><td class="c010">Termination </td></tr>
<tr><td class="c010"><code>sigint</code></td><td class="c010">Interruption (<code>ctrl-C</code>)</td><td class="c010">Termination </td></tr>
<tr><td class="c010"><code>sigquit</code></td><td class="c010">Strong interruption (<code>ctrl-\</code>)</td><td class="c010">Term. &amp; core dump </td></tr>
<tr><td class="c010"><code>sigfpe</code></td><td class="c010">Arithmetic error (division by zero)</td><td class="c010">Term. &amp; core dump </td></tr>
<tr><td class="c010"><code>sigkill</code></td><td class="c010">Very strong interruption (cannot be ignored)</td><td class="c010">Termination </td></tr>
<tr><td class="c010"><code>sigsegv</code></td><td class="c010">Memory protection violation</td><td class="c010">Term. &amp; core dump </td></tr>
<tr><td class="c010"><code>sigpipe</code></td><td class="c010">Writing to a pipe without readers</td><td class="c010">Termination </td></tr>
<tr><td class="c010"><code>sigalrm</code></td><td class="c010">Timer interrupt</td><td class="c010">Ignored </td></tr>
<tr><td class="c010"><code>sigtstp</code></td><td class="c010">Temporary halt (<code>ctrl-Z</code>)</td><td class="c010">Suspension </td></tr>
<tr><td class="c010"><code>sigcont</code></td><td class="c010">Resuming a stopped process</td><td class="c010">Ignored </td></tr>
<tr><td class="c010"><code>sigchld</code></td><td class="c010">A child process died or was stopped</td><td class="c010">Ignored <br>
</td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>

<a id="tab/signals"></a>
<div class="caption">Table 4 — Some signals and their default behaviors</div></div><p>The signals received by a process come from several possible sources:
</p><ul class="itemize"><li class="li-itemize">The user may send signals via the keyboard. By typing <code>ctrl-C</code>,
the console operator sends the <code>sigint</code> signal to the processes
controlled by her terminal (that were not already put in the background).
In the same way, the <code>sigquit</code> signal is sent by typing <code>ctrl-\</code><sup><a id="text6" href="#note6">1</a></sup>. 
When the terminal is closed (either through voluntary disconnection or owing to a disconnected network link), the <code>sighup</code> signal is sent.</li><li class="li-itemize">The user may issue the shell command <code>kill</code>. This makes it possible 
to send a specific signal to a specific process. For example, 
<code>kill -KILL 194</code> sends the <code>sigkill</code> signal to the process with id 194, which 
causes the process to be killed.</li><li class="li-itemize">Another program may invoke the system call 
<code>kill</code> (the preceding example being a specific case).</li><li class="li-itemize">The system, for misbehaving processes. For example, a process 
attempting to divide by zero will receive a <code>sigfpe</code> signal.</li><li class="li-itemize">The system, to notify a process that its execution environment has 
been changed. For example, when a child process terminates, its parent 
will receive a <code>sigchld</code> signal.</li></ul>
<!--TOC section id=sec80 Using signals-->
<h2 class="section" id="sec80">4.2  Using signals</h2><!--SEC END --><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/kill.html"><span class="c001">kill</span></a><a id="hevea_default79"></a> makes it possible to send a
signal to a process.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALkill">kill</a> : int -&gt; int -&gt; unit</div><p>The first parameter is the process id of the destination process and
the second the signal number to send. An error occurs if we attempt to
send a signal to a process not owned by the user. A process may send
signals to itself. When the <code>kill</code> system call returns, it is
guaranteed that the signal was delivered to the destination
process. If a process receives the same signal in rapid succession it
will execute the code associated with the signal only once. Therefore
a program cannot count the number of times it receives a signal,
rather only the number of times it responds to it.</p><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/alarm.html"><span class="c001">alarm</span></a><a id="hevea_default80"></a> makes it possible to schedule
interruptions based on the system clock.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALalarm">alarm</a> : int -&gt; int</div><p>The call <code>alarm s</code> returns immediately but causes the <code>sigalrm</code> 
signal to be sent to the calling process at least <code>s</code> seconds later 
(note that there is no guarantee on the maximum wait time). The call returns 
the number of seconds remaining to an alarm scheduled by a previous call.
If <code>s</code> is <code>0</code>, the effect is simply to cancel an earlier alarm.</p>
<!--TOC section id=sec81 Changing the effect of a signal-->
<h2 class="section" id="sec81">4.3  Changing the effect of a signal</h2><!--SEC END --><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/signal.html"><span class="c001">signal</span></a><a id="hevea_default81"></a> makes it possible to modify the behavior
of a process when it receives a signal of a certain type.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html#VALsignal">signal</a> : int -&gt; signal_behavior -&gt; signal_behavior</div><p>The first argument is the signal number and the second argument, a
value of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html#TYPEsignal_behavior"><span class="c001">signal_behavior</span></a>, indicates the desired
behavior for the signal. With:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>Signal_ignore</code></td><td class="c010">The signal is ignored. </td></tr>
<tr><td class="c010"><code>Signal_default</code></td><td class="c010">The default behavior occurs.</td></tr>
<tr><td class="c010"><code>Signal_handle f</code></td><td class="c010">The function <code>f</code> is
invoked each time the signal is received. 
</td></tr>
</table>
</div><p>Forking a process with the system call <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALfork"><span class="c001">fork</span></a><a id="hevea_default82"></a>
preserves signal behavior: the initial definitions for the child are
those of the parent at the time when <code>fork</code> was executed. The
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecve"><span class="c001">execve</span></a><a id="hevea_default83"></a> system call sets all the behaviors to
<code>Signal_default</code> except that signals ignored before are still
ignored afterward.</p><div class="example">
<!--TOC paragraph id=sec82 Example-->
<h5 class="paragraph" id="sec82">Example</h5><!--SEC END --><p>
Occasionally we want to log-off or end a session while allowing 
background tasks (large calculations, “spyware” programs, etc.) 
to continue to run. If this is desired, processes which normally
exit on receiving <code>sighup</code> (sent at the time the user disconnects)
should be prevented from doing so. The Unix command <code>nohup</code> does
exactly this:
</p><div class="mylisting">nohup cmd arg1 ... argn</div><p>executes the command <code>cmd arg1 ... argn</code> in a way unaffected by
the signal <code>sighup</code> (certain shells execute <code>nohup</code>
automatically for all processes launched as background tasks). Here’s how
to implement this in three lines:
</p><div class="mylisting"><span class="c006">open</span> Sys;;
signal sighup Signal_ignore;;
Unix.execvp argv.(1) (Array.sub argv 1 (Array.length argv - 1));;</div><p>The system call <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALexecvp"><span class="c001">execvp</span></a><a id="hevea_default84"></a> preserves the fact that
<code>sighup</code> is ignored.
</p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec83 Example-->
<h5 class="paragraph" id="sec83">Example</h5><!--SEC END --><p> 
Carefully exiting when a program is misbehaving. For example,
a program like <code>tar</code> can try to save important information
in a file or destroy the corrupted file before terminating. For this 
it is possible to include the following lines at the beginning of the program:
</p><div class="mylisting">signal sigquit (Signal_handle quit);
signal sigsegv (Signal_handle quit);
signal sigfpe  (Signal_handle quit);</div><p>where the function <code>quit</code> is of the form:
</p><div class="mylisting"><span class="c006">let</span> quit _ =
  <em>(* Try to save important information in a file *)</em>;
  exit 100;;</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec84 Example-->
<h5 class="paragraph" id="sec84">Example</h5><!--SEC END --><p> 
Capturing user-initiated interruptions. Some interactive programs
need to return to a main control loop when a user
presses <code>ctrl-C</code>. For this we just need to raise an exception when the
<code>sigint</code> signal is received.
</p><div class="mylisting"><span class="c006">exception</span> Break;;
<span class="c006">let</span> break _ = raise Break;;
...
<span class="c006">let</span> main_loop () =
  signal sigint (Signal_handle break);
  <span class="c006">while true do
    try</span> <em>(* Read and evaluate user commands  *)</em>
    <span class="c006">with</span> Break -&gt; <em>(* Display "stopped" *)</em>
  <span class="c006">done</span>;;</div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec85 Example-->
<h5 class="paragraph" id="sec85">Example</h5><!--SEC END --><p> 
<a id="ex/beep"></a>
To carry out periodic tasks (animations, etc.) interleaved with
the execution of the main program. For example, here is how
to create “beep” sounds every 30 seconds, regardless of
the activity of the main program (calculations or input/output).</p><div class="mylisting"><span class="c006">let</span> beep _ =
  output_char stdout '\007'; flush stdout;
  ignore (alarm 30);;
...
signal sigalrm (Signal_handle beep); ignore (alarm 30);;</div><div class="fancybreak">* * *</div></div><!--TOC subsection id=sec86 Checkpoints-->
<h3 class="subsection" id="sec86">Checkpoints</h3><!--SEC END --><p>Signals are useful for asynchronous communication — indeed, it is
their raison d’être — but this asynchronous nature also makes them
one of the major difficulties of system programming.</p><p>The signal handling function is executed asynchronously and thus
pseudo-concurrently with the main program of the process. As signal
handling functions cannot return a value, they usually modify global
variables. This can result in race conditions between the signal
handler and the main program if they try to modify the same variable.
As explained in the next section one solution is to temporarily block
signals when this variable is accessed by the main program.</p><p>In fact, OCaml does not treat signals in a strictly asynchronous
fashion. On receiving a signal, OCaml records the receipt of the
signal but the signal handling function will only be executed at
certain <em>checkpoints</em>. These are frequent enough to provide the
illusion of asynchronous execution. The checkpoints typically occur
during allocations, loop controls, or interactions with the system
(particularly system calls). OCaml guarantees that a program that
does not loop, does not allocate, and does not interact with the
system will not have its execution interleaved with that of a
signal handler. In particular, storing an unallocated value (integer,
boolean, etc. — but not a float!) in a reference cell cannot
result in the race condition described above.</p>
<!--TOC section id=sec87 How to mask signals-->
<h2 class="section" id="sec87">4.4  How to mask signals</h2><!--SEC END --><p>Signals may be blocked. Blocked signals are not ignored, but put on 
standby, generally to be delivered later. The 
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/sigprocmask.html"><span class="c001">sigprocmask</span></a><a id="hevea_default85"></a> system call makes it possible to change the mask
for incoming signals:

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsigprocmask">sigprocmask</a> : sigprocmask_command -&gt; int list -&gt; int list</div><p><code>sigprocmask cmd sigs</code> changes the list of blocked signals and
returns the list of signals that were blocked before the execution of
the function. This makes it possible to later reset the mask to its
previous state. The argument <code>sigs</code> is a list of signals and <code>cmd</code>
a value of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsigprocmask_command"><span class="c001">sigprocmask_command</span></a> which determines the
effect of the call:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>SIG_BLOCK</code></td><td class="c010">The signals <code>sigs</code> are added
to the list of blocked signals. </td></tr>
<tr><td class="c010"><code>SIG_UNBLOCK</code></td><td class="c010">The signals <code>sigs</code> are removed
from the set of blocked signals. </td></tr>
<tr><td class="c010"><code>SIG_SETMASK</code></td><td class="c010">The signals <code>sigs</code> are exactly the 
signals to be blocked.
</td></tr>
</table>
</div><p>
A typical usage of <code>sigprocmask</code> is to mask certain
signals temporarily.
</p><div class="mylisting"><span class="c006">let</span> old_mask = sigprocmask cmd sigs <span class="c006">in</span>
<em>(* do something *)</em>
<span class="c006">let</span> _ = sigprocmask SIG_SETMASK old_mask</div><p>Often, one has to guard against possible errors by using
the following pattern:

</p><div class="mylisting"><span class="c006">let</span> old_mask = sigprocmask cmd sigs <span class="c006">in
let</span> treat () = (<em>(* do something *)</em>) <span class="c006">in
let</span> reset () = ignore (sigprocmask SIG_SETMASK old_mask) <span class="c006">in</span>
Misc.try_finalize treat () reset ()</div>
<!--TOC section id=sec88 Signals and system calls-->
<h2 class="section" id="sec88">4.5  Signals and system calls</h2><!--SEC END --><p>Certain system calls can be interrupted by unignored signals. These
system calls are known as <em>slow</em> calls, which can take an
arbitrary amount of time (for example terminal <span class="c005">i/o</span>,
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALselect"><span class="c001">select</span></a><a id="hevea_default86"></a>, <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsystem"><span class="c001">system</span></a><a id="hevea_default87"></a>, etc.). If
an interruption occurs, the system call is not completed and raises
the exception <code>EINTR</code>. However file <span class="c005">i/o</span> is not interruptible:
although these operations can suspend the running process to execute
another process for disk <span class="c005">i/o</span>, when this occurs the interruption will
always be brief if the disk functions correctly. In particular, the
throughput of data depends only on the system, and not another user’s
process.</p><p>Ignored signals are never delivered and a masked signal is not
delivered until unmasked. But in all other cases we must protect our
system calls against unwanted interruptions. A typical example is a
parent waiting for the termination of a child. In this case, the
parent executes <span class="c001">waitpid</span><a id="hevea_default88"></a> <code>[] pid</code> where <code>pid</code> is the
process id of the child. This is a blocking system call, it is thus
<em>slow</em> and could be interrupted by the arrival of a signal,
especially since the <code>sigchld</code> signal is sent to the parent when a
child process dies.</p><p>The module <code>Misc</code> define the function <code>restart_on_EINTR</code> which
makes it possible to repeat a system call when it is interrupted by a
signal, i.e. when the <code>EINTR</code> exception is raised.

</p><div class="mylisting"><span class="c006">let rec</span> restart_on_EINTR f x =
  <span class="c006">try</span> f x <span class="c006">with</span> Unix_error (EINTR, _, _) -&gt; restart_on_EINTR f x</div><p>To wait on a child correctly, call
<code>restart_on_EINTR (waitpid flags) pid</code>.</p><div class="example">
<!--TOC paragraph id=sec89 Example-->
<h5 class="paragraph" id="sec89">Example</h5><!--SEC END --><p><a id="ex/childs"></a>
Children can also be recovered asynchronously in the signal handler of
<code>sigchld</code>, especially when their return value does not matter to
the parent. But when the process receives the <code>sigchld</code> signal, it
is not possible to know the exact number of terminated processes, since if
the signal is received several times within a short period of time the
handler is invoked only once. This leads to the library function
<code>Misc.free_children</code> function to handle the <code>sigchld</code> signal.

</p><div class="mylisting"><span class="c006">let</span> free_children _ =
  <span class="c006">try while</span> fst (waitpid [ WNOHANG ] (-1)) &gt; 0 <span class="c006">do</span> () <span class="c006">done
  with</span> Unix_error (ECHILD, _, _) -&gt; ()</div><p><code>free_children</code> executes <code>waitpid</code> in
non-blocking mode (option <code>WNOHANG</code>) to recover any dead children
and repeats until either there are only live children (zero is
returned instead of a child id) or there are no children (<code>ECHILD</code>
exception).</p><p>Note that it is not important to guard against the <code>EINTR</code>
exception because <code>waitpid</code> is non-blocking when called with the
<code>WNOHANG</code> option.
</p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec90 Example-->
<h5 class="paragraph" id="sec90">Example</h5><!--SEC END --><p>
The function <code>system</code> in the <code>Unix</code> module is simply defined as: 
</p><div class="mylisting"><span class="c006">let</span> system cmd = <span class="c006">match</span> fork () <span class="c006">with</span>
  | 0 -&gt; <span class="c006">begin try</span>
          execv "/bin/sh" [| "/bin/sh"; "-c"; cmd |]
         <span class="c006">with</span> _ -&gt; exit 127
         <span class="c006">end</span>
  | id -&gt; snd (waitpid [] id);;</div><p>The specification of the <code>system</code> function in the C standard
library states that the parent ignores <code>sigint</code> and
<code>sigquit</code> signals and masks the <code>sigchld</code> signal during the
command’s execution. This makes it possible to stop or kill the child
process without affecting the main program’s execution.</p><p>We prefer to define the function <code>system</code> as a specialization of the
more general function <code>exec_as_system</code> which does not necessarily 
go through the shell.


</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let</span> exec_as_system exec args =
<span class="c003">   2</span>   <span class="c006">let</span> old_mask = sigprocmask SIG_BLOCK [ sigchld ] <span class="c006">in</span>
<span class="c003">   3</span>   <span class="c006">let</span> old_int = signal sigint Signal_ignore <span class="c006">in</span>
<span class="c003">   4</span>   <span class="c006">let</span> old_quit = signal sigquit Signal_ignore <span class="c006">in</span>
<span class="c003">   5</span>   <span class="c006">let</span> reset () =
<span class="c003">   6</span>     ignore (signal sigint old_int);
<span class="c003">   7</span>     ignore (signal sigquit old_quit);
<span class="c003">   8</span>     ignore (sigprocmask SIG_SETMASK old_mask) <span class="c006">in</span>
<span class="c003">   9</span>   <span class="c006">let</span> system_call () = <span class="c006">match</span> fork () <span class="c006">with</span>
<span class="c003">  10</span>     | 0 -&gt;
<span class="c003">  11</span>         reset (); <a id="prog:sreset"></a>
<span class="c003">  12</span>         (<span class="c006">try</span> exec args <span class="c006">with</span> _ -&gt; exit 127)
<span class="c003">  13</span>     | k -&gt;
<span class="c003">  14</span>         snd (restart_on_EINTR (waitpid []) k) <span class="c006">in</span>
<span class="c003">  15</span>   try_finalize system_call () reset ();; <a id="prog:stry"></a>
<span class="c003">  16</span> 
<span class="c003">  17</span> <span class="c006">let</span> system cmd =
<span class="c003">  18</span>   exec_as_system (execv "/bin/sh") [| "/bin/sh"; "-c"; cmd |];;</div><p>Note that the signal changes must be made before the call
to <code>fork</code> is executed because the parent could receive signals
(e.g. <code>sigchld</code> if the child were to finish immediately) before it
proceeds. These changes are reset for the child on line <a href="#prog%3Asreset">11</a>
before executing the command. Indeed, all ignored signals
are preserved by <code>fork</code> and <code>exec</code> and their behavior is
preserved by <code>fork</code>. The <code>exec</code> system call uses the
default behavior of signals except if the calling process ignores a
signal in which case it also does. </p><p>Finally, the parent must also reset the changes immediately after the
call, even if an error occurs. This is why
<code>try_finalize</code> is used on line <a href="#prog%3Astry">15</a>.
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id=sec91 The passage of time-->
<h2 class="section" id="sec91">4.6  The passage of time</h2><!--SEC END --><!--TOC subsection id=sec92 Legacy approach to time-->
<h3 class="subsection" id="sec92">Legacy approach to time</h3><!--SEC END --><p>Since the earliest versions of Unix, time has been counted in seconds.
For compatibility reasons, therefore, one can always measure time in seconds.
The current time is defined as the number of seconds since January 1st, 1970
at <code>00:00:00</code> <span class="c005">gmt</span>. It is returned by the function:</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALtime">time</a><a id="hevea_default89"></a> : unit -&gt; float</div><p>The <a href="http://www.opengroup.org/onlinepubs/009696799/functions/sleep.html"><span class="c001">sleep</span></a><a id="hevea_default90"></a> system call can pause the execution of a program
for the number of seconds specified in its argument:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsleep">sleep</a> : int -&gt; unit</div><p>However, this function is not primitive. It is programmable with 
more elementary system calls using the function <code>alarm</code> (see 
above) and <code>sigsuspend</code>: </p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsigsuspend">sigsuspend</a> : int list -&gt; unit</div><p>The <code>sigsuspend l</code> system call temporarily suspends the signals in the 
list <code>l</code> and then halts the execution of the program until the reception 
of a signal which is not ignored or suspended (on return, the 
signal mask is reset to its old value).</p><div class="example">
<!--TOC paragraph id=sec93 Example-->
<h5 class="paragraph" id="sec93">Example</h5><!--SEC END --><p> Now we may program the <code>sleep</code> function:

</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let</span> sleep s =
<span class="c003">   2</span>   <span class="c006">let</span> old_alarm = signal sigalrm (Signal_handle (<span class="c006">fun</span> s -&gt; ())) <span class="c006">in</span> <a id="prog:sold"></a>
<span class="c003">   3</span>   <span class="c006">let</span> old_mask = sigprocmask SIG_UNBLOCK [ sigalrm ] <span class="c006">in</span>
<span class="c003">   4</span>   <span class="c006">let</span> _ = alarm s <span class="c006">in</span>
<span class="c003">   5</span>   <span class="c006">let</span> new_mask = List.filter (<span class="c006">fun</span> x -&gt; x &lt;&gt; sigalrm) old_mask <span class="c006">in</span>
<span class="c003">   6</span>   sigsuspend new_mask;
<span class="c003">   7</span>   <span class="c006">let</span> _ = alarm 0 <span class="c006">in</span>
<span class="c003">   8</span>   ignore (signal sigalrm old_alarm);
<span class="c003">   9</span>   ignore (sigprocmask SIG_SETMASK old_mask)<a id="prog:ssigproc"></a>;;</div><p>Initially, the behavior of the <code>sigalrm</code> signal does nothing. Note
that “doing nothing” is the same as ignoring the signal. To
ensure that the process will be awakened by the reception
of the signal, the <code>sigalrm</code> signal is put in an unblocked
state. Then the process is put on standby by suspending all other
signals which were not already suspended (<code>old_mask</code>). After the alarm
is signaled, the preceding modifications are erased. (Note that
line <a href="#prog%3Assigproc">9</a> could be placed immediately after
line <a href="#prog%3Asold">2</a> because the call to <code>sigsuspend</code> preserves
the signal mask.)</p><div class="fancybreak">* * *</div></div><!--TOC subsection id=sec94 Modern times-->
<h3 class="subsection" id="sec94">Modern times</h3><!--SEC END --><p>In more modern versions of Unix, time can also be measured in microseconds.
In OCaml, time measured in microseconds is represented by a float. 
The <a href="http://www.opengroup.org/onlinepubs/009696799/functions/gettimeofday.html"><span class="c001">gettimeofday</span></a><a id="hevea_default91"></a> function is the equivalent of the <code>time</code> 
function for modern systems.</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgettimeofday">gettimeofday</a> : unit -&gt; float</div><!--TOC subsection id=sec95 Timers-->
<h3 class="subsection" id="sec95">Timers</h3><!--SEC END --><p>
In present-day Unix each process is equipped with three timers, each
measuring time from a different perspective. The timers are
identified by a value of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEinterval_timer"><span class="c001">interval_timer</span></a> :
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>ITIMER_REAL</code></td><td class="c010">Real time (<code>sigalrm</code>). </td></tr>
<tr><td class="c010"><code>ITIMER_VIRTUAL</code></td><td class="c010">User time (<code>sigvtalrm</code>). </td></tr>
<tr><td class="c010"><code>ITIMER_PROF</code></td><td class="c010">User time and system time (<code>sigprof</code>).
</td></tr>
</table>
</div><p>
The state of a timer is described by the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEinterval_timer_status"><span class="c001">interval_timer_status</span></a>
type which is a record with two fields (each a <code>float</code>)
representing time:
</p><ul class="itemize"><li class="li-itemize">
The field <code>it_interval</code> is the period of the timer.
</li><li class="li-itemize">The field <code>it_value</code> is the current value of the timer; 
when it turns <code>0</code> the signal <code>sigvtalrm</code> is sent and 
the timer is reset to the value in <code>it_interval</code>.
</li></ul><p>
A timer is therefore inactive when its two fields are <code>0</code>. 
The timers can be queried or modified with the following functions:

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetitimer">getitimer</a><a id="hevea_default92"></a> : interval_timer -&gt; interval_timer_status
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetitimer">setitimer</a><a id="hevea_default93"></a> :
    interval_timer -&gt; interval_timer_status -&gt; interval_timer_status</div><p>The value returned by <code>setitimer</code> is the old value of 
the timer at the time of the modification.</p><div class="exercise">
<!--TOC paragraph id=sec96 Exercise 11-->
<h5 class="paragraph" id="sec96">Exercise 11</h5><!--SEC END --><p><a id="ex11"></a>
To manage several timers, write a module with the following interface:
</p><div class="mylisting"><span class="c006">module type</span> Timer = <span class="c006">sig
  open</span> Unix
  <span class="c006">type</span> t
  <span class="c006">val</span> new_timer : interval_timer -&gt; (unit -&gt; unit) -&gt; t
  <span class="c006">val</span> get_timer : t -&gt; interval_timer_status
  <span class="c006">val</span> set_timer : t -&gt; interval_timer_status -&gt; interval_timer_status
<span class="c006">end</span></div><p>The function <code>new_timer k f</code> should create a new timer of the 
timer-type <code>k</code> starting the action <code>f</code>, and inactive on creation; 
the function <code>set_timer t</code> should set the value of the timer <code>t</code> 
(and return the old value). </p><div class="fancybreak">* * *</div></div><!--TOC subsection id=sec97 Date calculations-->
<h3 class="subsection" id="sec97">Date calculations</h3><!--SEC END --><p>Modern versions of Unix also provide functions to handle dates, see
the structure <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEtm"><span class="c001">tm</span></a> which allows dates and times to be
expressed according to a calendar (year, month, etc.) and the
conversion functions: <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgmtime"><span class="c001">gmtime</span></a><a id="hevea_default94"></a>,
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlocaltime"><span class="c001">localtime</span></a><a id="hevea_default95"></a>, <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALmktime"><span class="c001">mktime</span></a><a id="hevea_default96"></a>, etc.</p>
<!--TOC section id=sec98 Problems with signals-->
<h2 class="section" id="sec98">4.7  Problems with signals</h2><!--SEC END --><p>Owing to their asynchronous nature, the use of signals for inter-process communication 
presents some limitations and difficulties:
</p><ul class="itemize"><li class="li-itemize">Very little information is transmitted — the signal’s
type and nothing else.</li><li class="li-itemize">A signal may occur at any point during the execution of the
program. Therefore, a signal handling function that accesses global
variables must cooperate with the main program to avoid race
conditions. </li><li class="li-itemize">The use of signals by the main program entails that long system
calls made by the program may be interrupted, even if the signals
keep their default behavior.</li><li class="li-itemize">Library functions must always consider the possibility of
signal use and guard against system call interruption.</li></ul><p>Signals offer only a limited form of asynchronous communication but
carry all the difficulties and problems associated with it. If possible,
it is therefore better not to use them. For example, to wait for a small
amount of time, <span class="c001">select</span><a id="hevea_default97"></a> can be used instead of alarms. But
in certain situations signals must be taken into account (for example in
command line interpreters).</p><p>Signals are possibly the least useful concept in the Unix system. On
certain older versions of Unix (System V, in particular) the behavior
of a signal is automatically reset to <code>Signal_default</code> when it is
received. The signal handling function can of course register itself
again. For example in the “beep” example on
page <a href="#ex%2Fbeep">??</a>, it would be necessary to write:
</p><div class="mylisting"><span class="c006">let rec</span> beep _ =
  set_signal sigalrm (Signal_handle beep);
  output_char stdout '\007'; flush stdout;
  ignore (alarm 30);;</div><p>However the problem is that the signals that are received between the
instant were the behavior is automatically reset to
<code>Signal_default</code> and the moment were <code>set_signal</code> is invoked are
not treated correctly and depending on the type of the signal they may
be ignored or cause the process to die instead of invoking the signal
handling function. </p><p>Other flavors of Unix (<span class="c005">bsd</span> or Linux) provide better support:
the behavior associated with a signal is not altered when it is
received, and during the handling of a signal other signals of the
same type are put on hold.</p>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note6" href="#text6">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">These 
are the default keystrokes, but it is possible to change them by 
modifying the properties of the terminal, see section <a href="#sec48">2.13</a>.</div>
</dd></dl>
<!--END NOTES-->
<!--TOC chapter id=sec99 Classical inter-process communication: pipes-->
<h1 class="chapter" id="sec99"> 5  Classical inter-process communication: pipes</h1><!--SEC END --><!--NAME pipes.html-->
<p>So far, we have learned how to manage processes and how they can communicate
with the environment by using files. In the remainder of the
course we see how processes running in parallel can cooperate by
communicating among themselves.</p>
<!--TOC section id=sec100 Pipes-->
<h2 class="section" id="sec100">5.1  Pipes</h2><!--SEC END --><p>Regular files are not a satisfactory communication medium for processes
running in parallel. Take for example a reader/writer situation in
which one process writes data and the other reads them. If a file is used
as the communication medium, the reader can detect that the file
does not grow any more (<code>read</code> returns zero), but it does not know
whether the writer is finished or simply busy computing
more data. Moreover, the file keeps track of all the data transmitted,
requiring needless disk space.</p><p>Pipes provide a mechanism suitable for this kind of communication. A
pipe is made of two file descriptors. The first one
represents the pipe’s output. The second one represents
the pipe’s input. Pipes are created by the system call
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/pipe.html"><span class="c001">pipe</span></a><a id="hevea_default98"></a>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALpipe">pipe</a> : unit -&gt; file_descr * file_descr</div><p>The call returns a pair <code>(fd_in, fd_out)</code> where <code>fd_in</code> is a
file descriptor open in <em>read mode</em> on the pipe’s output and
<code>fd_out</code> is file descriptor open in <em>write mode</em> on the pipe’s
input. The pipe itself is an internal object of the kernel that can
only be accessed via these two descriptors. In particular, it has no
name in the file system.</p><div class="image"><img src="ocamlunix-image6.png" width="60%"></div><p>A pipe behaves like a queue (<em>first-in, first-out</em>). The first
thing written to the pipe is the first thing read from the pipe.
Writes (calls to <span class="c001">write</span><a id="hevea_default99"></a> on the pipe’s input
descriptor) fill the pipe and block when the pipe is full. They block
until another process reads enough data at the other end of the pipe
and return when all the data given to <code>write</code> have been
transmitted. Reads (calls to <span class="c001">read</span><a id="hevea_default100"></a> on the pipe’s output
descriptor) drain the pipe. If the pipe is empty, a call to <code>read</code>
blocks until at least a byte is written at the other end. It then
returns immediately without waiting for the number of bytes requested
by <code>read</code> to be available.</p><p>Pipes are useless if they are written and read by the same process
(such a process will likely block forever on a substantial write or on
a read on the empty pipe). Hence they are usually read and written by
different processes. Since a pipe has no name, one of these processes
must be created by forking the process that created the pipe. Indeed,
the two file descriptors of the pipe, like any other file descriptors,
are duplicated by the call to <span class="c001">fork</span><a id="hevea_default101"></a> and thus refer to the
same pipe in the parent and the child process.
</p><div class="example">
<!--TOC paragraph id=sec101 Example-->
<h5 class="paragraph" id="sec101">Example</h5><!--SEC END --><p> The following snippet of code is typical.
</p><div class="mylisting"><span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in
match</span> fork () <span class="c006">with</span>
| 0 -&gt; close fd_in; ... write fd_out buffer1 offset1 count1 ...
| pid -&gt; close fd_out; ... read fd_in buffer2 offset2 count2 ...</div><p>After the <code>fork</code> there are two descriptors open on the pipe’s
input, one in the parent and the other in the child. The same
holds for the pipe’s output.
</p><div class="image"><img src="ocamlunix-image7.png" width="45%"></div><p>


In this example the child becomes the writer and the parent the
reader. Consequently the child closes its descriptor <code>fd_in</code> on the
pipe’s output (to save descriptors and to avoid programming
errors). This leaves the descriptor <code>fd_in</code> of the parent unchanged
as descriptors are allocated in process memory and after the fork the
parent’s and child’s memory are disjoint. The pipe, allocated in system
memory, still lives as there’s still the descriptor <code>fd_in</code> of the
parent open in read mode on the pipe’s output. Following the same
reasoning the parent closes its descriptor on the pipe’s input. The
result is as follows:
</p><div class="image"><img src="ocamlunix-image8.png" width="45%"></div><p>


Data written by the child on <code>fd_out</code> is transmitted to <code>fd_in</code>
in 
the parent.
</p><div class="fancybreak">* * *</div></div><p>
When all the descriptors on a pipe’s input are closed and the pipe is
empty, a call to <code>read</code> on its output returns zero:
end of file. And when all the descriptors on a pipe’s output are
closed, a call to <code>write</code> on its input kills the writing
process. More precisely the kernel sends the signal <code>sigpipe</code> to
the process calling <code>write</code> and the default handler of this signal
terminates the process. If the signal handler of <code>sigpipe</code> is
changed, the call to <code>write</code> fails with an <code>EPIPE</code> error.
</p>
<!--TOC section id=sec102 Complete example: parallel sieve of Eratosthenes-->
<h2 class="section" id="sec102">5.2  Complete example: parallel sieve of Eratosthenes</h2><!--SEC END --><p>This is a classic example of parallel programming. The task of the
program is to enumerate the prime numbers and display them
interactively as they are found. The idea of the algorithm is as
follows. A process enumerates on its output the integers from 2 onwards. We
connect this process to a “filter” process that reads an
integer <span class="c004">p</span> on its input and displays it.</p><div class="image"><img src="ocamlunix-image9.png" width="38%"></div><p>


Therefore, the first filter process reads <span class="c004">p</span>=2. Then it creates a new
filter process connected to its output and filters out the multiples
of <span class="c004">p</span> it gets on its input; all numbers it reads that are not a
multiple of <span class="c004">p</span> are rewritten on its output.
</p><div class="image"><img src="ocamlunix-image10.png" width="65%"></div><p>


Hence the next process reads <span class="c004">p</span>=3, which it displays and then starts
to filter multiples of 3, and so on.
</p><div class="image"><img src="ocamlunix-image11.png" width="100%"></div><p>


This algorithm cannot be directly implemented in Unix because it
creates too many processes (the number of primes already found plus
one). Most Unix systems limit the number of process to a few dozens.
Moreover, on a uniprocessor machine, too many processes active
simultaneously can bring the system to its knees because of the
high costs incurred by switching process contexts. In the following
implementation each process first reads <span class="c004">n</span> primes <span class="c004">p</span><sub>1</sub>, …, <span class="c004">p</span><sub><span class="c004">n</span></sub>
on its input before transforming itself in a filter that eliminate the
multiples of <span class="c004">p</span><sub>1</sub>, …, <span class="c004">p</span><sub><span class="c004">n</span></sub>. In practice <span class="c004">n</span> = 1000 gives a
reasonable slowdown on process creation.</p><p>We start with the process that enumerates integers from 2 to <span class="c004">k</span>.
</p><div class="mylisting"><span class="c006">open</span> Unix;;

<span class="c006">let</span> input_int = input_binary_int
<span class="c006">let</span> output_int = output_binary_int

<span class="c006">let</span> generate k output =
  <span class="c006">let rec</span> gen m =
    output_int output m;
    <span class="c006">if</span> m &lt; k <span class="c006">then</span> gen (m+1)
  <span class="c006">in</span>
  gen 2;;</div><p>To output and input the integers, the following functions are used:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALoutput_binary_int">output_binary_int</a> : out_channel -&gt; int -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinput_binary_int">input_binary_int</a> : in_channel -&gt; int</div><p>The function <code>output_binary_int</code> from the standard library writes a
four-byte binary representation of an integer on an
<code>out_channel</code>. The integer can be read back by the function
<code>input_binary_int</code> on an <code>in_channel</code>. Using these functions
from the standard library has two advantages: first, there is no need to
code the function converting integers to a bytewise
representation<sup><a id="text7" href="#note7">1</a></sup>; second, since
these functions use buffered <span class="c005">i/o</span>, fewer system calls are
performed, which results in better performance. The following functions
create an <code>in_channel</code> or <code>out_channel</code> to buffer the
<span class="c005">i/o</span> on the given descriptor:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALin_channel_of_descr">in_channel_of_descr</a><a id="hevea_default102"></a> : file_descr -&gt; in_channel
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALout_channel_of_descr">out_channel_of_descr</a><a id="hevea_default103"></a> : file_descr -&gt; out_channel</div><p>They allow a program to perform buffered <span class="c005">i/o</span> on descriptors acquired
indirectly or that are not the result of opening a file. These
functions are not here to mix buffered <span class="c005">i/o</span> with non-buffered
<span class="c005">i/o</span>; this is possible but very brittle and highly
discouraged — particularly for input. Note also that it is possible
but very risky to create more than one <code>in_channel</code> (for example)
on the same descriptor.</p><p>We now continue with the filter process. It uses the auxiliary function
<code>read_first_primes</code>. A call to <code>read_first_primes input count</code> 
reads <code>count</code> prime numbers on <code>input</code> (an <code>in_channel</code>) and eliminates
multiples of the primes already read. These <code>count</code> primes are
displayed as soon as they are read and we return them in a list.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let</span> print_prime n = print_int n; print_newline ()
<span class="c003">   2</span> 
<span class="c003">   3</span> <span class="c006">let</span> read_first_primes input count =
<span class="c003">   4</span>   <span class="c006">let rec</span> read_primes first_primes count =
<span class="c003">   5</span>     <span class="c006">if</span> count &lt;= 0 <span class="c006">then</span> first_primes <span class="c006">else</span>
<span class="c003">   6</span>     <span class="c006">let</span> n = input_int input <span class="c006">in</span>
<span class="c003">   7</span>     <span class="c006">if</span> List.exists (<span class="c006">fun</span> m -&gt; n <span class="c006">mod</span> m = 0) first_primes <span class="c006">then</span>
<span class="c003">   8</span>       read_primes first_primes count
<span class="c003">   9</span>     <span class="c006">else begin</span>
<span class="c003">  10</span>       print_prime n;
<span class="c003">  11</span>       read_primes (n :: first_primes) (count - 1)
<span class="c003">  12</span>     <span class="c006">end</span>
<span class="c003">  13</span>   <span class="c006">in</span>
<span class="c003">  14</span>   read_primes [] count<a id="prog:pprime"></a>;;</div><p>And here is the concrete filter function: 
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let rec</span> filter input =
<span class="c003">   2</span>   <span class="c006">try</span>
<span class="c003">   3</span>     <span class="c006">let</span> first_primes = read_first_primes input 1000 <span class="c006">in</span>
<span class="c003">   4</span>     <span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in</span>
<span class="c003">   5</span>     <span class="c006">match</span> fork () <span class="c006">with</span> <a id="prog:sievefilterfork"></a>
<span class="c003">   6</span>     | 0 -&gt;
<span class="c003">   7</span>         close fd_out;
<span class="c003">   8</span>         filter (in_channel_of_descr fd_in)
<span class="c003">   9</span>     | p -&gt;
<span class="c003">  10</span>         close fd_in;
<span class="c003">  11</span>         <span class="c006">let</span> output = out_channel_of_descr fd_out <span class="c006">in</span>
<span class="c003">  12</span>         <span class="c006">while true do</span> <a id="prog:sievefilterwhile"></a>
<span class="c003">  13</span>           <span class="c006">let</span> n = input_int input <span class="c006">in</span>
<span class="c003">  14</span>           <span class="c006">if</span> List.exists (<span class="c006">fun</span> m -&gt; n <span class="c006">mod</span> m = 0) first_primes <span class="c006">then</span> ()
<span class="c003">  15</span>           <span class="c006">else</span> output_int output n
<span class="c003">  16</span>         <span class="c006">done</span> <a id="prog:sievefilterdone"></a>
<span class="c003">  17</span>   <span class="c006">with</span> End_of_file -&gt; ();;</div><p>The filter starts by calling <code>read_first_primes</code> to read the first
1000 prime numbers on its input (the <code>input</code> argument of type
<code>in_channel</code>). Then we create a pipe and clone the process with
<code>fork</code>. The child starts to filter the output of this pipe. The
parent reads numbers on its input and writes each one to the pipe if it
is not a multiple of one of the 1000 primes it initially read.</p><p>Finally, the main program just connects the integer generator to the
first filter process with a pipe. Invoking the program <code>sieve k</code>
enumerates the primes smaller than <code>k</code>. If <code>k</code> is omitted (or
not an integer), it defaults to <code>max_int</code>.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let</span> sieve () =
<span class="c003">   2</span>   <span class="c006">let</span> len = <span class="c006">try</span> int_of_string Sys.argv.(1) <span class="c006">with</span> _ -&gt; max_int <span class="c006">in</span>
<span class="c003">   3</span>   <span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in</span>
<span class="c003">   4</span>   <span class="c006">match</span> fork () <span class="c006">with</span> <a id="prog:sievefork"></a>
<span class="c003">   5</span>   | 0 -&gt;
<span class="c003">   6</span>       close fd_out;
<span class="c003">   7</span>       filter (in_channel_of_descr fd_in)
<span class="c003">   8</span>   | p -&gt;
<span class="c003">   9</span>       close fd_in;
<span class="c003">  10</span>       generate len (out_channel_of_descr fd_out);; <a id="prog:gen"></a>
<span class="c003">  11</span> 
<span class="c003">  12</span> handle_unix_error sieve ();;</div><p>In this example we do not wait for the child before stopping the
parent. The reason is that parent processes are <em>generators</em> for
their children.</p><p>When <code>k</code> is given, the parent will terminate first and close
the descriptor on the input of the pipe connected to its child. Since
OCaml empties the buffers of descriptors open in write mode when a
process stops, the child process will read the last integer provided
by the parent. After that the child also stops etc. Thus, in this
program children become orphaned and are temporarily attached to the
process <code>init</code> before they die in turn.</p><p>If <code>k</code> is not given, all processes continue indefinitely until one or
more are killed. The death of a process results in the death of its child
as described above. It also closes the output of the pipe connected to
its parent. This will in turn kill the parent at the next write on the
pipe (the parent will receive a <code>sigpipe</code> signal whose default
handler terminates the process).</p><div class="exercise">
<!--TOC paragraph id=sec103 Exercise 12-->
<h5 class="paragraph" id="sec103">Exercise 12</h5><!--SEC END --><p><a id="ex12"></a>
What needs to be changed so that the parent waits on the termination
of its children?
<a href="#exans12">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 12</arg>-->
<!--NAME exercise12.html-->
<div class="answer">
<!--TOC paragraph id=sec104 Answer of exercise 12-->
<h5 class="paragraph" id="sec104">Answer of <a href="#ex12">exercise 12</a></h5><!--SEC END --><p>
<a id="exans12"></a>
Of course the parent must wait on its child. However, before that the
input of the pipe on which the child reads must be closed by the
parent, otherwise the child will wait indefinitely for new integers from the
parent. This leads to a deadlock (closing the channel empties the
buffer before closing the corresponding descriptor, therefore no data
is lost). Concretely, the line <a href="#prog%3Agen">10</a> of the <code>sieve</code>
function needs to be replaced by:
</p><div class="mylisting"><span class="c006">let</span> output = out_channel_of_descr fd_out <span class="c006">in</span>
generate len output;
close_out output;
ignore(waitpid [] p);;</div><p>Accordingly, we enclose the 
lines <a href="#prog%3Asievefilterwhile">12</a>–<a href="#prog%3Asievefilterdone">16</a> of the 
<code>filter</code> function (represented by <code>...</code> below) with the
following lines:
</p><div class="mylisting"><span class="c006">try</span>
  ...
<span class="c006">with</span> End_of_file -&gt;
  close_out output;
  ignore (waitpid [] p)</div><div class="fancybreak">* * *</div></div><!--END FLOW-->
<div class="exercise">
<!--TOC paragraph id=sec105 Exercise 13-->
<h5 class="paragraph" id="sec105">Exercise 13</h5><!--SEC END --><p><a id="ex13"></a>
Whenever a prime is found, the function <code>print_prime</code> evaluates
<code>print_newline ()</code>. This performs a system call to empty the standard
output buffer and artificially limits the execution speed of the program.
In fact <code>print_newline ()</code> executes <code>print_char '\n'</code>
followed by <code>flush Pervasives.stdout</code>. What can happen if
<code>print_newline ()</code> is replaced by <code>print_char '\n'</code>? What needs
to be added to solve the problem?
<a href="#exans13">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 13</arg>-->
<!--NAME exercise13.html-->
<div class="answer">
<!--TOC paragraph id=sec106 Answer of exercise 13-->
<h5 class="paragraph" id="sec106">Answer of <a href="#ex13">exercise 13</a></h5><!--SEC END --><p>
<a id="exans13"></a>
Since the child process is an exact copy of the parent, <span class="c005">i/o</span>
buffers of the standard library are duplicated when <code>fork</code> is
executed. If the buffers are not emptied after each write,
they must be emptied explicitly just before the call to
<code>fork</code>. All is needed is to add 
<code>flush Pervasives.stdout</code> after the line <a href="#prog%3Apprime">14</a> of the 
function <code>read_first_prime</code>.
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id=sec107 Named pipes-->
<h2 class="section" id="sec107">5.3  Named pipes</h2><!--SEC END --><p>On some Unix systems (System V, SunOS, Ultrix, Linux, <span class="c005">bsd</span>)
pipes with a name in the file system can be created. These <em>named
pipes</em> (also known as <em>fifo</em>) allow processes to communicate
even if they are not in a parent/child relationship. This contrasts
with regular pipes that limit communication between the pipe creator
and its descendants.</p><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/mkfifo.html"><span class="c001">mkfifo</span></a><a id="hevea_default104"></a> creates a named pipe: 
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALmkfifo">mkfifo</a> : string -&gt; file_perm -&gt; unit</div><p>The first argument is the name of the pipe, and the second one represents the
requested access permissions.</p><p>Named pipes are opened with a call to <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALopenfile"><span class="c001">openfile</span></a> like any
regular file. Reads and writes on a named pipe have the same semantics
as those on regular ones. Opening a named pipe in read-only mode
(resp. write-only mode) blocks until the pipe is opened by another
process for writing (resp. reading); if this has already happened,
there’s no blocking. Blocking can be avoided altogether by opening the
pipe with the flag <code>O_NONBLOCK</code>, but in this case reads and writes
on the pipe won’t block either. After the
pipe is opened, the function <code>clear_nonblock</code> will change this flag to make further
reads or writes on the pipe blocking. Alternatively,
<code>set_nonblock</code> will make reads and writes non-blocking.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALclear_nonblock">clear_nonblock</a><a id="hevea_default105"></a> : file_descr -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALset_nonblock">set_nonblock</a><a id="hevea_default106"></a> : file_descr -&gt; unit</div>
<!--TOC section id=sec108 Descriptor redirections-->
<h2 class="section" id="sec108">5.4  Descriptor redirections</h2><!--SEC END --><p>So far, we still do not know how to connect the standard input and
output of processes with a pipe as the shell does to execute
commands like <code>cmd1 | cmd2</code>. Indeed, the descriptors we get on the
ends of a pipe with a call to <code>pipe</code> (or to <code>openfile</code> on a
named pipe) are <em>new</em> descriptors, distinct from <code>stdin</code>,
<code>stdout</code> or <code>stderr</code>.</p><p>To address this problem, Unix provides the system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/dup2.html"><span class="c001">dup2</span></a><a id="hevea_default107"></a> 
(read: “<em>dup</em>licate a descriptor <em>to</em> another
descriptor”) that gives one file descriptor another one’s meaning.
This
can be done because there is a level of indirection between a file
descriptor (an object of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEfile_descr"><span class="c001">file_descr</span></a>) and the object in the
kernel called a <em>file table entry</em> that points to the actual
file or pipe and maintains its current read/write position.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALdup2">dup2</a> : file_descr -&gt; file_descr -&gt; unit</div><p>The effect of <code>dup2 fd1 fd2</code> is to update the descriptor <code>fd2</code> to refer to
the file table entry pointed to by <code>fd1</code>. After the call, these two
descriptors refer to same file or pipe, at the same read/write
position.</p><div class="image"><img src="ocamlunix-image12.png" width="80%"></div><div class="example">
<!--TOC paragraph id=sec109 Example-->
<h5 class="paragraph" id="sec109">Example</h5><!--SEC END --><p> 
Standard input redirection.
</p><div class="mylisting"><span class="c006">let</span> fd = openfile "foo" [O_RDONLY] 0 <span class="c006">in</span>
dup2 fd stdin;
close fd;
execvp "bar" [|"bar"|]</div><p>After the call to <code>dup2</code>, the descriptor <code>stdin</code> points to the
file <code>foo</code>. Any read on <code>stdin</code> will read from the file <code>foo</code>
(so does any read on <code>fd</code>; but since we won’t use it, we close it
immediately). This setting on <code>stdin</code> is preserved by <code>execvp</code>
and the program <code>bar</code> will execute with its standard input
connected to the file <code>foo</code>. This is the way the shell executes
commands like <code>bar &lt; foo</code>.
</p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec110 Example-->
<h5 class="paragraph" id="sec110">Example</h5><!--SEC END --><p> 
Standard output redirection.
</p><div class="mylisting"><span class="c006">let</span> fd = openfile "foo" [O_WRONLY; O_TRUNC; O_CREAT] 0o666 <span class="c006">in</span>
dup2 fd stdout;
close fd;
execvp "bar" [|"bar"|]</div><p>After the call to <code>dup2</code>, the descriptor <code>stdout</code> points to
the file <code>foo</code>. Any write on <code>stdout</code> will write to the file
<code>foo</code> (so does any write on <code>fd</code>; but since we won’t use it we
close it immediately). This setting on <code>stdout</code> is preserved by
<code>execvp</code> and the program <code>bar</code> will execute with its standard output
connected to the file <code>foo</code>. This is the way the shell executes
commands like <code>bar &gt; foo</code>.
</p><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec111 Example-->
<h5 class="paragraph" id="sec111">Example</h5><!--SEC END --><p> Connecting the output of a program to the input of another.
</p><div class="mylisting"><span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in
match</span> fork () <span class="c006">with</span>
| 0 -&gt;
       dup2 fd_in stdin;
       close fd_out;
       close fd_in;
       execvp "cmd2" [|"cmd2"|]
| _ -&gt;
       dup2 fd_out stdout;
       close fd_out;
       close fd_in;
       execvp "cmd1" [|"cmd1"|]</div><p>The program <code>cmd2</code> is executed with its standard input connected to
the output of the pipe. In parallel, the program <code>cmd1</code> is executed
with its standard output connected to the input of the pipe. Therefore
whatever <code>cmd1</code> writes on its standard output is read by <code>cmd2</code>
on its standard input.</p><p>What happens if <code>cmd1</code> terminates before <code>cmd2</code>? When <code>cmd1</code>
terminates, all its open descriptors are closed. This means that there’s no
open descriptor on the input of the pipe. When <code>cmd2</code> has read all
the data waiting in the pipe, the next read returns an end of file;
<code>cmd2</code> will then do what it is assigned to do when it reaches the
end of its standard input — for example, terminate. </p><p>Now, if <code>cmd2</code> terminates before <code>cmd1</code>, the last descriptor on
the output of the pipe is closed and <code>cmd1</code> will get
a signal (which by default kills the process) the next time
it tries to write on its standard output. </p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id=sec112 Exercise 14-->
<h5 class="paragraph" id="sec112">Exercise 14</h5><!--SEC END --><p><a id="ex14"></a>
Implement some of the other redirections provided by the shell
<code>sh</code>. Namely: 
</p><div class="mylisting">&gt;&gt;      2&gt;      2&gt;&gt;     2&gt;1     &lt;&lt;</div><p><a href="#exans14">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 14</arg>-->
<!--NAME exercise14.html-->
<div class="answer">
<!--TOC paragraph id=sec113 Answer of exercise 14-->
<h5 class="paragraph" id="sec113">Answer of <a href="#ex14">exercise 14</a></h5><!--SEC END --><p>
<a id="exans14"></a>
</p><ul class="itemize"><li class="li-itemize">
For <code>&gt;&gt;</code>, the answer is similar to the <code>&gt;</code> redirection, except that the
file is opened with the flags <code>[O_WRONLY; O_APPEND; O_CREAT]</code>.
</li><li class="li-itemize">For <code>2&gt;</code>, the answer is similar to the <code>&gt;</code> redirection, except that
<code>dup2 fd stderr</code> is executed instead of <code>dup2 fd stdout</code>
</li><li class="li-itemize">For <code>2&gt;1</code>, we must call <code>dup2 stderr stdout</code> before executing
the command.
</li><li class="li-itemize">For <code>&lt;&lt;</code>, the shell <code>sh</code> must create a temporary file in
<code>/tmp</code> containing the lines that follow <code>&lt;&lt;</code> and execute the 
command with its standard input redirected from this file. Another 
solution is to connect the command’s standard input to the output of a 
pipe and let a child process write the lines following <code>&lt;&lt;</code> on the
input of that pipe.
</li></ul><div class="fancybreak">* * *</div></div><!--END FLOW-->
<p>Swapping two descriptors requires care. The naive sequence
<code>dup2 fd1 fd2;</code> <code>dup2 fd2 fd1</code> does not work. Indeed, the second
redirection has no effect since after the first one both descriptors
<code>fd1</code> and <code>fd2</code> already point to the same file table entry. The
initial value pointed by <code>fd2</code> was lost. This is like swapping the
contents of two reference cells: a temporary variable is needed to
save one of the two values. Here we can save one of the
descriptors by copying it with the system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/dup.html"><span class="c001">dup</span></a><a id="hevea_default108"></a>.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALdup">dup</a> : file_descr -&gt; file_descr</div><p>The call to <code>dup fd</code> returns a new descriptor pointing on the same
file table entry as <code>fd</code>. For example we can swap <code>stdout</code> and 
<code>stderr</code> with:

</p><div class="mylisting"><span class="c006">let</span> tmp = dup stdout <span class="c006">in</span>
dup2 stderr stdout;
dup2 tmp stderr;
close tmp;;</div><p>After the swap, do not forget to close the temporary descriptor
<code>tmp</code> to prevent a descriptor leak.</p>
<!--TOC section id=sec114 Complete example: composing <span class="c004">N</span> commands-->
<h2 class="section" id="sec114">5.5  Complete example: composing <span class="c004">N</span> commands</h2><!--SEC END --><p>We program a command <code>compose</code> such that 
</p><div class="mylisting">compose cmd<sub>1</sub> cmd<sub>2</sub> ... cmd<sub><span class="c004">n</span></sub></div><p>behaves like the shell command:
</p><div class="mylisting">cmd<sub>1</sub> | cmd<sub>2</sub> | ... | cmd<sub><span class="c004">n</span></sub></div><div class="mylisting"><span class="c003">   1</span> <span class="c006">open</span> Sys;;
<span class="c003">   2</span> <span class="c006">open</span> Unix;;
<span class="c003">   3</span> 
<span class="c003">   4</span> <span class="c006">let</span> compose () =
<span class="c003">   5</span>   <span class="c006">let</span> n = Array.length Sys.argv - 1 <span class="c006">in</span>
<span class="c003">   6</span>   <span class="c006">for</span> i = 1 <span class="c006">to</span> n - 1 <span class="c006">do</span> <a id="prog:composefor"></a>
<span class="c003">   7</span>     <span class="c006">let</span> (fd_in, fd_out) = pipe () <span class="c006">in</span>
<span class="c003">   8</span>     <span class="c006">match</span> fork () <span class="c006">with</span>
<span class="c003">   9</span>     | 0 -&gt;
<span class="c003">  10</span>         dup2 fd_out stdout;
<span class="c003">  11</span>         close fd_out;
<span class="c003">  12</span>         close fd_in;
<span class="c003">  13</span>         execv "/bin/sh" [| "/bin/sh"; "-c"; Sys.argv.(i) |]
<span class="c003">  14</span>     | _ -&gt;
<span class="c003">  15</span>         dup2 fd_in stdin;
<span class="c003">  16</span>         close fd_out;
<span class="c003">  17</span>         close fd_in
<span class="c003">  18</span>   <span class="c006">done</span>;
<span class="c003">  19</span>   <span class="c006">match</span> fork () <span class="c006">with</span>
<span class="c003">  20</span>   | 0 -&gt; execv "/bin/sh" [|"/bin/sh"; "-c"; Sys.argv.(n) |]
<span class="c003">  21</span>   | _ -&gt;
<span class="c003">  22</span>       <span class="c006">let rec</span> wait_for_children retcode =
<span class="c003">  23</span>         <span class="c006">try</span>
<span class="c003">  24</span>           <span class="c006">match</span> wait () <span class="c006">with</span>
<span class="c003">  25</span>           | (pid, WEXITED n) -&gt; wait_for_children (retcode <span class="c006">lor</span> n)
<span class="c003">  26</span>           | (pid, _)         -&gt; wait_for_children 127
<span class="c003">  27</span>         <span class="c006">with</span>
<span class="c003">  28</span>           Unix_error(ECHILD, _, _) -&gt; retcode <span class="c006">in</span>
<span class="c003">  29</span>       exit (wait_for_children 0)
<span class="c003">  30</span> ;;
<span class="c003">  31</span> handle_unix_error compose ();;</div><p>The bulk of the work is done by the <code><span class="c006">for</span></code> loop starting at
line <a href="#prog%3Acomposefor">6</a>. For each command except the last one, we
create a new pipe and a child process. The child connects the pipe’s
input to its standard output and executes the command. After the
<code>fork</code> it inherits the standard input of its parent. The main
process (the parent) connects the pipe’s output to its standard input
and continues the loop. Suppose (induction hypothesis) that at the
beginning of the <span class="c004">i</span>th iteration, the situation is as follows:

</p><div class="image"><img src="ocamlunix-image13.png" width="80%"></div><p>


Rounded boxes represent processes. Their standard input is on the
left, their standard output on the right. The ellipses represent
the initial standard input and output of the <code>compose</code> process.
Just after the call to <code>pipe</code> and <code>fork</code> we have:
</p><div class="image"><img src="ocamlunix-image14.png" width="100%"></div><p>


When the parent calls <code>dup2</code>, we get:
</p><div class="image"><img src="ocamlunix-image15.png" width="100%"></div><p>


When the child calls <code>dup2</code> and <code>execv</code>, we get:
</p><div class="image"><img src="ocamlunix-image16.png" width="100%"></div><p>


and everything is ready for the next iteration. </p><p>The last command is forked after the loop because there’s no need to
create a new pipe: the process <code>compose</code> already has the right
standard input (the output of the next to last command) and output
(the one initially given to the command <code>compose</code>) for the
child. Hence it is sufficient to <code>fork</code> and <code>exec</code>. The parent then
waits for its children to terminate: it calls <code>wait</code> repeatedly
until the error <code>ECHILD</code> (no child to wait for) is raised. The
children’s return codes are combined with a bitwise “or”
(<code><span class="c006">lor</span></code> operator) to create a meaningful return code for
<code>compose</code> : zero if all the children returned zero, different from
zero otherwise.</p><p>Note that we execute commands through the shell <code>/bin/sh</code>. This
prevents us from having to parse complex commands into tokens as
in the following invocation:
</p><div class="mylisting">compose "grep foo" "wc -l"</div><p>Adding this functionality to our program would complicate it needlessly.</p>
<!--TOC section id=sec115 Input/output multiplexing-->
<h2 class="section" id="sec115">5.6  Input/output multiplexing</h2><!--SEC END --><p>In all the examples so far, processes communicate <em>linearly</em>:
each process reads data coming from at most one other process. In this
section we highlight and solve the problems occurring whenever a
process needs to read data coming from <em>many</em> processes.</p><p>Consider the example of a multi-windowed terminal emulator. Suppose we
have a computer, called the client, connected to a Unix machine by a
serial port. We want to emulate, on the client, many terminal windows
connected to different user processes on the Unix machine. For example,
one window can be connected to a shell and another to a text
editor. Outputs from the shell are displayed in the first window and
those from the editor in the other. If the first window is
active, keystrokes from the client’s keyboard are sent to the input of
the shell and if the second window is active they are sent to the
input of the editor.</p><p>Since there’s only a single physical link between the client and the
Unix machine, we need to multiplex the virtual connections between
windows and processes by interleaving the data transmissions.
Here’s the protocol we are going to use. On the serial port, we send
messages with the following structure: 
</p><ul class="itemize"><li class="li-itemize">
One byte indicating the process number or window number of the receiver.
</li><li class="li-itemize">One byte indicating the number <span class="c004">N</span> of bytes that are following.
</li><li class="li-itemize"><span class="c004">N</span> bytes of data to send to the receiver.
</li></ul><p>
On the Unix machine, user processes (shell, editor, etc.) are
connected by a pipe to one or more auxiliary processes that read and
write on the serial port and (de)multiplex the data. The serial port
is a special file (<code>/dev/ttya</code>, for example), on which the
auxiliary processes <code>read</code> and <code>write</code> to communicate with the 
client.</p><p>Demultiplexing (transmission from the client to the user processes)
does not pose any particular problem. We just need a process that reads
messages on the serial port and writes the extracted data on the pipe
connected to the standard input of the receiving user process.
</p><div class="image"><img src="ocamlunix-image17.png" width="55%"></div><p>


Multiplexing (transmission from user processes to the client) is
more tricky. Let us try to mimic the demultiplexer: a process reads
sequentially the output of the pipes connected to the standard output
of the user processes and then writes the data it reads as message on
the serial port by adding the receiving window number and the length
of the data.
</p><div class="image"><img src="ocamlunix-image18.png" width="100%"></div><p>


This does not work, because reading a pipe can block. For example, if we
try to read the output of the shell but it has nothing to
display at that moment, the multiplexer process will block, and waiting
characters from the editor will be ignored.
There’s no way to know in advance on which pipes there is
data waiting to be displayed (in parallel algorithms, the situation
where a process is perpetually denied access to a shared resource is
called <em>starvation</em>).</p><p>Here is another approach: we associate with each user process a
<em>repeater</em> process. The repeater reads the output of the pipe
connected to the standard output of the user process, transforms the
data into messages and writes the result directly on the serial port
(each repeater process opens <code>/dev/ttya</code> in write mode).
</p><div class="image"><img src="ocamlunix-image19.png" width="100%"></div><p>Since each user process has its output transmitted independently,
blocking problems are solved. However the protocol may not be
respected. Two repeaters may try to write a message at the same time
and the Unix kernel does not guarantee the atomicity of writes, i.e. 
that they are performed in a single uninterruptible operation.
Thus the kernel may choose to write only a part of a message from a
repeater to <code>/dev/ttya</code>, then write a full message from another
repeater and finally write the remaining part of the first message.
This will utterly confuse the demultiplexer on the client: 
it will interpret the second message as part of the data of the
first and then interpret the rest of the data as a new message header.</p><p>To avoid this, repeater processes must synchronize so that at anytime
at most one of them is writing on the serial port (in parallel
algorithms we say that we need to enforce the mutual exclusion of
repeaters on the access to the serial link). Technically, this can be
done with concepts we have already seen so far: repeaters can create a
specific file (the “lock”) with the <code>O_EXCL</code> flag before
sending a message and destroy it after they are done writing to the
serial port. However this technique is not very efficient because the
lock creation and destruction costs are too high.</p><p>A better solution is to take the first approach (a single
multiplexer process) and set the output of the pipes connected to the
standard output of user processes in non-blocking mode with
<code>set_nonblock</code>. A read on an empty pipe will not block but return
immediately by raising the error <code>EAGAIN</code> or <code>EWOULDBLOCK</code>. We
just ignore this error and try to read the output of the next user
process. This will prevent starvation and avoid any mutual exclusion
problem. However it is a very inefficient solution, the multiplexer
process performs what is called “busy waiting”: it uses
processing time even if no process is
sending data. This can be alleviated by introducing calls to
<code>sleep</code> in the reading loop; unfortunately, it is very difficult to find
the right frequency. Short <code>sleep</code>s cause needless processor load when there
is little data, and long <code>sleep</code>s introduce perceptible delays when there is a lot of data.</p><p>This is a serious problem. To solve it, the designers of <span class="c005">bsd</span>
Unix introduced a new system call, <code>select</code>, which is now
available on most Unix variants. A call to <code>select</code> allows a
process to wait (passively) on one or more input/output events.
An event can be:
</p><ul class="itemize"><li class="li-itemize">
A read event: there is data to read on that descriptor.</li><li class="li-itemize">A write event: it is possible to write on that descriptor
without blocking.</li><li class="li-itemize">An exceptional event: an exceptional condition is
true on that descriptor. For example, on certain network connections
high-priority data (<em>out-of-band data</em>) can be sent that
overtakes normal data waiting to be sent. Receiving this kind of 
high-priority data is an exceptional condition.
</li></ul><p>
The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/select.html"><span class="c001">select</span></a><a id="hevea_default109"></a> has the following signature:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALselect">select</a> :
    file_descr list -&gt; file_descr list -&gt; file_descr list -&gt;
      float -&gt; file_descr list * file_descr list * file_descr list</div><p>The first three arguments are sets of descriptors represented by
lists: the first argument is the set of descriptors to watch for read
events; the second argument is the set of descriptors to watch for
write events; the third argument is the set of descriptors to watch
for exceptional events. The fourth argument is a timeout in
seconds. If it is positive or zero, the call to <code>select</code> will return
after that time, even if no event occurred. If it is negative, the call
to <code>select</code> waits indefinitely until one of the requested events occurs.</p><p>The <code>select</code> call returns a triplet of descriptor lists: the first
component is the list of descriptors ready for reading, the second
component those ready for writing and the third one those on which an
exceptional condition occurred. If the timeout expires before any
event occurs, the three lists are empty.</p><div class="example">
<!--TOC paragraph id=sec116 Example-->
<h5 class="paragraph" id="sec116">Example</h5><!--SEC END --><p> 
The code below watches read events on the descriptors <code>fd1</code> and 
<code>fd2</code> and returns after 0.5 seconds. 
</p><div class="mylisting"><span class="c006">match</span> select [fd1; fd2] [] [] 0.5 <span class="c006">with</span>
| [], [], [] -&gt; <em>(* the 0,5s timeout expired *)</em>
| fdl, [], [] -&gt;
    <span class="c006">if</span> List.mem fd1 fdl <span class="c006">then</span>
         <em>(* read from fd1 *)</em>;
    <span class="c006">if</span> List.mem fd2 fdl <span class="c006">then</span>
         <em>(* read from fd2 *)</em></div><div class="fancybreak">* * *</div></div><div class="example">
<!--TOC paragraph id=sec117 Example-->
<h5 class="paragraph" id="sec117">Example</h5><!--SEC END --><p> 
The following <code>multiplex</code> function is central to the
multiplexer/demultiplexer of the multi-windowed terminal emulator
described above.</p><p>To simplify, the multiplexer just sets the receiver of messages
according to their provenance and the demultiplexer redirects data
directly to the receiver number. In other words, we assume that either
each sender talks to a receiver with the same number, or that the
correspondence between them is magically established in the middle of
the serial link by rewriting the receiver number.</p><p>The <code>multiplex</code> function takes a descriptor open on the serial port
and two arrays of descriptors of the same size, one containing pipes
connected to the standard input of the user processes, the other
containing pipes connected to their standard output.
</p><div class="mylisting"><span class="c006">open</span> Unix;;

<span class="c006">let rec</span> really_read fd buff start length =
  <span class="c006">if</span> length &lt;= 0 <span class="c006">then</span> () <span class="c006">else
    match</span> read fd buff start length <span class="c006">with</span>
    | 0 -&gt; raise End_of_file
    | n -&gt; really_read fd buff (start+n) (length-n);;

<span class="c006">let</span> buffer = String.create 258;;

<span class="c006">let</span> multiplex channel inputs outputs =
  <span class="c006">let</span> input_fds = channel :: Array.to_list inputs <span class="c006">in
  try
    while true do
      let</span> (ready_fds, _, _) = select input_fds [] [] (-1.0) <span class="c006">in
      for</span> i = 0 <span class="c006">to</span> Array.length inputs - 1 <span class="c006">do
        if</span> List.mem inputs.(i) ready_fds <span class="c006">then begin
          let</span> n = read inputs.(i) buffer 2 255 <span class="c006">in</span>
          buffer.[0] &lt;- char_of_int i;
          buffer.[1] &lt;- char_of_int n;
          ignore (write channel buffer 0 (n+2));
          ()
        <span class="c006">end
      done</span>;
      <span class="c006">if</span> List.mem channel ready_fds <span class="c006">then begin</span>
        really_read channel buffer 0 2;
        <span class="c006">let</span> i = int_of_char(buffer.[0])
        <span class="c006">and</span> n = int_of_char(buffer.[1]) <span class="c006">in
        if</span> n = 0 <span class="c006">then</span> close outputs.(i) <span class="c006">else
        begin</span>
          really_read channel buffer 0 n;
          ignore (write outputs.(i) buffer 0 n);
          ()
        <span class="c006">end
      end
    done
  with</span> End_of_file -&gt; () ;;</div><p>The <code>multiplex</code> function starts by constructing a set of
descriptors (<code>input_fds</code>) that contain the input descriptors
(those connected to the standard output of the user processes) and the
descriptor of the serial port. On each iteration of the 
<code><span class="c006">while</span></code> loop we call <code>select</code> to watch for pending reads in
<code>input_fds</code>. We do not watch for any write or exceptional event and
we do not limit the waiting time. When <code>select</code> returns, we test whether
there is data waiting on an input descriptor or on the serial port.</p><p>If there is data on an input descriptor we <code>read</code> this input into a
buffer, add a message header and write the result on the serial
port. If <code>read</code> returns zero this indicates that the corresponding
pipe was closed. The terminal emulator on the client will receive a
message with zero bytes, signaling that the user process
with that number died; it can then close the corresponding window.</p><p>If there is data on the serial port, we read the two-byte message
header which gives us the number <code>i</code> of the receiver and the number
<code>n</code> of bytes to read. We then read <code>n</code> bytes on the channel and
write them on the output <code>i</code> connected to the standard input of the
corresponding user process. However, if <code>n</code> is 0, we close the
output <span class="c004">i</span>. The idea is that the terminal emulator at the other end
sends a message with <code>n = 0</code> to indicate an end of file on the
standard input of the receiving user process.</p><p>We get out of the loop when <code>really_read</code> raises the exception
<code>End_of_file</code>, which indicates an end of file on the
serial port.
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id=sec118 Miscellaneous: <span class="c001">write</span>-->
<h2 class="section" id="sec118">5.7  Miscellaneous: <span class="c001">write</span></h2><!--SEC END --><p>The function <code>write</code> of the <code>Unix</code> module iterates the system call
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/write.html"><span class="c001">write</span></a><a id="hevea_default110"></a> until all the requested bytes are effectively written.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALwrite">write</a> : file_descr -&gt; string -&gt; int -&gt; int -&gt; int</div><p>However, when the descriptor is a pipe (or a socket, see
chapter <a href="#sec119">6</a>), writes may block and the system call
<code>write</code> may be interrupted by a signal. In this case the OCaml
call to <code>Unix.write</code> is interrupted and the error <code>EINTR</code> is
raised. The problem is that some of the data may already have been
written by a previous system call to <code>write</code> but the actual size
that was transferred is unknown and lost. This renders the function 
<code>write</code> of the <code>Unix</code> module useless in the presence of signals.</p><p>To address this problem, the <code>Unix</code> module also provides the
“raw” system call <code>write</code> under the name
<code>single_write</code>. 
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsingle_write">single_write</a> : file_descr -&gt; string -&gt; int -&gt; int -&gt; int</div><p>With <code>single_write</code>, if an error is raised it is guaranteed that no
data is written.</p><p>The rest of this section shows how to implement this
function. Fundamentally, it is just a matter of interfacing OCaml with
C (more information about this topic can be found in the relevant
section of the OCaml manual). The following code is written in the file
<code>single_write.c</code>:
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">#include</span> &lt;errno.h&gt;
<span class="c003">   2</span> <span class="c006">#include</span> &lt;string.h&gt;
<span class="c003">   3</span> <span class="c006">#include</span> &lt;caml/mlvalues.h&gt;
<span class="c003">   4</span> <span class="c006">#include</span> &lt;caml/memory.h&gt;
<span class="c003">   5</span> <span class="c006">#include</span> &lt;caml/signals.h&gt;
<span class="c003">   6</span> <span class="c006">#include</span> &lt;caml/unixsupport.h&gt;
<span class="c003">   7</span> 
<span class="c003">   8</span> CAMLprim value caml_single_write
<span class="c003">   9</span>         (value fd, value buf, value vofs, value vlen) {
<span class="c003">  10</span>   CAMLparam4(fd, buf, vofs, vlen);
<span class="c003">  11</span>   long ofs, len;
<span class="c003">  12</span>   int numbytes, ret;
<span class="c003">  13</span>   char iobuf[UNIX_BUFFER_SIZE];
<span class="c003">  14</span>   ofs = Long_val(vofs)
<span class="c003">  15</span>   len = Long_val(vlen)
<span class="c003">  16</span>   ret = 0;
<span class="c003">  17</span>   <span class="c006">if</span> (len &gt; 0) {
<span class="c003">  18</span>     numbytes = len &gt; UNIX_BUFFER_SIZE ? UNIX_BUFFER_SIZE : len;
<span class="c003">  19</span>     memmove (iobuf, &amp;Byte(buf, ofs), numbytes);
<span class="c003">  20</span>     caml_enter_blocking_section (); <a id="prog:enterbs"></a>
<span class="c003">  21</span>     ret = write(Int_val(fd), iobuf, numbytes);
<span class="c003">  22</span>     caml_leave_blocking_section (); <a id="prog:leavebs"></a>
<span class="c003">  23</span>     <span class="c006">if</span> (ret == -1) uerror("single_write", Nothing);
<span class="c003">  24</span>   }
<span class="c003">  25</span>   CAMLreturn (Val_int(ret));
<span class="c003">  26</span> }</div><p>The first two lines include standard C headers. The following four
lines include C headers specific to OCaml installed by the
distribution. The <code>unixsupport.h</code> header defines reusable C
functions of the OCaml Unix library.</p><p>The most important line is the call to <code>write</code>. Since the call may
block (if the descriptor is a pipe or a socket) we need to release the
global lock on the OCaml runtime immediately before the call
(line <a href="#prog%3Aenterbs">20</a>) and reacquire it right after
(line <a href="#prog%3Aleavebs">22</a>). This makes the function compatible with the
<code>Thread</code> module (see chapter <a href="#sec149">7</a>): it allows
other threads to execute during the blocking call. </p><p>During the system call OCaml may perform a garbage collection and
the address of the OCaml string <code>buf</code> may move in memory. To
solve this problem we copy <code>buf</code> into the C string <code>iobuf</code>.
This has an additional cost, but only in the order of magnitude of
10% (and not 50% as one might think) because the overall cost of the
function is dominated by the system call. The size of this C string is
defined in <code>unix_support.h</code>. If an error occurs during the system
call (indicated by a negative return value) it is propagated to
OCaml by the function <code>uerror</code>, defined in the OCaml Unix library.</p><p>To access this code from OCaml, the file <code>unix.mli</code> declares:


</p><div class="mylisting"><span class="c006">external</span> unsafe_single_write :
  file_descr -&gt; string -&gt; int -&gt; int -&gt; int = "caml_single_write"</div><p>But in practice we verify the arguments before calling the function: 
</p><div class="mylisting"><span class="c006">let</span> single_write fd buf ofs len =
  <span class="c006">if</span> ofs &lt; 0 || len &lt; 0 || ofs &gt; String.length buf - len
  <span class="c006">then</span> invalid_arg "Unix.write"
  <span class="c006">else</span> unsafe_single_write fd buf ofs len</div><p>This function has been available in the <code>Unix</code> module since version
<span class="c001">3.08</span>. But if we had written the program above ourselves we would
need to compile it as follows to use it (assuming the OCaml code is
in the files <code>write.mli</code> and <code>write.ml</code>):
</p><div class="mylisting">ocamlc -c single_write.c write.ml
ocamlc -custom -o prog unix.cma single_write.o write.cmo mod1.ml mod2.ml</div><p>It is often more practical to build a library <code>write.cma</code> containing
both the C and the OCaml code:
</p><div class="mylisting">ocamlc -custom -a -o write.cma single_write.o write.cmo</div><p>The library <code>write.cma</code> can then be used like <code>unix.cma</code>:
</p><div class="mylisting">ocamlc -o main.byte unix.cma write.cma main.ml</div><p>The semantics of <code>single_write</code> is as close as possible to the
system call <code>write</code>. The only remaining difference is when the
original string is very long (greater than <code>UNIX_BUFFER_SIZE</code>); the
call may then not write all the data and must be iterated. The
atomicity of <code>write</code> (guaranteed for regular files) is thus not
guaranteed for long writes. This difference is generally insignificant but one should
be aware of it.</p><p>On top of this function we can implement a higher-level function
<code>really_write</code>, analogous to the function <code>really_read</code> of the
multiplexer example, that writes exactly the requested amount of data
(but not atomically).

</p><div class="mylisting"><span class="c006">let rec</span> really_write fd buffer offset len =
  <span class="c006">let</span> n = restart_on_EINTR (single_write fd buffer offset) len <span class="c006">in
  if</span> n &lt; len <span class="c006">then</span> really_write fd buffer (offset + n) (len - n);;</div>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note7" href="#text7">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">The representation used by these functions is
unspecified but it is guaranteed to be platform-independent for a
particular version of the language.</div>
</dd></dl>
<!--END NOTES-->
<!--TOC chapter id=sec119 Modern communication: sockets-->
<h1 class="chapter" id="sec119"> 6  Modern communication: sockets</h1><!--SEC END --><!--NAME sockets.html-->
<p>Communication with pipes has some limitations. First, it is local to a
machine: with named pipes, communicating processes must run on the
same machine and what’s more, with anonymous pipes, they must share a
common ancestor. Furthermore, pipes are not very suitable for a
particularly useful model of communication: the <em>client-server</em>
model. In this model, only one program, the <em>server</em>, has direct
access to a shared resource. The other programs, the <em>clients</em>,
access the resource by connecting to the server. The server serializes
and controls the access to the shared resource. (Example: the
<span class="c005">x</span>-window windowing system — the shared resources are
the screen, the keyboard and the mouse.)</p><p>The client-server model is difficult to implement with pipes. The
major difficulty is to establish the connection between a client and
the server. With anonymous pipes, it is impossible: the server and the
client would need a common ancestor that allocated an arbitrarily
large number of pipes in advance. With named pipes, the server could
read connection requests on a particular pipe. These requests would
contain the name of another named pipe created and used by the client
to communicate with the server. The problem is to ensure the mutual
exclusion of simultaneous connection requests performed by multiple
clients.</p><p>Sockets are a generalization of pipes addressing these issues. The
client-server model is shown in figure <a href="#fig%2Fclient-server">3</a>.</p><div class="figure">
<div class="image"><img src="ocamlunix-image20.png" width="70%"></div>



<a id="fig/client-server"></a>
<div class="caption">Figure 3 — Client-Server model</div></div><ol class="enumerate" type=1><li class="li-enumerate">
The server <span class="c004">U</span> creates a socket <span class="c004">s</span> on a port <span class="c004">p</span> known to the clients and
waits for connections on it (1).
</li><li class="li-enumerate">The client <span class="c004">A</span> creates a socket and connects to the server on the port
<span class="c004">p</span> (2). On the server, the system allocates a new socket to
communicate privately with
the client <span class="c004">A</span> (3). In this example, the server forks off an auxiliary
server <span class="c004">V</span> (4), closes its connection with the client <span class="c004">A</span> (represented by the
dashed line) and lets its child <span class="c004">V</span> handle the connection with <span class="c004">A</span> (5).
</li><li class="li-enumerate">The server can then accept a new client <span class="c004">B</span>, establish another
connection handled in parallel by another clone <span class="c004">W</span> (6), and so on.
</li><li class="li-enumerate">The server can close its service by closing the file descriptor
associated with the socket <span class="c004">s</span>. After a while the system frees the
port <span class="c004">p</span> which can then be reused, for example to install another
service.</li></ol><p>In the model described above, the server <span class="c004">U</span> and the client <span class="c004">A</span>
establish a private connection (3) to communicate without interference
from other clients. For that reason, this mode of communication is
referred to as the <em>connection-oriented</em> mode. If the transaction
is short the server can handle the request directly (without forking)
through the connection (3). In this case, the next client must wait
for the server to be available, either because it is handling the
connection (3), or because it explicitly manages several connections
via multiplexing.</p><p>Sockets also allow a <em>connectionless</em> communication mode. In
this mode, less frequently used, the server does not establish a
private connection with the client, but responds directly to the
client’s requests. We will briefly comment on this model in
section <a href="#sec132">6.10</a> but in the remainder of this
chapter, we mainly describe <em>connection-oriented</em> communication.</p>
<!--TOC section id=sec120 Sockets-->
<h2 class="section" id="sec120">6.1  Sockets</h2><!--SEC END --><p>Sockets, an extension of pipes, were introduced in <span class="c005">bsd</span>
4.2. They are now found on all Unix machines connected to a
network. Special system calls are provided to establish connections
following the client-server model; they enable local and remote
communication between processes in a (nearly) transparent way.</p><p>The <em>communication domain</em> of a socket limits the processes (and
the format of their address) with which we can communicate on the
socket. Different communication domains are available, for example:
</p><ul class="itemize"><li class="li-itemize">
the Unix domain: an address is a name in the file system
of a machine. Communication is limited to processes
running on that machine (like with pipes).
</li><li class="li-itemize">the Internet domain: an address is an address of a
machine on the Internet network (addresses of the form
<code>129.199.129.1</code>, for example) and a port number on that
machine. Communication is possible between processes running on any
two machines connected to Internet.<sup><a id="text8" href="#note8">1</a></sup>
</li></ul><p>The <em>communication type</em> of a socket indicates whether
communication is reliable (no loss or duplication of data) and the way
the data is sent and received (a stream of bytes, or a sequence of
packets — small blocks of bytes). The communication type
constrains the protocol used to transmit data. Different communication
types are available, here are three of them with their properties:
</p><div class="center">
<table class="c000 cellpading0"><tr><td class="c010">Type</td><td class="c010">Reliable</td><td class="c010">Data representation </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c010">Stream</td><td class="c010">yes</td><td class="c010">byte stream </td></tr>
<tr><td class="c010">Datagram</td><td class="c010">no</td><td class="c010">packets </td></tr>
<tr><td class="c010">Segmented packets</td><td class="c010">yes</td><td class="c010">packets </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>
</div><p>
The “stream” type is very similar to communication with pipes.
It is used most frequently, in particular to transmit unstructured
byte sequences (e.g. <code>rsh</code>). The “segmented packets” type
transmits data as packets: each write delimits a packet, each read
returns at most a packet. It is well suited for message-oriented
communication. The “datagram” type is the closest to the
hardware properties of an Ethernet network: data is transmitted with
packets and there is no guarantee that they reach their
destination. It is the most economical type in terms of network
resources. Some programs use it to transmit data that is not of
crucial importance (e.g. <code>biff</code>); others, to get more network
performance but with the burden of managing data losses manually. </p>
<!--TOC section id=sec121 Socket creation-->
<h2 class="section" id="sec121">6.2  Socket creation</h2><!--SEC END --><p>The <a href="http://www.opengroup.org/onlinepubs/009696799/functions/socket.html"><span class="c001">socket</span></a><a id="hevea_default111"></a> system creates a new socket:

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsocket">socket</a> : socket_domain -&gt; socket_type -&gt; int -&gt; file_descr</div><p>The result is a file descriptor that represents the new
socket. Initially, this descriptor is “disconnected”, 
it is not ready to accept any <code>read</code> or <code>write</code>. </p><p>The first argument is a value of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsocket_domain"><span class="c001">socket_domain</span></a>, it
specifies the socket’s communication domain:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>PF_UNIX</code></td><td class="c010">The Unix domain. </td></tr>
<tr><td class="c010"><code>PF_INET</code></td><td class="c010">The Internet domain.
</td></tr>
</table>
</div><p>
The second argument, a value of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsocket_type"><span class="c001">socket_type</span></a>,
specifies the desired communication type:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>SOCK_STREAM</code></td><td class="c010">Byte streams, reliable. </td></tr>
<tr><td class="c010"><code>SOCK_DGRAM</code></td><td class="c010">Packets, unreliable. </td></tr>
<tr><td class="c010"><code>SOCK_RAW</code></td><td class="c010">Direct access to the lower layers of the network. </td></tr>
<tr><td class="c010"><code>SOCK_SEQPACKET</code></td><td class="c010">Packets, reliable.
</td></tr>
</table>
</div><p>
The third argument is the communication protocol to use. It is usually
<code>0</code> which selects the default protocol for the given communication
domain and type (e.g. <span class="c005">udp</span> for <code>SOCK_DGRAM</code> or
<span class="c005">tcp</span> for <code>SOCK_STREAM</code>). Other values allow to use special
protocols, for example <span class="c005">icmp</span> (<em>Internet Control Message
Protocol</em>) used by the <code>ping</code> command to send packets which
return automatically to the sender. The numbers for these special protocols
are in the <code>/etc/protocols</code> file or in the <code>protocols</code> table of
the <span class="c005">nis</span> (<em>Network Information Service</em>) database, if
any. The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getprotobyname.html"><span class="c001">getprotobyname</span></a><a id="hevea_default112"></a> returns information about a
protocol in a portable manner: 

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetprotobyname">getprotobyname</a> : string -&gt; protocol_entry</div><p>Given the name of a protocol the result is a record 
of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEprotocol_entry"><span class="c001">protocol_entry</span></a>. The <code>p_proto</code> field of
this record has the protocol number.</p>
<!--TOC section id=sec122 Addresses-->
<h2 class="section" id="sec122">6.3  Addresses</h2><!--SEC END --><p>Several socket operations use socket addresses, represented by the variant
type <code>sockaddr</code>:
</p><div class="mylisting"><span class="c006">type</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEsockaddr">sockaddr</a> =
  | ADDR_UNIX <span class="c006">of</span> string
  | ADDR_INET <span class="c006">of</span> inet_addr * int</div><p><code>ADDR_UNIX f</code> is an address in the Unix domain, <code>f</code> is
the name of the corresponding file in the machine’s file
system. <code>ADDR_INET (a,p)</code> is an address in the Internet domain,
<code>a</code> is the Internet address of a machine and <code>p</code> a port
number on this machine.</p><p>Internet addresses are represented by the abstract type
<code>inet_addr</code>. The following functions convert strings of the form
<code>128.93.8.2</code> to values of type <code>inet_addr</code>, and vice versa:

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALinet_addr_of_string">inet_addr_of_string</a><a id="hevea_default113"></a> : string -&gt; inet_addr
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALstring_of_inet_addr">string_of_inet_addr</a><a id="hevea_default114"></a> : inet_addr -&gt; string</div><p>Another way to obtain internet addresses is to look them up by host name in
the <code>/etc/hosts</code> table, the <span class="c005">nis</span> database or in domain name
servers. The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/gethostbyname.html"><span class="c001">gethostbyname</span></a><a id="hevea_default115"></a> does that. On
modern machines, the domain name servers are consulted first and
<code>/etc/hosts</code> is only used as a fallback but in general that may
depend on the machine’s configuration.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgethostbyname">gethostbyname</a> : string -&gt; host_entry</div><p>The argument is the host name to look for and the result a record of
type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEhost_entry"><span class="c001">host_entry</span></a>. The <code>h_addr_list</code> field of this
record is an array of Internet addresses corresponding to the machine
(the same machine can be connected to multiple networks under
different addresses).</p><p>Regarding port numbers, the most common services are listed in the
table <code>/etc/services</code> which can be read in a portable manner using
the <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getservbyname.html"><span class="c001">getservbyname</span></a><a id="hevea_default116"></a> function:

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetservbyname">getservbyname</a> : string -&gt; string -&gt; service_entry</div><p>The first argument is the service name (<code>"ftp"</code> for <span class="c005">ftp</span>
servers, <code>"smtp"</code> for email, <code>"nntp"</code> for news servers,
<code>"talk"</code> and <code>"ntalk"</code> for commands of that name, etc.) and the
second argument is the name of the protocol: usually <code>"tcp"</code> if the
service is using the stream connection type or <code>"udp"</code> for the
datagram type. The result of <code>getservbyname</code> is a record of type
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEservice_entry"><span class="c001">service_entry</span></a> whose <code>s_port</code> field contains the
desired number.</p><div class="example">
<!--TOC paragraph id=sec123 Example-->
<h5 class="paragraph" id="sec123">Example</h5><!--SEC END --><p> To obtain the address of the <span class="c005">ftp</span> server
<code>pauillac.inria.fr</code>:
</p><div class="mylisting">ADDR_INET((gethostbyname "pauillac.inria.fr").h_addr_list.(0),
          (getservbyname "ftp" "tcp").s_port)</div><div class="fancybreak">* * *</div></div>
<!--TOC section id=sec124 Connection to a server-->
<h2 class="section" id="sec124">6.4  Connection to a server</h2><!--SEC END --><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/connect.html"><span class="c001">connect</span></a><a id="hevea_default117"></a> establishes a connection with a
server on a socket. 

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALconnect">connect</a> : file_descr -&gt; sockaddr -&gt; unit</div><p>The first argument is a socket descriptor and the second argument is
the server’s address.</p><p>Once the connection is established, calls to <span class="c001">write</span><a id="hevea_default118"></a> on the
socket descriptor send data to the server and calls to <span class="c001">read</span><a id="hevea_default119"></a>
receive data from the server. Sockets behave like pipes for read and
write operations. First, <code>read</code> blocks if no data is available and
can return fewer bytes than requested. Second, whenever the server
closes the connection <code>read</code> returns <code>0</code> and <code>write</code> sends a
<code>sigpipe</code> signal to the calling process.</p><p><code>connect</code> binds the socket to a local address chosen by the
system. Sometimes, it is preferable to manually choose this address.
This can be done by calling the function <code>bind</code> (see
section <a href="#sec127">6.7</a>) before <code>connect</code>.</p><p>The <code>netstat</code> Unix command lists the current connections on the
machine and their status.</p>
<!--TOC section id=sec125 Disconnecting sockets-->
<h2 class="section" id="sec125">6.5  Disconnecting sockets</h2><!--SEC END --><p>There are two ways to disconnect a socket. The first is to
call <span class="c001">close</span><a id="hevea_default120"></a> on the socket. This closes the read and write
sides of the connection, and deallocates the socket. But sometimes
this is too brutal, for example we may want to close the connection
from the client to the server to indicate an end of file but keep the
connection open in the other direction to get remaining data from the
server. The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/shutdown.html"><span class="c001">shutdown</span></a><a id="hevea_default121"></a> allows to close the
connection gradually.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALshutdown">shutdown</a> : file_descr -&gt; shutdown_command -&gt; unit</div><p>The first argument is the descriptor of the socket to close and the
second a value of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEshutdown_command"><span class="c001">shutdown_command</span></a> indicating
which direction to close:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c013"><code>SHUTDOWN_RECEIVE</code></td><td class="c012">Closes the socket for reading; <code>write</code>
on the other end of the connection will send a <code>sigpipe</code> signal to
the caller. </td></tr>
<tr><td class="c013"><code>SHUTDOWN_SEND</code></td><td class="c012">Closes the socket for writing; <code>read</code> on the
other end of the connection returns an end of file. </td></tr>
<tr><td class="c013"><code>SHUTDOWN_ALL</code></td><td class="c012">Closes the socket for reading and writing;
unlike <code>close</code>, the socket descriptor is not deallocated.
</td></tr>
</table>
</div><p>
Note that disconnecting a socket can take some time whether done with
<code>close</code> or <code>shutdown</code>.</p>
<!--TOC section id=sec126 Complete example: the universal client-->
<h2 class="section" id="sec126">6.6  Complete example: the universal client</h2><!--SEC END --><p>We program a <code>client</code> command such that <code>client host port</code>
establishes a connection on the port <code>port</code> of the machine named
<code>host</code>, sends on the resulting socket the data it reads on its
standard input and writes the data it receives on its standard output.
For instance, the command
</p><div class="mylisting">echo -e 'GET /~remy/ HTTP/1.0\r\n\r\n' | ./client pauillac.inria.fr 80</div><p>connects to the port <code>80</code> of <code>pauillac.inria.fr</code> and sends an
<span class="c005">http</span> request for the web page <code>/~remy/</code>.</p><p>This command is a “universal” client application in the sense
that it factors out the code to establish a connection common to many
clients and delegates the implementation of the specific protocol to
the program that calls <code>client</code>.</p><p>The library function <code>Misc.retransmit fdin fdout</code> reads data on the
descriptor <code>fdin</code> and writes it on <code>fdout</code>. It terminates,
without closing the descriptors, when the end of file is reached on
the input descriptor. Note that <code>retransmit</code> may be interrupted by
a signal.

</p><div class="mylisting"><span class="c006">let</span> retransmit fdin fdout =
  <span class="c006">let</span> buffer_size = 4096 <span class="c006">in
  let</span> buffer = String.create buffer_size <span class="c006">in
  let rec</span> copy () = <span class="c006">match</span> read fdin buffer 0 buffer_size <span class="c006">with</span>
    | 0 -&gt; ()
    | n -&gt; ignore (write fdout buffer 0 n); copy ()
  <span class="c006">in</span>
  copy ();;</div><p>The serious matter starts here.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">open</span> Sys;;
<span class="c003">   2</span> <span class="c006">open</span> Unix;;
<span class="c003">   3</span> 
<span class="c003">   4</span> <span class="c006">let</span> client () =
<span class="c003">   5</span>   <span class="c006">if</span> Array.length Sys.argv &lt; 3 <span class="c006">then begin</span>
<span class="c003">   6</span>     prerr_endline "Usage: client &lt;host&gt; &lt;port&gt;";
<span class="c003">   7</span>     exit 2;
<span class="c003">   8</span>   <span class="c006">end</span>;
<span class="c003">   9</span>   <span class="c006">let</span> server_name = Sys.argv.(1)
<span class="c003">  10</span>   <span class="c006">and</span> port_number = int_of_string Sys.argv.(2) <span class="c006">in</span>
<span class="c003">  11</span>   <span class="c006">let</span> server_addr =
<span class="c003">  12</span>     <span class="c006">try</span> (gethostbyname server_name).h_addr_list.(0)
<span class="c003">  13</span>     <span class="c006">with</span> Not_found -&gt;
<span class="c003">  14</span>       prerr_endline (server_name ^ ": Host not found");
<span class="c003">  15</span>       exit 2 <span class="c006">in</span>
<span class="c003">  16</span>   <span class="c006">let</span> sock = socket PF_INET SOCK_STREAM 0 <span class="c006">in</span>
<span class="c003">  17</span>   connect sock (ADDR_INET(server_addr, port_number));
<span class="c003">  18</span>   <span class="c006">match</span> fork () <span class="c006">with</span>
<span class="c003">  19</span>   | 0 -&gt; <a id="prog:add_signal_ignore"></a>
<span class="c003">  20</span>       Misc.retransmit stdin sock;
<span class="c003">  21</span>       shutdown sock SHUTDOWN_SEND;
<span class="c003">  22</span>       exit 0
<span class="c003">  23</span>   | _ -&gt;
<span class="c003">  24</span>       Misc.retransmit sock stdout;
<span class="c003">  25</span>       close stdout;
<span class="c003">  26</span>       wait ();;
<span class="c003">  27</span> 
<span class="c003">  28</span> handle_unix_error client ();;</div><p>We start by determining the Internet address of the machine to which
we want to connect. It can be specified by a host name or in numerical
form, <code>gethostbyname</code> correctly handles both cases. Then, we create
a socket of type stream in the Internet domain with the default protocol
and connect it to the address of the machine.</p><p>The process is then cloned with <code>fork</code>. The child process copies
the data from its standard input to the socket. Once the end of
standard input is reached it closes the connection in the sending
direction and terminates. The parent process copies the data it reads
on the socket to its standard output. Once the end of file is reached
on the socket, it closes the standard output, synchronizes with the
child process and terminates.</p><p>The connection is closed either by the client or by the server:
</p><ul class="itemize"><li class="li-itemize">
If the child client receives an end of file on its standard
input, it closes the connection in the client to server direction
and terminates. The server upon receiving the end of file on its
socket should, possibly after some further processing, close the
connection in the other direction. Thus the parent client eventually
receives an end of file on the socket and terminates normally.
</li><li class="li-itemize">If the server closes the connection. The parent client receives
an end of file on the socket and waits on the child. The
child client is killed by a <code>sigpipe</code> signal the next time it
tries to write on the socket. This does not however report that the
connection was lost. If that is needed we can ignore
the <code>sigpipe</code> signal by inserting the following line after
line <a href="#prog%3Aadd_signal_ignore">19</a>:
<div class="mylisting">ignore (signal sigpipe Signal_ignore)</div><p>and the write will raise an <code>EPIPE</code> error instead.
</p></li><li class="li-itemize">If the parent or child client exits prematurely the socket will
be closed for reading or writing. 
Whenever the server detects this information, it closes its
side of the connection, which is eventually detected by the other part of the
client. 
</li></ul>
<!--TOC section id=sec127 Establishing a service-->
<h2 class="section" id="sec127">6.7  Establishing a service</h2><!--SEC END --><p>Having seen how a client connects to a server, we now show how a
server can provide a service for clients. First we need to associate a
particular address to a socket to make it reachable from the network.
The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/bind.html"><span class="c001">bind</span></a><a id="hevea_default122"></a> does this:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALbind">bind</a> : file_descr -&gt; sockaddr -&gt; unit</div><p>The first argument is the socket descriptor and the second the address
to bind. The constant Internet address <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALinet_addr_any"><span class="c001">inet_addr_any</span></a> can be
used to bind all the Internet addresses that the machine has (it may
be on multiple sub-networks).</p><p>We then indicate that the socket can accept connections with the
system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/listen.html"><span class="c001">listen</span></a><a id="hevea_default123"></a>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALlisten">listen</a> : file_descr -&gt; int -&gt; unit</div><p>The first argument is the socket descriptor and the second is the
number of request that can be be put on hold while the server is busy
(ranges from a few dozen to several hundreds for large servers). When
the number of waiting clients exceeds this number, additional client 
connection requests fail.</p><p>Finally, connection requests on a socket descriptor are received via the 
system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/accept.html"><span class="c001">accept</span></a><a id="hevea_default124"></a>:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALaccept">accept</a> : file_descr -&gt; file_descr * sockaddr</div><p>When the call returns the socket given in argument is still free and
can accept more connection request. The first component of the result
is a new descriptor connected to the client, everything written
(resp. read) on that socket can be read (resp. is written) on the
socket the client gave to <code>connect</code>. The second component of the
result is the address of the client. It can be used to check that the
client is authorized to connect (for example this is what the
<span class="c005">x</span> server does, <code>xhost</code> can be used to add new
authorizations), or to establish a second connection from the server
to the client (as <span class="c005">ftp</span> does for each file transfer request).</p><p>The general structure of a <span class="c005">tcp</span> server is as follows.

</p><div class="mylisting"><span class="c006">let</span> install_tcp_server_socket addr =
  <span class="c006">let</span> s = socket PF_INET SOCK_STREAM 0 <span class="c006">in
  try</span>
    bind s addr;
    listen s 10;
    s
  <span class="c006">with</span> z -&gt; close s; raise z;;</div><p>The library function <code>Misc.install_tcp_server addr</code> creates a
socket of type stream in the Internet domain with the default protocol 
and prepares it to accept new connection requests on the address <code>addr</code>
with <code>bind</code> and <code>listen</code>. Given that this is a library
function, we close the socket in case of an error.</p><div class="mylisting"><span class="c006">let</span> tcp_server treat_connection addr =
  ignore (signal sigpipe Signal_ignore);
  <span class="c006">let</span> server_sock = install_tcp_server_socket addr <span class="c006">in
  while true do
      let</span> client = restart_on_EINTR accept server_sock <span class="c006">in</span>
      treat_connection server_sock client
  <span class="c006">done</span>;;</div><p>The library function <code>Misc.tcp_server</code> creates a socket with
<code>install_tcp_server</code> and enters an infinite loop. At each iteration
of the loop it waits for a connection request with <code>accept</code> and
treats it with the function <code>treat_connection</code>. Since this is a
library function we restart the <code>accept</code> call if it is
interrupted. We also ignore the signal <code>sigpipe</code> so that unexpected
disconnection raise an <code>EPIPE</code> exception that can be caught by
<code>treat_connection</code> rather than killing the server. Note that it in
any case it is <code>treat_connection</code>’s duty to close the <code>client</code>
descriptor at the end of the connection.</p><p>The function <code>treat_connection</code> is also given the descriptor of the
server so that if it <code>fork</code>s or or <code>double_fork</code>s it can be
closed by the child.</p><p>Now suppose we have the following, application specific, <code>service</code>
function that talks to the client end ends by closing the connection:
</p><div class="mylisting"><span class="c006">let</span> service (client_sock, client_addr) =
  <em>(* Handle the client on the descriptor client_sock *)
  (* And when we are done: *)</em>
  close client_sock;;</div><p>The server itself can treat each connection sequentially. The
following library function, in <code>Misc</code>, captures this pattern:

</p><div class="mylisting"><span class="c006">let</span> sequential_treatment server service client = service client</div><p>However as the server cannot handle any other requests while serving a client,
this scheme is only appropriate for quick services, where the
<code>service</code> function always runs in a short, bounded, amount of time (for
instance, a date server).
</p><p>Most servers delegate the service to a child process: <code>fork</code> is called
immediately after <code>accept</code> returns. The child process handles the
connection and the parent process immediately retries to <code>accept</code>. We
obtain the following library function in <code>Misc</code>:

</p><div class="mylisting"><span class="c006">let</span> fork_treatment server service (client_sock, _ <span class="c006">as</span> client) =
  <span class="c006">let</span> treat () = <span class="c006">match</span> fork () <span class="c006">with</span>
    | 0 -&gt; close server; service client; exit 0
    | k -&gt; ()
  <span class="c006">in</span>
  try_finalize treat () close client_sock;;</div><p>Note that it is essential that the parent closes <code>client_sock</code>
otherwise the close made by the child will not terminate the
connection (besides the parent would also quickly run out of
descriptors). The descriptor is also closed if the fork fails, for the
server may eventually decide the error is not fatal and continue to
operate.</p><p>Similarly, the child immediately closes the <code>server</code> descriptor on
which the connection request was received. First, it does not need
it. Second, the server may stop accepting new connections before
the child has terminated. The call to <code>exit 0</code> is important since
it ensures that the child terminates after the execution of the
service and that it does not start to execute the server loop.</p><p>So far we ignored the fact that children will become zombie processes
and that we need to recover them. There are two ways to to so. The
simple approach is to have a grandchild process handle the connection
using a double fork (see page <a href="#double-fork">??</a>). This gives the
following library function, also in <code>Misc</code>:

</p><div class="mylisting"><span class="c006">let</span> double_fork_treatment server service (client_descr, _ <span class="c006">as</span> client) =
  <span class="c006">let</span> treat () = <span class="c006">match</span> fork () <span class="c006">with</span>
    | 0 -&gt;
        <span class="c006">if</span> fork () &lt;&gt; 0 <span class="c006">then</span> exit 0;
        close server; service client; exit 0
    | k -&gt;
        ignore (restart_on_EINTR (waitpid []) k)
  <span class="c006">in</span>
  try_finalize treat () close client_descr;;</div><p>However with this approach the server loses all control on the
grandchild process. It is better to have the processes handling
services and the server in the same process group so that the whole
group can be killed at once to terminate the service. For this reason servers
usually keep the fork treatment but add children recovering code, for
example in the handler of the <code>sigchld</code> signal (see the function
<code>Misc.free_children</code> on page <a href="#ex%2Fchilds">??</a>).</p>
<!--TOC section id=sec128 Tuning sockets-->
<h2 class="section" id="sec128">6.8  Tuning sockets</h2><!--SEC END --><p>Sockets have numerous internal parameters that can be tuned: the size
of the transfer buffer, the size of the minimum transfer, the behavior
on closing, etc.</p><p>These parameters have different types, for this reason there are as
many <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetsockopt"><span class="c001">getsockopt</span></a> and <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsetsockopt"><span class="c001">setsockopt</span></a>
OCaml functions as there are types. Consult the OCaml
documentation of the function <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgetsockopt"><span class="c001">getsockopt</span></a> and its variants
to get a detailed list of those options and the <span class="c005">posix</span>
reference for <a href="http://www.opengroup.org/onlinepubs/009696799/functions/getsockopt.html"><span class="c001">getsockopt</span></a><a id="hevea_default125"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/setsockopt.html"><span class="c001">setsockopt</span></a><a id="hevea_default126"></a> for their
exact meaning.</p><div class="example">
<!--TOC paragraph id=sec129 Example-->
<h5 class="paragraph" id="sec129">Example</h5><!--SEC END --><p> 
The following two parameters apply only to sockets of type stream in the
Internet domain.</p><p>In the <span class="c005">tcp</span> protocol, the disconnection of a socket is
negotiated and hence takes some time. Normally a call to
<span class="c001">close</span><a id="hevea_default127"></a> returns immediately, and lets the system
negotiates the disconnection. The code below turns <code>close</code> on the
socket <code>sock</code> into a blocking operation. It blocks either
until all the sent data has been transmitted or until 5 seconds have
passed.
</p><div class="mylisting">setsockopt_optint sock SO_LINGER (Some 5);;</div><p>The <code>SO_REUSEADDR</code> option allows the <span class="c001">bind</span><a id="hevea_default128"></a> system call
to allocate a new socket on a local address immediately after the
socket <code>sock</code> bound on that address is closed (there is however the
risk to get packets intended for the old connection). This option
allows to stop a server and restart it immediately, very useful for
testing purposes.
</p><div class="mylisting">setsockopt sock SO_REUSEADDR;;</div><div class="fancybreak">* * *</div></div>
<!--TOC section id=sec130 Complete example: the universal server-->
<h2 class="section" id="sec130">6.9  Complete example: the universal server</h2><!--SEC END --><p>We program a <code>server</code> command such that:
</p><div class="mylisting">./server port cmd arg1 ... argn</div><p>receives connection requests on the port <code>port</code> and, for each
connection, executes <code>cmd</code> with the arguments <code>arg1 ... argn</code>
and the socket connection as its standard input and output. For
example, if we execute:
</p><div class="mylisting">./server 8500 grep foo</div><p>on the <code>pomerol</code> machine and the universal client (see
section <a href="#sec126">6.6</a>) on an other machine as follows:
</p><div class="mylisting">./client pomerol 8500 &lt; /etc/passwd</div><p>the client displays the same result as if we had typed:
</p><div class="mylisting">grep foo &lt; /etc/passwd</div><p>except that <code>grep</code> is executed on <code>pomerol</code>, and not on the local machine.</p><p>This command is a “universal” server in the sense that it factors
out the code common to many server and delegates the implementation of
the specific service and communication protocol to the <code>cmd</code> program it
launches.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">open</span> Sys;;
<span class="c003">   2</span> <span class="c006">open</span> Unix;;
<span class="c003">   3</span> 
<span class="c003">   4</span> <span class="c006">let</span> server () =
<span class="c003">   5</span>   <span class="c006">if</span> Array.length Sys.argv &lt; 2 <span class="c006">then begin</span>
<span class="c003">   6</span>     prerr_endline "Usage: client &lt;port&gt; &lt;command&gt; [arg1 ... argn]";
<span class="c003">   7</span>     exit 2;
<span class="c003">   8</span>   <span class="c006">end</span>;
<span class="c003">   9</span>   <span class="c006">let</span> port = int_of_string Sys.argv.(1) <span class="c006">in</span>
<span class="c003">  10</span>   <span class="c006">let</span> args = Array.sub Sys.argv 2 (Array.length Sys.argv - 2) <span class="c006">in</span>
<span class="c003">  11</span>   <span class="c006">let</span> host = (gethostbyname(gethostname ())).h_addr_list.(0) <span class="c006">in</span> <a id="prog:gethost"></a>
<span class="c003">  12</span>   <span class="c006">let</span> addr = ADDR_INET (host, port) <span class="c006">in</span>
<span class="c003">  13</span>   <span class="c006">let</span> treat sock (client_sock, client_addr <span class="c006">as</span> client) =
<span class="c003">  14</span>     <em>(* log information *)</em>
<span class="c003">  15</span>     <span class="c006">begin match</span> client_addr <span class="c006">with</span>
<span class="c003">  16</span>     | ADDR_INET(caller, _) -&gt;
<span class="c003">  17</span>         prerr_endline ("Connection from " ^ string_of_inet_addr caller);
<span class="c003">  18</span>     | ADDR_UNIX _ -&gt;
<span class="c003">  19</span>         prerr_endline "Connection from the Unix domain (???)";
<span class="c003">  20</span>     <span class="c006">end</span>;
<span class="c003">  21</span>     <em>(* connection treatment *)</em>
<span class="c003">  22</span>     <span class="c006">let</span> service (s, _) =
<span class="c003">  23</span>       dup2 s stdin; dup2 s stdout; dup2 s stderr; close s;
<span class="c003">  24</span>       execvp args.(0) args
<span class="c003">  25</span>     <span class="c006">in</span>
<span class="c003">  26</span>     Misc.double_fork_treatment sock service client <span class="c006">in</span>
<span class="c003">  27</span>   Misc.tcp_server treat addr;;
<span class="c003">  28</span> 
<span class="c003">  29</span> handle_unix_error server ();;</div><p>The address given to <code>tcp_server</code> contains the Internet address
of the machine running the program; the usual way to get it
(line <a href="#prog%3Agethost">11</a>) is by calling
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALgethostname"><span class="c001">gethostname</span></a><a id="hevea_default129"></a>. But in general many addresses are
referencing the same machine. For instance, the address of the
<code>pauillac</code> machine is <code>128.93.11.35</code>, it can also be accessed
locally (provided we are already on the <code>pauillac</code> machine) with
the address <code>127.0.0.1</code>. To provide a service on all the addresses
pointing to this machine, we can use the constant Internet address
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALinet_addr_any"><span class="c001">inet_addr_any</span></a>.</p><p>The service is handled by a “double fork”. The <code>service</code>
function, executed by the child, redirects standard input and the two
standard output on the connection socket and executes the requested
command (note that the handling of the service cannot be done
sequentially).</p><p>The connection is closed without any intervention of the <code>server</code>
program. One of the following cases occurs:
</p><ul class="itemize"><li class="li-itemize">
The client closes the connection in the client to server
direction. The command launched by the server receives an end of
file on its standard input. It finishes what it has to do, and calls
<code>exit</code> when it is done. This closes the standard outputs which
are the last descriptors open for writing on the connection and the
client receives an end of file on its socket.</li><li class="li-itemize">The client ends prematurely and closes the connection in the
server to client direction. The command launched by the server may
then receive a <code>sigpipe</code> signal the next time it tries to write
data on the connection. This may kill the process but is perfectly
acceptable since nothing is now reading the output of this command.</li><li class="li-itemize">The command launched by the server exits before having read the
end of file on its input. The client receives a <code>sigpipe</code> signal
(or an <code>EPIPE</code> exception) when it tries to write on the
connection.
</li></ul><!--TOC subsection id=sec131 Precautions-->
<h3 class="subsection" id="sec131">Precautions</h3><!--SEC END --><p>Writing a server requires more care than writing a client. While the
client usually knows the server to which it connects, the server knows
nothing about its clients and particularly if the service is public,
the client can be “hostile”. The server must therefore guard
itself against all pathological cases.</p><p>A typical attack is to open connections and leave them open without
transmitting requests. After accepting the connection the server is
blocked on the socket as long as the client stays connected. An
attacker can saturate the service by opening a lot of unused
connections. The server must be robust against these attacks: it must
only accept a limited number of simultaneous connections to avoid
system resources exhaustion and it must terminate connections that
remain inactive for too long. </p><p>A sequential server handling connections without forking is
immediately exposed to this blocking issue. It will be unresponsive for
further request even though it does nothing. A solution for a
sequential server is to multiplex the connections, but it can be
tricky to implement. The solution with a parallel server is more
elegant, but it still needs a timeout, for example by programming an alarm
(see section <a href="#sec80">4.2</a>).</p>
<!--TOC section id=sec132 Communication in connectionless mode-->
<h2 class="section" id="sec132">6.10  Communication in connectionless mode</h2><!--SEC END --><p>The <span class="c005">tcp</span> protocol used by most connections of type
<code>SOCK_STREAM</code> works only in connection-oriented mode. Conversely,
the <span class="c005">udp</span> protocol used by most connections of type
<code>SOCK_DGRAM</code> always works in connectionless mode, there is
no established connection between the two machines. For this type of
sockets, data is transmitted with the system calls <a href="http://www.opengroup.org/onlinepubs/009696799/functions/recvfrom.html"><span class="c001">recvfrom</span></a><a id="hevea_default130"></a> 
and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/sendto.html"><span class="c001">sendto</span></a><a id="hevea_default131"></a>.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrecvfrom">recvfrom</a> :
  file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; int * sockaddr

<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsendto">sendto</a> :
  file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; sockaddr -&gt; int</div><p>Their interface is similar to <code>read</code> and <code>write</code>, they
return the size of the transferred data. The
call <code>recvfrom</code> also returns the address of the sending machine.</p><p>We can call <span class="c001">connect</span><a id="hevea_default132"></a> on a socket of type <code>SOCK_DGRAM</code>
to obtain a pseudo-connection. This pseudo-connection is just an
illusion, the only effect is that the address passed in argument is
memorized by the socket and becomes the address used for sending and
receiving data (messages coming from other addresses are ignored). It
is possible to call <code>connect</code> more than once to change the address
or disconnect the pseudo-connection by connecting to an invalid
address like <code>0</code>. In contrast, doing this with a socket of type stream
would generally issue an error.</p>
<!--TOC section id=sec133 Low level reads and writes-->
<h2 class="section" id="sec133">6.11  Low level reads and writes</h2><!--SEC END --><p>The system calls <a href="http://www.opengroup.org/onlinepubs/009696799/functions/recv.html"><span class="c001">recv</span></a><a id="hevea_default133"></a> and <a href="http://www.opengroup.org/onlinepubs/009696799/functions/send.html"><span class="c001">send</span></a><a id="hevea_default134"></a> respectively
generalize <span class="c001">read</span><a id="hevea_default135"></a> and <span class="c001">write</span><a id="hevea_default136"></a> but they work only 
on socket descriptors.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALrecv">recv</a> : file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; int
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALsend">send</a> : file_descr -&gt; string -&gt; int -&gt; int -&gt; msg_flag list -&gt; int</div><p>Their interface is similar to <code>read</code> and <code>write</code> but they add 
a list of flags of type <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#TYPEmsg_flag"><span class="c001">msg_flag</span></a> whose semantics is:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c010"><code>MSG_OOB</code></td><td class="c010">Process out-of-band data. </td></tr>
<tr><td class="c010"><code>MSG_DONTROUTE</code></td><td class="c010">Short-circuit the default routing table. </td></tr>
<tr><td class="c010"><code>MSG_PEEK</code></td><td class="c010">Examines the data without reading it.
</td></tr>
</table>
</div><p>
These primitives can be used in connection-oriented mode instead of
<code>read</code> and <code>write</code> or in pseudo-connected mode instead of
<code>recvfrom</code> and <code>sendto</code>.</p>
<!--TOC section id=sec134 High-level primitives-->
<h2 class="section" id="sec134">6.12  High-level primitives</h2><!--SEC END --><p>Examples like the universal client-server are so frequent that the
<code>Unix</code> module provides higher-level functions to establish 
or use network services.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALopen_connection">open_connection</a><a id="hevea_default137"></a> : sockaddr -&gt; in_channel * out_channel
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALshutdown_connection">shutdown_connection</a><a id="hevea_default138"></a> : Pervasives.in_channel -&gt; unit</div><p>The <code>open_connection</code> function opens a connection to the given address
and creates a pair of <code>Pervasives</code> input/output channels on the resulting
socket. Reads and writes on these channels communicate with the server
but since the output channel is buffered we must flush it to ensure
that a request has been really sent. The client can shutdown the
connection abruptly by closing either of the channels (this will close
the socket) or more “cleanly” by calling
<code>shutdown_connection</code>. If the server closes the connection, the
client receives an end of file on the input channel.</p><p>A service can be established with the <code>establish_server</code> function.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html#VALestablish_server">establish_server</a><a id="hevea_default139"></a> :
  (in_channel -&gt; out_channel -&gt; unit) -&gt; sockaddr -&gt; unit</div><p>The function <code>establish_server f addr</code> establishes a service on the
address <code>addr</code> and handles requests with the function <code>f</code>. Each
connection to the server creates a new socket and forks. The child
creates a pair of <code>Pervasives</code> input/output channels on the socket
to communicate with the client and gives them to <code>f</code> to provide the
service. Once <code>f</code> returns the child closes the socket and exits. If
the client closes the connection cleanly, the child gets and end of
file on the input channel and if it doesn’t it may receive a
<code>sigpipe</code> signal when <code>f</code> writes on the output channel. As for the
parent, it has probably already handled another request! The
<code>establish_server</code> function never terminates, except in
case of error (e.g. of the OCaml runtime or the system during
the establishment of the service).</p>
<!--TOC section id=sec135 Examples of protocols-->
<h2 class="section" id="sec135">6.13  Examples of protocols</h2><!--SEC END --><p>In simple cases (<code>rsh</code>, <code>rlogin</code>, …), the data transmitted
between a client and a server is naturally represented by two streams
of bytes, one from the client to the server and the other in the
reverse direction. In other cases, the data to transmit is more
complex, and requires to be encoded and decoded to/from the streams of
bytes. The client and the server must then agree on a precise
transmission protocol, which specifies the format of requests and
responses exchanged on the connection. Most protocols used by Unix
commands are specified in documents called “<span class="c005">rfc</span>”
(request for comments): these documents start as proposals open
for discussion, and gradually become standards over time, as users
adopt the described protocol.<sup><a id="text9" href="#note9">2</a></sup></p><!--TOC subsection id=sec136 “Binary” protocols-->
<h3 class="subsection" id="sec136">“Binary” protocols</h3><!--SEC END --><p>Most binary protocols transmit data in a compact format, as close as
possible to the in-memory representation, in order to minimize the
encoding/decoding work needed for transmission and save network
bandwidth. Typical examples of protocols of this type are the
<span class="c005">x</span>-window protocol, which governs exchanges between the
<span class="c005">x</span> server and <span class="c005">x</span> applications, and the
<span class="c005">nfs</span> protocol (<a href="http://www.faqs.org/rfcs/rfc1094.html"><span class="c005">rfc</span> 1094</a>).</p><p>Binary protocols usually encode data as follows. An integer or
floating point number is represented by its 1, 2, 4, or 8 bytes binary
representation. A string by its length as an integer followed by its
contents as bytes. A structured object (tuple, record) by the
representation of its fields in order. A variable size structure
(array, list) by its length as an integer followed by the
representation of its elements. If the exact type of data being
transmitted in known to a process it can easily recreate it in its
memory. When different type of data is exchanged on a socket the data
encoding can be preceded by an integer to identify the data that
follows.</p><div class="example">
<!--TOC paragraph id=sec137 Example-->
<h5 class="paragraph" id="sec137">Example</h5><!--SEC END --><p>
The <code>XFillPolygon</code> call of the <span class="c005">x</span> library, which draws and
fills a polygon, sends a message with the following structure to the 
<span class="c005">x</span> server:
</p><ul class="itemize"><li class="li-itemize">
the byte 69 (the code of the <code>FillPoly</code> command)
</li><li class="li-itemize">a padding byte
</li><li class="li-itemize">a 16 bit integer specifying the number <span class="c004">n</span> of vertices of the polygon
</li><li class="li-itemize">a 32 bit integer identifying the window on which to draw
</li><li class="li-itemize">a 32 bit integer identifying the “graphic context”
</li><li class="li-itemize">a “form” byte, indicating whether the polygon is convex, etc.</li><li class="li-itemize">a byte indicating whether the coordinates of the vertices are absolute or
relative
</li><li class="li-itemize">4<span class="c004">n</span> bytes encoding the coordinates of the polygon’s vertices
by two 16 bit integers
</li></ul><div class="fancybreak">* * *</div></div><p>With binary protocols we must pay attention to the computer
architecture of the communicating machines. In particular for
multi-byte integers, <em>big-endian</em> machines store the most
significant byte first (that is, in memory, at the lower-address) and
<em>little-endian</em> machines store the least significant byte
first. For instance, the 16 bit integer 12345 = 48 × 256 + 57
is represented by the byte 48 at the address <span class="c004">n</span> and the byte 57
at the address <span class="c004">n</span>+1 on a big-endian machine, and by the byte
57 at the address <span class="c004">n</span> and the byte 48 at the address <span class="c004">n</span>+1 on a
little-endian machine. Hence protocols must precisely specify which
convention they use when multi-bytes integers are transmitted. Another
option is to allow both and have it specified in the header of the
transmitted message. </p><p>The OCaml system helps to encode and decode data structures (a
procedure called
<em>marshalling</em>, <em>serialization</em> or <em>pickling</em> in the
literature) by providing two functions to convert an OCaml value
into a sequence of bytes and vice versa:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALoutput_value">output_value</a><a id="hevea_default140"></a> : out_channel -&gt; 'a -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALinput_value">input_value</a><a id="hevea_default141"></a> : in_channel -&gt; 'a</div><p>These function are defined to save values to a disk file and get
them back but they can also be used to transmit any value on a pipe or
a socket. They handle any OCaml values except functions, preserve
sharing and circularities inside values and work correctly between
machines of different endianness. More information can be found in the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html"><span class="c001">Marshal</span></a> module.</p><p>Note that semantically, the type of <code>input_value</code> is incorrect. It
is too general, it is not true that the result of <code>input_value</code> is
of type <code>'a</code> for any type <code>'a</code>. The value returned by
<code>input_value</code> belongs to a precise type, and not to all possible
types. But this type cannot be determined at compile time, it depends
on the content of the channel read at runtime. Type-checking
<code>input_value</code> correctly requires an extension to the ML language
known as dynamic objects: values are paired with a representation of
their type allowing to perform runtime type checks. Consult
[<a href="#Dynamiques">15</a>] for a detailed presentation.</p><div class="example">
<!--TOC paragraph id=sec138 Example-->
<h5 class="paragraph" id="sec138">Example</h5><!--SEC END --><p>
If the <span class="c005">x</span>-window protocol was written in OCaml, we would
define a variant type <code>request</code> for requests sent to the
server and a <code>reply</code> type for server responses:
</p><div class="mylisting"><span class="c006">type</span> request =
  | FillPolyReq <span class="c006">of</span> (int * int) array * drawable * graphic_context
                                    * poly_shape * coord_mode
  | GetAtomNameReq <span class="c006">of</span> atom
  | ...
<span class="c006">and</span> reply =
  | GetAtomNameReply <span class="c006">of</span> string
  | ...</div><p>The core of the server would be a loop that reads and decodes a
request and responds by writing a reply:
</p><div class="mylisting"><em>(* Get a connection request on the descriptor s *)</em>
<span class="c006">let</span> requests = in_channel_of_descr s
<span class="c006">and</span> replies  = out_channel_of_descr s <span class="c006">in
try
  while true do
    match</span> input_value requests <span class="c006">with</span>
        ...
      | FillPoly(vertices, drawable, gc, shape, mode) -&gt;
          fill_poly vertices drawable gc shape mode
      | GetAtomNameReq atom -&gt;
          output_value replies (GetAtomNameReply(get_atom_name atom))
      | ...
  <span class="c006">done
with</span> End_of_file -&gt; <em>(* end of the connection *)</em></div><p>The functions of the <span class="c005">x</span> library, 
linked with each application would have the following structure:
</p><div class="mylisting"><em>(* First establish a connection with the server on the descriptor s *)</em>
...
<span class="c006">let</span> requests = out_channel_of_descr s
<span class="c006">and</span> replies  = in_channel_of_descr s;;

<span class="c006">let</span> fill_poly vertices drawable gc shape mode =
  output_value requests
               (FillPolyReq(vertices, drawable, gc, shape, mode));;
<span class="c006">let</span> get_atom_name atom =
  output_value requests (GetAtomNameReq atom);
  <span class="c006">match</span> input_value replies <span class="c006">with</span>
  | GetAtomNameReply name -&gt; name
  | _ -&gt; fatal_protocol_error "get_atom_name";;</div><div class="fancybreak">* * *</div></div>
<!--TOC paragraph id=sec139 Remote procedure call-->
<h5 class="paragraph" id="sec139">Remote procedure call</h5><!--SEC END --><p>Another typical incarnation of binary protocols is remote procedure
calls (<span class="c005">rpc</span>). A user on machine A wants to call a function
<code>f</code> on a machine B. This is obviously not directly possible. It can
be programmed on a case by case basis using the system to open
a connection to the machine B, execute the call and send the
result back to the machine A.</p><div class="figure">
<div class="image"><img src="ocamlunix-image21.png" width="80%"></div>



<a id="fig/rpc"></a>
<div class="caption">Figure 4 — Remote procedure call</div></div><p>But since this is a common situation, an <span class="c005">rpc</span> service can
handle that (see figure <a href="#fig%2Frpc">4</a>). An <span class="c005">rpc</span> server runs on
both machine A and B. A user on machine A requests the <span class="c005">rpc</span>
server on the machine to execute a function on the distant machine
B. The server on A relays the request to the <span class="c005">rpc</span> server on
machine B which executes the call to <code>f</code>, sends the result back to
the server on A which gives the result to the user. The point is that
another user can call another function on B by going through the same
server on A. The connection work is shared by the <span class="c005">rpc</span> service
installed on the machines A and B and from the perspective of the
users, everything happens as if these calls were simple function calls
(dashed arrows).</p><!--TOC subsection id=sec140 “Text” protocols-->
<h3 class="subsection" id="sec140">“Text” protocols</h3><!--SEC END --><p>Network services where the efficiency of the protocol is not crucial
are often “text” protocols. A “text” protocol is in fact a
small command language. Requests are command lines, the first word
identifies the request type and the possible remaining words the
command’s arguments. Responses are also made of one or more lines of
text, often starting with a numerical code to identify the kind of
response. Here are some “text” protocols:
</p><div class="center">
<table class="c000 cellpading0"><tr><td class="c010">Name</td><td class="c010">Descr.</td><td class="c010">Purpose </td></tr>
<tr><td class="hbar" colspan=3></td></tr>
<tr><td class="c010"><span class="c005">smtp</span> (Simple Mail Transfer Protocol)</td><td class="c010"><a href="http://www.faqs.org/rfcs/rfc821.html"><span class="c005">rfc</span> 821</a></td><td class="c010">Electronic mail
</td></tr>
<tr><td class="c010"><span class="c005">ftp</span>
(File Transfer Protocol)</td><td class="c010"><a href="http://www.faqs.org/rfcs/rfc959.html"><span class="c005">rfc</span> 959</a></td><td class="c010">File transfer
</td></tr>
<tr><td class="c010"><span class="c005">nttp</span>
(Network News Transfer Protocol)</td><td class="c010"><a href="http://www.faqs.org/rfcs/rfc977.html"><span class="c005">rfc</span> 977</a></td><td class="c010">News reading
</td></tr>
<tr><td class="c010"><span class="c005">http</span>/1.0 (HyperText Transfer Protocol)</td><td class="c010"><a href="http://www.faqs.org/rfcs/rfc1945.html"><span class="c005">rfc</span> 1945</a></td><td class="c010">Web navigation
</td></tr>
<tr><td class="c010"><span class="c005">http</span>/1.1 (HyperText Transfer Protocol)</td><td class="c010"><a href="http://www.faqs.org/rfcs/rfc2068.html"><span class="c005">rfc</span> 2068</a></td><td class="c010">Web navigation<br>
</td></tr>
<tr><td class="hbar" colspan=3></td></tr>
</table>
</div><p>
The great advantage of these protocols is that the exchanges between
the server and the client are human readable. For example we can just
use the <code>telnet</code> command to talk directly to the server. Invoke
<code>telnet host service</code> where <code>host</code> is the host name on which the
server is running the service <code>service</code> (e.g. <code>http</code>, <code>smtp</code>,
<code>nntp</code>, etc.) and then type in the requests as a client would, the
server’s responses will be printed on standard output. This makes it easier to
understand the protocol. However coding and decoding requests and
responses is more involved than for binary protocols and the message
size also tends to be larger which is less efficient.</p><div class="example">
<!--TOC paragraph id=sec141 Example-->
<h5 class="paragraph" id="sec141">Example</h5><!--SEC END --><p>
Here is an example of an interactive dialog, in the shell, to send an
email on an <span class="c005">smtp</span> server. The
lines preceded by &gt;&gt; go from the client to the
server, and are typed in by the user. The lines preceded
by &lt;&lt; go from the server to the client.

</p><div class="mylisting">    telnet margaux smtp
    Trying 128.93.8.2 ...
    Connected <span class="c006">to</span> margaux.inria.fr.
    Escape character is '^]'.
&lt;&lt;  220 margaux.inria.fr Sendmail 5.64+/AFUU-3 ready at Wed, 15 Apr 92 17:40:59
&gt;&gt;  HELO pomerol.inria.fr
&lt;&lt;  250 Hello pomerol.inria.fr, pleased <span class="c006">to</span> meet you
&gt;&gt;  MAIL From:&lt;god@heavens.sky.com&gt;
&lt;&lt;  250 &lt;god@heavens.sky.com&gt;... Sender ok
&gt;&gt;  RCPT To:&lt;xleroy@margaux.inria.fr&gt;
&lt;&lt;  250 &lt;xleroy@margaux.inria.fr&gt;... Recipient ok
&gt;&gt;  DATA
&lt;&lt;  354 Enter mail, <span class="c006">end with</span> "." on a line by itself
&gt;&gt;  From: god@heavens.sky.com (Himself)
&gt;&gt;  To: xleroy@margaux.inria.fr
&gt;&gt;  Subject: Hello!
&gt;&gt;
&gt;&gt;  Is everything ok down there?
&gt;&gt;  .
&lt;&lt;  250 Ok
&gt;&gt;  QUIT
&lt;&lt;  221 margaux.inria.fr closing connection
    Connection <span class="c006">closed</span> by foreign host.</div><p>
The commands <code>HELO</code>, <code>MAIL</code> and <code>RCPT</code> respectively send to
the server: the name of the client machine, the address of the sender
and the address of the recipient. The <code>DATA</code> command asks to send
the body of the email. The body of the message is then entered and
ended by a line containing the single character <code>'.'</code> (would the body
of the email contain such a line, we just double the initial <code>'.'</code> on
that line, this additional period is then suppressed by the server). </p><p>The responses from the server are all made of a 3 digit numerical code
followed by a comment. Responses of the form <code>5xx</code> indicate an
error and those with <code>2xx</code>, that everything is fine. When the
client is a real program it only interprets the response code, the comment is
only to help the person who develops the mail system.
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id=sec142 Complete example: <span class="c005">http</span> requests-->
<h2 class="section" id="sec142">6.14  Complete example: <span class="c005">http</span> requests</h2><!--SEC END --><p>The <span class="c005">http</span> protocol (HyperText Transfer Protocol) is primarily used
to read documents over the famous “world wide web”. This domain
is a niche area of client-server examples: between the client that
reads a page and the server that writes it there is a myriad of
intermediary relays that act as virtual servers for the real client or
delegated clients for the real server. These relay often provide
additional service like caching, filtering, etc..</p><p>There are several versions of the <span class="c005">http</span> protocol. To allow us to
focus on the essentials, namely the architecture of clients or relays,
we use the simple protocol inherited from the very first versions of
the protocol. Even if dust-covered it is still understood by most
servers. At the end of the section we describe a more modern, but also
more complex, version which is needed to make real tools to explore
the web. We do however leave the translation of the examples to this
new version as an exercise. </p><p>Version 1.0 of the <span class="c005">http</span> protocol specified in <a href="http://www.faqs.org/rfcs/rfc1945.html"><span class="c005">rfc</span> 1945</a> defines
simple requests of the form:
</p><div class="mylisting">GET <span class="c004">sp uri crlf</span></div><p>where <code><span class="c004">sp</span></code> represents a space and <code><span class="c004">crlf</span></code> the
string <code>"\r\n"</code> (“return” followed by
“linefeed”). The response to a simple request is also
simple: the content of the <span class="c005">url</span> is sent directly, without any
headers and the end of the request is signaled by the end of file,
which closes the connection. This form of request, inherited from
version 0.9 of the protocol, limits the connection to a single 
request.</p><!--TOC subsection id=sec143 Fetching a <span class="c005">url</span>-->
<h3 class="subsection" id="sec143">Fetching a <span class="c005">url</span></h3><!--SEC END --><p>We write a <code>geturl</code> program that takes a single argument, a <span class="c005">url</span>,
retrieves the resource it denotes on the web and displays it. </p><p>The first task is to parse the <span class="c005">url</span> to extract the name of the
protocol (here, necessarily <code>"http"</code>), the address of the server,
the optional port and the absolute path of the document on the
server. This is done with <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html"><span class="c001">Str</span></a>, OCaml’s regular
expression library.
</p><div class="mylisting"><span class="c006">open</span> Unix;;

<span class="c006">exception</span> Error <span class="c006">of</span> string
<span class="c006">let</span> error err mes = raise (Error (err ^ ": " ^ mes));;
<span class="c006">let</span> handle_error f x = <span class="c006">try</span> f x <span class="c006">with</span> Error err -&gt; prerr_endline err; exit 2

<span class="c006">let</span> default_port = "80";;

<span class="c006">type</span> regexp = { regexp : Str.regexp; fields : (int * string option) list; }

<span class="c006">let</span> regexp_match r string =
  <span class="c006">let</span> get (pos, default) =
    <span class="c006">try</span> Str.matched_group pos string
    <span class="c006">with</span> Not_found -&gt;
      <span class="c006">match</span> default <span class="c006">with</span> Some s -&gt; s | _ -&gt; raise Not_found <span class="c006">in
  try
    if</span> Str.string_match r.regexp string 0 <span class="c006">then</span>
      Some (List.map get r.fields)
    <span class="c006">else</span> None
  <span class="c006">with</span> Not_found -&gt; None;;

<span class="c006">let</span> host_regexp =
  { regexp = Str.regexp "\\([^/:]*\\)\\(:\\([0-9]+\\)\\)?";
    fields = [ 1, None; 3, Some default_port; ] };;

<span class="c006">let</span> url_regexp =
  { regexp = Str.regexp "http://\\([^/:]*\\(:[0-9]+\\)?\\)\\(/.*\\)";
    fields = [ 1, None; 3, None ] };;

<span class="c006">let</span> parse_host host = <span class="c006">match</span> regexp_match host_regexp host <span class="c006">with</span>
  | Some (host :: port :: _) -&gt; host, int_of_string port
  | _ -&gt; error host "Ill formed host";;

<span class="c006">let</span> parse_url url = <span class="c006">match</span> regexp_match url_regexp url <span class="c006">with</span>
  | Some (host :: path :: _) -&gt; parse_host host, path
  | _ -&gt; error url "Ill formed url";;</div><p>Sending a simple request is a trivial task, as the following function
shows.
</p><div class="mylisting"><span class="c006">let</span> send_get url sock =
  <span class="c006">let</span> s = Printf.sprintf "GET %s\r\n" url <span class="c006">in</span>
  ignore (write sock s 0 (String.length s));;</div><p>Note that the <span class="c005">url</span> can be complete, with the address and port of the
server, or just contain the requested path on the server.</p><p>Reading the response is even easier, since only the document is
returned, without any additional information. If there’s an error in
the request, the error message returned by the server as an
<span class="c005">html</span> document. Thus we just print the response with the
function <code>Misc.retransmit</code> without indicating whether this is an
error or the desired document. The rest of the program establishes the
connection with the server.
</p><div class="mylisting"><span class="c006">let</span> get_url proxy url fdout =
  <span class="c006">let</span> (hostname, port), path = <span class="c006">match</span> proxy <span class="c006">with</span>
    | None -&gt; parse_url url
    | Some host -&gt; parse_host host, url
  <span class="c006">in
  let</span> hostaddr =
    <span class="c006">try</span> inet_addr_of_string hostname
    <span class="c006">with</span> Failure _ -&gt;
      <span class="c006">try</span> (gethostbyname hostname).h_addr_list.(0)
      <span class="c006">with</span> Not_found -&gt; error hostname "Host not found"
  <span class="c006">in
  let</span> sock = socket PF_INET SOCK_STREAM 0 <span class="c006">in</span>
  Misc.try_finalize
    <span class="c006">begin function</span> () -&gt;
      connect sock (ADDR_INET (hostaddr, port));
      send_get path sock;
      Misc.retransmit sock fdout
    <span class="c006">end</span> ()
    close sock;;</div><p>We conclude, as usual, by parsing the command line.

</p><div class="mylisting"><span class="c006">let</span> geturl () =
  <span class="c006">let</span> len =  Array.length Sys.argv <span class="c006">in
  if</span> len &lt; 2 <span class="c006">then</span>
    error "Usage:" (Sys.argv.(0) ^ " [ proxy [:&lt;port&gt;] ] &lt;url&gt;")
  <span class="c006">else
    let</span> proxy, url =
      <span class="c006">if</span> len &gt; 2 <span class="c006">then</span> Some Sys.argv.(1), Sys.argv.(2) <span class="c006">else</span>
      None, Sys.argv.(1)
    <span class="c006">in</span>
    get_url proxy url stdout;;

handle_unix_error (handle_error geturl) ();;</div><!--TOC subsection id=sec144 <span class="c005">http</span> relay-->
<h3 class="subsection" id="sec144"><span class="c005">http</span> relay</h3><!--SEC END --><p>We program an <span class="c005">http</span> relay (or <em>proxy</em>), which is a server 
that redirects <span class="c005">http</span> requests from a client to another server
(or relay…) and forwards responses from that server back to the 
client. </p><p>The role of a relay is shown in in figure <a href="#sec144">5</a>. When a
client uses a relay, it addresses its requests to the relay rather
than to the individual <span class="c005">http</span> servers located
around the world. A relay has multiple advantages. It can store the
responses to the most recent or frequent requests and serve them without
querying the remote server (e.g. to avoid network overload or if
the server is down). It can filter the responses (e.g. to remove
advertisements or image, etc.). It can also simplify the development
of a program by making it see the whole world wide web through a
single server.</p><div class="figure">
<div class="image"><img src="ocamlunix-image22.png" width="70%"></div>




<div class="caption">Figure 5 — <span class="c005">http</span> relay</div></div><p>The <code>proxy port</code> command launches the server on the port <code>port</code>
(or if omitted, on the default port for <span class="c005">http</span>). We reuse the code of
the <code>get_url</code> function (we assume that the functions above are
available in a <code>Url</code> module). It only remains to write the code to
analyze the requests and set up the server.
</p><div class="mylisting"><span class="c006">open</span> Unix
<span class="c006">open</span> Url

<span class="c006">let</span> get_regexp =
  { regexp = Str.regexp "^[Gg][Ee][Tt][ \t]+\\(.*[^ \t]\\)[ \t]*\r";
    fields = [ 1, None ] }

<span class="c006">let</span> parse_request line = <span class="c006">match</span> regexp_match get_regexp line <span class="c006">with</span>
  | Some (url :: _) -&gt; url
  | _ -&gt; error line "Ill formed request"</div><p>We establish the service with the <code>establish_server</code>
function, thus we just need to define the function to handle a 
connection:
</p><div class="mylisting"><span class="c006">let</span> proxy_service (client_sock, _) =
  <span class="c006">let</span> service () =
    <span class="c006">try
      let</span> in_chan = in_channel_of_descr client_sock <span class="c006">in
      let</span> line = input_line in_chan <span class="c006">in
      let</span> url = parse_request line <span class="c006">in</span>
      get_url None url client_sock
    <span class="c006">with</span> End_of_file -&gt;
      error "Ill formed request" "End_of_file encountered"
  <span class="c006">in</span>
  Misc.try_finalize
    (handle_error service) ()
    close client_sock</div><p>
and the rest of the program just establishes the service:
</p><div class="mylisting"><span class="c006">let</span> proxy () =
  <span class="c006">let</span> http_port =
    <span class="c006">if</span> Array.length Sys.argv &gt; 1 <span class="c006">then
      try</span> int_of_string Sys.argv.(1)
      <span class="c006">with</span> Failure _ -&gt; error Sys.argv.(1) "Incorrect port"
    <span class="c006">else
      try</span> (getservbyname "http" "tcp").s_port
      <span class="c006">with</span> Not_found -&gt; error "http" "Unknown service"
  <span class="c006">in
  let</span> treat_connection s = Misc.double_fork_treatment s proxy_service <span class="c006">in
  let</span> addr = ADDR_INET(inet_addr_any, http_port) <span class="c006">in</span>
  Misc.tcp_server treat_connection addr;;

handle_unix_error (handle_error proxy) ();;</div><!--TOC subsection id=sec145 The <span class="c005">http</span>/1.1 protocol-->
<h3 class="subsection" id="sec145">The <span class="c005">http</span>/1.1 protocol</h3><!--SEC END --><p>Simple <span class="c005">http</span> requests need one connection per request. This is
inefficient because most requests on a server are followed by others
(e.g. if a client gets a web page with images, it will
subsequently request the images) and the time to establish a
connection can easily exceed the time spent in handling the request
itself (chapter <a href="#sec149">7</a> show how we can reduce this by
handling the requests with threads rather than processes). Version 1.1
of the <span class="c005">http</span> described in <a href="http://www.faqs.org/rfcs/rfc2068.html"><span class="c005">rfc</span> 2068</a> uses complex requests that
allow to make multiple requests on a single connection<sup><a id="text10" href="#note10">3</a></sup>. </p><p>In complex requests, the server precedes every response with a header
describing the format of the response and possibly the size of the
document transmitted. The end of the document is no longer indicated
by an end of file, since we know its size. The connection can
therefore stay
open to handle more requests. Complex requests have the following form:
</p><div class="mylisting">GET <span class="c004">sp uri sp</span> HTTP/1.1 <span class="c004">crlf
header crlf</span></div><p>The <code><span class="c004">header</span></code> part defines a list of key-value fields with
the following syntax:
</p><div class="mylisting"><span class="c004">field</span> : <span class="c004">value crlf</span></div><p>Superfluous spaces are allowed around the <code>':'</code> separator and any
space can always be replaced by a tab or a sequence of spaces. The
header fields can also span several lines: in this case, and in this
case only, the <code><span class="c004">crlf</span></code> end of line lexeme is immediately
followed by a space <code><span class="c004">sp</span></code>. Finally, uppercase and lowercase
letters are equivalent in the keyword of fields and in the values of
certain fields.</p><p>Mandatory and optional fields depend on the type of request. For
instance, a <code>GET</code> request must have a field indicating the
destination machine:
</p><div class="mylisting">Host : <span class="c004">hostname crlf</span></div><p>For this type of request, we may also request, using the optional field
<span class="c001">If-Modified</span>, that the document be returned only if it has been
modified since a given date.
</p><div class="mylisting">If-Modified : <span class="c004">date crlf</span></div><p>The number of fields in the <code><span class="c004">header</span></code> is not fixed in
advance but indicated by the end of the header: a line
containing only the characters <code><span class="c004">crlf</span></code>.</p><p>Here is a complete request (on each line an implicit <code>\n</code> follows
the <code>\r</code>):
</p><div class="mylisting">GET /~remy/ HTTP/1.1\r
Host:pauillac.inria.fr\r
\r</div><p>A response to a complex request is also a complex response. It contains
a status line, a header, and the body of the response, if any.
</p><div class="mylisting">HTTP/1.1 <span class="c004">sp status sp message crlf
header crlf
body</span></div><p>The fields of a response header have a syntax similar to that of a
request but the required and optional fields are different (they
depend on type of request and the status of the response — see the
full documentation of the protocol).</p><p>The <code><span class="c004">body</span></code> of the response can be transmitted in a
single block, in chunks or be empty: </p><ul class="itemize"><li class="li-itemize">
If the body is a single block the header
contains a <code>Content-Length</code> field specifying in decimal
<span class="c005">ascii</span> notation the number of bytes in the body. </li><li class="li-itemize">If the body is transmitted in chunks, 
the header contains a <code>Transfer-Encoding</code>
field with the value “<code>chunked</code>”. The body is then a set of chunks
and ends with an empty chunk. A chunk is of the form:
<div class="mylisting"><span class="c004">size [ ; arg ] crlf
chunk crlf</span></div>where <code><span class="c004">size</span></code> is the size of the chunk in hexadecimal
notation and <code><span class="c004">chunk</span></code> is a chunk of the response body of
the given size (the part between <code><span class="c004">[</span></code> and <code><span class="c004">]</span></code>
is optional and can safely be ignored). The last, empty, chunk is
always of the following form:
<div class="mylisting">0 <span class="c004">crlf
header crlf crlf</span></div></li><li class="li-itemize">If the response does not contain a <code>Content-Length</code> field and
that it is not chunked, the body is empty (for instance, a
response to a request of type <code>HEAD</code> contains only a header). 
</li></ul><p>
Here is an example of a single block response:
</p><div class="mylisting">HTTP/1.1 200 OK\r
Date: Sun, 10 Nov 2002 09:14:09 GMT\r
Server: Apache/1.2.6\r
Last-Modified: Mon, 21 Oct 2002 13:06:21 GMT\r
ETag: "359-e0d-3db3fbcd"\r
Content-Length: 3597\r
Accept-Ranges: bytes\r
Content-Type: text/html\r
\r
&lt;html&gt;
...
&lt;/html&gt;</div><p>The status <code>200</code> indicates that the request was successful. A
<code>301</code> means the <span class="c005">url</span> was redirected to another <span class="c005">url</span> defined in
the <code>Location</code> field of the response. The <code>4XX</code> statuses
indicate errors on the client side while <code>5XX</code> errors on the server
side.</p><div class="exercise">
<!--TOC paragraph id=sec146 Exercise 15-->
<h5 class="paragraph" id="sec146">Exercise 15</h5><!--SEC END --><p><a id="ex15"></a>
<a id="ex/proxy-1.1"></a>
Write a relay that works with the <span class="c005">http</span>/1.1 protocol.
</p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id=sec147 Exercise 16-->
<h5 class="paragraph" id="sec147">Exercise 16</h5><!--SEC END --><p><a id="ex16"></a>
Add a cache to the relay. Pages are saved on the hard drive and when a
requested page is available in the cache, it is served unless too old.
In that case the server is queried again and the cache updated.
</p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id=sec148 Exercise 17-->
<h5 class="paragraph" id="sec148">Exercise 17</h5><!--SEC END --><p><a id="ex17"></a>
<a id="ex/wget"></a>
Write a program <code>wget</code> such that <code>wget u1 u2 ... un</code> makes the
requests <code>u1</code>, <code>u2</code>, …, <code>un</code> and saves the responses in
the files <code>./m1/p1</code>, <code>./m2/p2</code>, …, <code>./mn/pn</code> where
<code>mi</code> and <code>pi</code> are respectively the name of the server and the
absolute path of the request <code>ui</code>. The program should take
advantage of the protocol to establish a single connection to a
machine <code>m</code> when it is the same for consecutive requests. 
Permanent <span class="c005">url</span> redirections
should be followed. The following options can also be added:
</p><div class="mltypecases">
<table class="c000 cellpading0"><tr><td class="c013"><code>-N</code></td><td class="c012">Do not download the <span class="c005">url</span> if the file <code>./mi/ui</code>
does not exist or is older than the <span class="c005">url</span>. </td></tr>
<tr><td class="c013"><code>-r</code></td><td class="c012">Download recursively all the <span class="c005">url</span>s embedded in the
responses which are documents in <span class="c005">html</span> format.
</td></tr>
</table>
</div><div class="fancybreak">* * *</div></div>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note8" href="#text8">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext"> The Internet network
is made of local networks, usually Ethernet networks, connected by
specialized links. It connects millions of machines world-wide. In
the Internet domain, there is no difference between programs that
communicate with a neighboring machine, connected to the same
Ethernet cable, and those that communicate with a machine on the other
side of the planet, through a dozen routers and a satellite link.</div>
</dd><dt class="dt-thefootnotes"><a id="note9" href="#text9">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext"><span class="c005">rfc</span>s are available
via anonymous <span class="c005">ftp</span> on numerous sites. In France:
<a href="ftp://ftp.inria.fr"><span class="c001">ftp.inria.fr</span></a>, in the directory
<a href="ftp://ftp.inria.fr/pub/rfc/"><span class="c001">rfc</span></a>. The reference site
is <a href="http://www.faqs.org/rfcs/"><span class="c001">http://www.faqs.org/rfcs/</span></a>. </div>
</dd><dt class="dt-thefootnotes"><a id="note10" href="#text10">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">The <span class="c005">http</span>/1.0
protocol already allows complex requests but we prefer to describe the 
<span class="c005">http</span>/1.1 protocol which deals exclusively with these.</div>
</dd></dl>
<!--END NOTES-->
<!--TOC chapter id=sec149 Threads-->
<h1 class="chapter" id="sec149"> 7  Threads</h1><!--SEC END --><!--NAME threads.html-->
<p>A <em>thread</em>, also called a <em>lightweight process</em>, is a flow
of control that can execute in parallel with other threads in the same
program.</p><p>This chapter describes the functions that allow a program to create
threads (<code>Thread</code> module) and synchronize by means of locks
(<code>Mutex</code> module), conditions (<code>Condition</code> module), and
synchronous events (<code>Event</code> module).</p>
<!--TOC section id=sec150 Introduction-->
<h2 class="section" id="sec150">7.1  Introduction</h2><!--SEC END --><p>The creation of a thread is very different from the <span class="c001">fork</span><a id="hevea_default142"></a>
operation that creates a copy of the current process (and therefore a
copy of the program). After a fork, the address spaces of the parent
and child are totally disjoint, and the two processes can communicate
only through system calls (like reading or writing a file or a pipe).</p><p>In contrast, all the threads within a program share the same address
space. The only information that is not shared, and differentiates one
thread from another, is the thread’s identity and its execution stack
(along with certain system information such as the signal mask, the
state of locks and conditions, etc.) From this viewpoint, threads
resemble coroutines. The threads within a given program are all
treated in the same fashion, except for the initial thread that was
created when the program started. When this thread terminates, so do
all the other threads and therefore the program as a whole. (Whenever
we speak of multiple threads, we will implicitly mean threads within a
given program.)</p><p>But unlike coroutines, which pass control explicitly from one to another
and cannot execute in parallel, threads can execute in parallel and
can be scheduled preemptively by the system. From this viewpoint,
threads resemble processes.</p><p>The common address space permits threads to communicate directly among
themselves using shared memory. The fact that threads can execute in
parallel means that they must synchronize their access to shared data,
so that one finishes writing before the other begins reading.
Although not necessary in principle, in practice this requires going
through the operating system. Synchronization is often a difficult
part of programming with threads. It can be done with locks and
conditions, or in a higher-level fashion with events.</p><p>The advantages of threads over processes are the lower cost of
creation and the ability to exchange large data structures simply by
passing pointers rather than copying.</p><p>On the other hand, using threads incurs the cost of managing the
synchronization among them, including the case of a fatal error in one
of the threads. In particular, a thread must be careful to release its
locks and preserve its invariant before stopping. Processes may also
be preferable to threads when we cannot really benefit from the
latter’s advantages.</p>
<!--TOC paragraph id=sec151 Implementation in OCaml-->
<h5 class="paragraph" id="sec151">Implementation in OCaml</h5><!--SEC END --><p>To compile an application using native threads, use the following:
</p><div class="mylisting">ocamlc -thread unix.cma threads.cma -o prog mod1.ml mod2.ml mod3.ml

ocamlopt -thread unix.cmxa threads.cmxa -o prog mod1.ml mod2.ml mod3.ml</div><p>If the <code>ocamlbuild</code> tool is used, all that is needed is to add the
following to the <code>_tags</code> file:
</p><div class="mylisting">&lt;<span class="c006">mod</span>{1,2,3}.ml&gt; : thread
&lt;prog.{native,byte}&gt; : use_unix, thread</div><p>If your installation does not support native threads, you can refer to
section <a href="#sec172">7.8</a> or the manual for instructions
how to use simulated “<span class="c005">vm</span>-level” threads. The text
and examples in this chapter assume native threads and do not apply,
in general, to <span class="c005">vm</span>-level threads.</p>
<!--TOC section id=sec152 Creation and termination of threads-->
<h2 class="section" id="sec152">7.2  Creation and termination of threads</h2><!--SEC END --><p>The functions described in this section are defined in the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html"><span class="c001">Thread</span></a> module.<br>
</p><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_create.html"><span class="c001">create</span></a><a id="hevea_default143"></a> <code>f v</code> creates a new thread that
executes the function application <code>f v</code> and returns a <em>thread id</em> that
the caller can use to control the newly-created thread.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALcreate">create</a> : ('a -&gt; 'b) -&gt; 'a -&gt; t</div><p>The function application executes concurrently with the other threads
in the program. The thread terminates when the application returns and
its result is simply ignored. If the thread terminates with an
uncaught exception, the exception is not propagated to any other
thread: a message is printed on the standard error output and the
exception is otherwise ignored. (The other threads have proceeded
independently and would not be able to receive the exception.)</p><p>A thread can also terminate prematurely with the system call
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_exit.html"><span class="c001">exit</span></a><a id="hevea_default144"></a> of the <code>Thread</code> module, not to be confused with
<code>Pervasives.</code><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALexit"><span class="c001">exit</span></a><a id="hevea_default145"></a> that terminates the
entire program, i.e. all its threads.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALexit">exit</a><a id="hevea_default146"></a> : unit -&gt; unit</div><p>The initial thread of a program implicitly calls the
<code>Pervasives.exit</code> function when it terminates.</p><p>When another thread terminates before the initial thread, it is
deallocated immediately by the OCaml runtime library. It does not
become a zombie as in the case of a Unix process created by <code>fork</code>.</p><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_self.html"><span class="c001">self</span></a><a id="hevea_default147"></a> returns the thread id of the
calling thread.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALself">self</a> : unit -&gt; t</div><p>We already know enough to propose an alternative to the preceding
model for the concurrent server that used “fork” (or
“double fork”) — by using a thread rather than a child process.
To establish such a server, we introduce a variant
<code>Misc.co_treatment</code> of the function <code>Misc.fork_treatment</code>
defined in section <a href="#sec127">6.7</a>.

</p><div class="mylisting"><span class="c006">let</span> co_treatment server_sock service (client_descr, _ <span class="c006">as</span> client) =
  <span class="c006">try</span> ignore (Thread.create service client)
  <span class="c006">with</span> exn -&gt; close client_descr; raise exn;;</div><p>If the thread was successfully created, the treatment is handled
entirely by the <code>service</code> function, including closing
<code>client_descr</code>. Otherwise, we close the <code>client_descr</code>
descriptor, the client is abandoned, and we let the main program
handle the error.</p><p>Note that all the difficulty of the co-server is hidden in the
<code>service</code> function, which must handle the connection robustly until
disconnection. In the case of a concurrent server where the service
is executed by another process, premature termination of the service
due to a fatal error produces by default the desired behavior — closing
the connection — because the system closes the file descriptors when a
process exits. But in the case where the service is executed by a
thread, the descriptors of the different threads are shared by default
and not closed at the termination of the thread. It is therefore up
to the thread to close its descriptors before exiting. In addition, a
thread cannot call <code>Pervasives.exit</code> in the case of a fatal error
during the handling of a service, because it would stop not only the
service but also the entire server. Calling <code>Thread.exit</code> is often
not a solution either, because we risk not having properly
deallocated the thread’s open resources, and in particular the
connection.</p><p>One solution consists of raising an exception to signify a fatal stop
(for example an <code>Exit</code> exception), causing finalization code to be
executed as it is handled. For similar reasons, it is essential to
block the <code>sigpipe</code> signal during the handling of a service by a
thread, replacing the immediate termination of the thread by the
raising of an <code>EPIPE</code> exception.</p>
<!--TOC section id=sec153 Waiting-->
<h2 class="section" id="sec153">7.3  Waiting</h2><!--SEC END --><p>The functions described in this section are defined in the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html"><span class="c001">Thread</span></a> module.<br>
</p><p>The system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_join.html"><span class="c001">join</span></a><a id="hevea_default148"></a> allows one thread to wait for another
to finish.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALjoin">join</a> : t -&gt; unit</div><p>The calling thread is suspended until the thread with the given
thread id has terminated its execution. This function can also be used
by the principal thread to wait for all the other threads to finish
before terminating itself and the program. (The default behavior is to
kill the other threads without waiting for them to terminate.)</p><p>Although this call is blocking and therefore “long”, it
is restarted automatically when a signal is received: it is
effectively interrupted by the signal, the handler is invoked, then the
call is restarted. The call therefore does not return until the
thread has really terminated, and the call never raises the <code>EINTR</code>
exception. From the viewpoint of the OCaml programmer, it behaves as
if the signal was received at the moment when the call returns.</p><p>A thread does not return, since it is executed asynchronously. But
its action can be observed — luckily! — by its side effects. For
example, one thread can place the result of a computation in a
reference that another thread will consult after making sure that the
calculation has finished. We illustrate this in the following
example.

</p><div class="mylisting"><span class="c006">exception</span> Exited
<span class="c006">type</span> 'a result = Value <span class="c006">of</span> 'a | Exception <span class="c006">of</span> exn
<span class="c006">let</span> eval f x = <span class="c006">try</span> Value (f x) <span class="c006">with</span> z -&gt; Exception z
<span class="c006">let</span> coexec (f : 'a -&gt; 'b) (x : 'a) : unit -&gt; 'b =
  <span class="c006">let</span> result = <span class="c006">ref</span> (Exception Exited) <span class="c006">in
  let</span> p = Thread.create (<span class="c006">fun</span> x -&gt; result := eval f x) x <span class="c006">in
  function</span> () -&gt; <span class="c006">match</span> (join p; !result) <span class="c006">with</span>
    | Value v -&gt; v
    | Exception exn -&gt; raise exn;;

<span class="c006">let</span> v1 = coexec succ 4 <span class="c006">and</span> v2 = coexec succ 5 <span class="c006">in</span> v1 () + v2 ();;</div><p>The system can suspend one thread in order to give control temporarily
to another, or because it is waiting for a resource being used by
another thread (locks and conditions, for example) or by another
process (file descriptors, for example). A thread can also suspend
itself voluntarily. The <code>yield</code> function allows a thread to give
up control explicitly, without waiting for preemption by the system.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALyield">yield</a><a id="hevea_default149"></a> : unit -&gt; unit</div><p>It is a hint for the thread scheduler, but it may have no effect, for
example if no other thread can execute immediately, the system may
give control back to the same thread.</p><p>Conversely, it is not necessary to execute <code>yield</code> to permit other
threads to execute, because the system reserves the right to execute
the <code>yield</code> command itself at any moment. In fact, it exercises
this right sufficiently often to permit other threads to execute and
to give the illusion that the threads are running in parallel, even on
a uniprocessor machine.</p><div class="example">
<!--TOC paragraph id=sec154 Example-->
<h5 class="paragraph" id="sec154">Example</h5><!--SEC END --><p>
We can revisit the example of section <a href="#ex%2Fforksearch">3.3</a> and modify it to use
threads rather than processes.

</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let rec</span> psearch k cond v =
<span class="c003">   2</span>   <span class="c006">let</span> n = Array.length v <span class="c006">in</span>
<span class="c003">   3</span>   <span class="c006">let</span> slice i = Array.sub v (i * k) (min k (n - i * k)) <span class="c006">in</span>
<span class="c003">   4</span>   <span class="c006">let</span> slices = Array.init (n/k) slice <span class="c006">in</span>
<span class="c003">   5</span>   <span class="c006">let</span> found = <span class="c006">ref false in</span>
<span class="c003">   6</span>   <span class="c006">let</span> pcond v = <span class="c006">if</span> !found <span class="c006">then</span> Thread.exit (); cond v <span class="c006">in</span>
<span class="c003">   7</span>   <span class="c006">let</span> search v = <span class="c006">if</span> simple_search pcond v <span class="c006">then</span> found := <span class="c006">true in</span> <a id="prog:search"></a>
<span class="c003">   8</span>   <span class="c006">let</span> proc_list = Array.map (Thread.create search) slices <span class="c006">in</span>
<span class="c003">   9</span>   Array.iter Thread.join proc_list;
<span class="c003">  10</span>   !found;;</div><p>
The function <code>psearch k f v</code> searches with <code>k</code> threads in
parallel for an array element satisfying the function <code>f</code>.
The function <code>pcond</code> allows the search to be interrupted when an
answer has been found. All the threads share the same reference
<code>found</code>: they can therefore access it concurrently. No critical
section is required, because if different threads write to this resource
in parallel, they write the same value. It is important that the
threads do not write the result of the search when it is false!
For example, replacing line <a href="#prog%3Asearch">7</a> by
</p><div class="mylisting"><span class="c006">let</span> search v = found := !found &amp;&amp; simple_search pcond v</div><p>or even:
</p><div class="mylisting"><span class="c006">let</span> search v = <span class="c006">let</span> r = simple_search pcond v <span class="c006">in</span> found := !found &amp;&amp; r</div><p>would be incorrect.
 </p><div class="fancybreak">* * *</div></div><p>The parallel search is interesting even on a uniprocessor machine if
the comparison of elements could be blocked temporarily (for example by
disk accesses or network connections). In this case, the thread
performing the search passes control to another and the machine can
therefore continue the computation on another part of the array and
return to the blocked thread when its resource is free.</p><p>Access to certain elements can have significant latency, on the order
of a second if information must be retrieved over the network. In
this case, the difference in behavior between a sequential search and
a parallel search becomes obvious.
<br>
</p><div class="exercise">
<!--TOC paragraph id=sec155 Exercise 18-->
<h5 class="paragraph" id="sec155">Exercise 18</h5><!--SEC END --><p><a id="ex18"></a>
<a id="ex/qsort"></a>
Parallelize quicksort on arrays.
<a href="#exans18">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 18</arg>-->
<!--NAME exercise18.html-->
<div class="answer">
<!--TOC paragraph id=sec156 Answer of exercise 18-->
<h5 class="paragraph" id="sec156">Answer of <a href="#ex18">exercise 18</a></h5><!--SEC END --><p>
<a id="exans18"></a>
Quicksort lends itself well to parallelization, because the sorting is
done recursively on independent sub-arrays. This can be delegated to
threads whose only synchronization is to wait for all the threads to
finish their sorting, in order for the sub-array to be sorted.</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">let</span> qsort cmp arr =
<span class="c003">   2</span>   <span class="c006">let rec</span> qsort lo hi =
<span class="c003">   3</span>   <span class="c006">if</span> hi - lo &gt; 0 <span class="c006">then</span>
<span class="c003">   4</span>     <span class="c006">begin</span>
<span class="c003">   5</span>       <span class="c006">let</span> mid = (lo + hi) <span class="c006">lsr</span> 1 <span class="c006">in</span>
<span class="c003">   6</span>       <span class="c006">if</span> cmp arr.(mid) arr.(lo) <span class="c006">then</span> swap arr mid lo;
<span class="c003">   7</span>       <span class="c006">if</span> cmp arr.(hi) arr.(mid) <span class="c006">then</span>
<span class="c003">   8</span>         <span class="c006">begin</span>
<span class="c003">   9</span>           swap arr mid hi;
<span class="c003">  10</span>           <span class="c006">if</span> cmp arr.(mid) arr.(lo) <span class="c006">then</span> swap arr mid lo
<span class="c003">  11</span>         <span class="c006">end</span>;
<span class="c003">  12</span>       <span class="c006">let</span> pivot = arr.(mid) <span class="c006">in</span>
<span class="c003">  13</span>       <span class="c006">let</span> i = <span class="c006">ref</span> (lo + 1) <span class="c006">and</span> j = <span class="c006">ref</span> (hi - 1) <span class="c006">in</span>
<span class="c003">  14</span>       <span class="c006">while</span> !i &lt; !j <span class="c006">do</span>
<span class="c003">  15</span>         <span class="c006">while</span> not (cmp pivot arr.(!i)) <span class="c006">do</span> incr i <span class="c006">done</span>;
<span class="c003">  16</span>         <span class="c006">while</span> not (cmp arr.(!j) pivot) <span class="c006">do</span> decr j <span class="c006">done</span>;
<span class="c003">  17</span>         <span class="c006">if</span> !i &lt; !j <span class="c006">then</span> swap arr !i !j;
<span class="c003">  18</span>       <span class="c006">done</span>;
<span class="c003">  19</span>       <span class="c006">let</span> u = Thread.create (qsort lo) (!i-1) <span class="c006">in</span>
<span class="c003">  20</span>       <span class="c006">let</span> v = Thread.create (qsort (!i+1)) hi <span class="c006">in</span> <a id="prog:tcreate"></a>
<span class="c003">  21</span>       Thread.join u; <a id="prog:tjoin"></a>
<span class="c003">  22</span>       Thread.join v
<span class="c003">  23</span>     <span class="c006">end in</span>
<span class="c003">  24</span>   qsort 0 (Array.length arr - 1);;</div><p>
It would be correct, but uninteresting, to exchange
lines <a href="#prog%3Atcreate">20</a> and <a href="#prog%3Atjoin">21</a>.
In effect, that would wait for the lower portion of the array to be
sorted before starting the sort of the upper portion. We would thus
obtain the behavior of a sequential program, with the additional cost
of threads but without obtaining any benefit.</p><p>In practice, we should limit parallelization to a reasonable factor
and continue sequentially after that.
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->
<p>The other forms of suspension are tied to operating system resources.
A thread can be suspended for a certain time by calling <code>delay s</code>.
Once <code>s</code> seconds elapse, it can be restarted.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALdelay">delay</a><a id="hevea_default150"></a> : float -&gt; unit</div><p>This primitive is provided for portability with <span class="c005">vm</span>-level threads, but
<code>delay s</code> is simply an abbreviation for
<code>ignore (Unix.select [] [] [] s)</code>. This call, unlike <code>join</code>, is
not restarted when it is interrupted by a signal.</p><p>To synchronize a thread with an external operation, we can use the
<span class="c001">select</span><a id="hevea_default151"></a> command. Note that this will block only the
calling thread and not the entire program. (The <code>Thread</code> module
redefines this function, because in the case of simulated threads
calling the one in the <code>Unix</code> module would block the whole program
and therefore all the threads. It is therefore necessary to use
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALselect"><span class="c001">select</span></a> from the <code>Thread</code> module and not
<code>Unix.select</code>, even if the two are equivalent in the case of native
threads.)</p><div class="example">
<!--TOC paragraph id=sec157 Example-->
<h5 class="paragraph" id="sec157">Example</h5><!--SEC END --><p>
<a id="ex/crible-copro"></a>
To make the Sieve of Eratosthenes example of section <a href="#sec102">5.2</a>
work with threads instead of by duplication of Unix processes, 
it suffices to replace the 
lines <a href="#prog%3Asievefilterfork">5</a>–<a href="#prog%3Asievefilterdone">16</a> of the 
function <code>filter</code> by:

</p><div class="mylisting">    <span class="c006">let</span> p = Thread.create filter (in_channel_of_descr fd_in) <span class="c006">in
    let</span> output = out_channel_of_descr fd_out <span class="c006">in
    try
      while true do
        let</span> n = input_int input <span class="c006">in
        if</span> List.exists (<span class="c006">fun</span> m -&gt; n <span class="c006">mod</span> m = 0) first_primes <span class="c006">then</span> ()
        <span class="c006">else</span> output_int output n
      <span class="c006">done</span>;
    <span class="c006">with</span> End_of_file -&gt;
      close_out output;
      Thread.join p</div><p>and the lines <a href="#prog%3Asievefork">4</a>–<a href="#prog%3Agen">10</a> of the function
<code>sieve</code> by:

</p><div class="mylisting">  <span class="c006">let</span> k = Thread.create filter (in_channel_of_descr fd_in) <span class="c006">in
  let</span> output = out_channel_of_descr fd_out <span class="c006">in</span>
  generate len output;
  close_out output;
  Thread.join k;;</div><p>
However, we cannot expect any significant gain from this example,
which uses few processes relative to computation time.
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id=sec158 Synchronization among threads: locks-->
<h2 class="section" id="sec158">7.4  Synchronization among threads: locks</h2><!--SEC END --><p>
The functions in this section are defined in the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html"><span class="c001">Mutex</span></a> module (as in <code>Mut</code>ual <code>ex</code>clusion).<br>
</p><p>We mentioned above a problem of concurrent access to mutable
resources. In particular, the following scenario illustrates the
problem of access to shared resources. Consider a counter <span class="c004">c</span> and two
processes <span class="c004">p</span> and <span class="c004">q</span>, each incrementing the counter in parallel.</p><p>Assume the scenario described in figure <a href="#fig%2Fcompetition">6</a>.
Thread <span class="c004">p</span> reads the value of counter <span class="c004">c</span>, then gives control to <span class="c004">q</span>.
In its turn, <span class="c004">q</span> reads the value of <span class="c004">c</span>, then writes the value <span class="c004">k</span>+1
to <span class="c004">c</span>. The thread <span class="c004">p</span> resumes control and writes the value <span class="c004">k</span>+1 to
<span class="c004">c</span>. The final value of <span class="c004">c</span> is therefore <span class="c004">k</span>+1 instead of <span class="c004">k</span>+2.</p><div class="figure">
<div class="image"><img src="ocamlunix-image23.png" width="100%"></div>



<a id="fig/competition"></a>
<div class="caption">Figure 6 — Competition for access to a shared resource.</div></div><p>This classic problem can be resolved by using locks that
prevent arbitrary interleaving of <span class="c004">p</span> and <span class="c004">q</span>.</p><p>Locks are shared objects that can be held by at most a single thread
within a program at a time. A lock is created by the function
<code>create</code>.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html#VALcreate">create</a> : unit -&gt; t</div><p>This function returns a new lock, initially not held by any thread.
To acquire an existing lock, it is necessary to use the system call
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_mutex_lock.html"><span class="c001">lock</span></a><a id="hevea_default152"></a> with the lock as argument. If the lock is
held by another thread, the caller is frozen until the lock is released.
A lock must be released explicitly by the thread that holds it with
the system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_mutex_unlock.html"><span class="c001">unlock</span></a><a id="hevea_default153"></a>.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html#VALlock">lock</a> : t -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html#VALunlock">unlock</a> : t -&gt; unit</div><p>The <code>lock</code> call behaves like <code>Thread.join</code> with respect to
signals: if the thread receives a signal while executing <code>lock</code>,
the signal will be noted (i.e. the OCaml runtime will be notified
that the signal has arrived), but the thread will continue to wait so
that <code>lock</code> effectively returns only when the lock has been
acquired, and never raises the <code>EINTR</code> exception. The real
treatment of the signal by OCaml will happen only upon the return
from <code>lock</code>.</p><p>We can also try to acquire a lock without blocking with the system call
<a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_mutex_trylock.html"><span class="c001">trylock</span></a><a id="hevea_default154"></a>
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Mutex.html#VALtry_lock">try_lock</a> : t -&gt; bool</div><p>This function returns <code><span class="c006">true</span></code> if the lock has been acquired and
<code><span class="c006">false</span></code> otherwise. In the latter case, execution is not suspended
since the lock is not acquired. The thread can therefore do something
else and eventually return and try its luck later.</p><div class="example">
<!--TOC paragraph id=sec159 Example-->
<h5 class="paragraph" id="sec159">Example</h5><!--SEC END --><p>Incrementing a global counter used by several threads poses a
synchronization problem: the instants between reading the value of the
counter and writing the incremented value are in a critical region,
i.e. two threads cannot be in this region at the same time. The
synchronization can easily be managed with a lock.
</p><div class="mylisting"><span class="c006">type</span> counter = { lock : Mutex.t; <span class="c006">mutable</span> counter : int }
<span class="c006">let</span> newcounter () = { lock = Mutex.create (); counter = 0 }
<span class="c006">let</span> addtocounter c k =
  Mutex.lock c.lock;
  c.counter &lt;- c.counter + k;
  Mutex.unlock c.lock;;</div><p>The sole read operation on the counter poses no problem. It can be
performed in parallel with a modification of the counter: the result
will simply be the value of the counter just before or just after the
modification, both results being consistent.
</p><div class="fancybreak">* * *</div></div><p>A common pattern is to hold a lock temporarily during a function call.
It is of course necessary to make sure to release the lock at the end
of the call, whether the call succeeded or failed. We can abstract
this behavior in a library function:

</p><div class="mylisting"><span class="c006">let</span> run_with_lock l f x =
  Mutex.lock l; try_finalize f x Mutex.unlock l</div><p>In the preceding example, we could also have written:

</p><div class="mylisting"><span class="c006">let</span> addtocounter c =
  Misc.run_with_lock c.lock (<span class="c006">fun</span> k -&gt; c.counter &lt;- c.counter + k)</div><div class="example">
<!--TOC paragraph id=sec160 Example-->
<h5 class="paragraph" id="sec160">Example</h5><!--SEC END --><p>
An alternative to the model of the server with threads is to start a
number of threads in advance which handle requests in parallel.

</p><div class="mylisting"><span class="c006">val</span> tcp_farm_server :
  int -&gt; (file_descr -&gt; file_descr * sockaddr -&gt; 'a) -&gt; sockaddr -&gt; unit</div><p>The <code>tcp_farm_server</code> function behaves like <code>tcp_server</code> but
takes an additional argument which is the number of threads to start,
each of which will become a server at the same address. The advantage
of a pool of threads is to reduce the time to handle each connection
by eliminating the cost of creating a thread for it, since they are
created once and for all.

</p><div class="mylisting"><span class="c006">let</span> tcp_farm_server n treat_connection addr =
  <span class="c006">let</span> server_sock = Misc.install_tcp_server_socket addr <span class="c006">in
  let</span> mutex = Mutex.create () <span class="c006">in
  let rec</span> serve () =
    <span class="c006">let</span> client =
      Misc.run_with_lock mutex
        (Misc.restart_on_EINTR accept) server_sock <span class="c006">in</span>
    treat_connection server_sock client;
    serve () <span class="c006">in
  for</span> i = 1 <span class="c006">to</span> n-1 <span class="c006">do</span> ignore (Thread.create serve ()) <span class="c006">done</span>;
  serve ();;</div><p>The only precaution to take is to ensure mutual exclusion around the
<code>accept</code> so that only one of the threads accepts a connection at a
time. The idea is that the <code>treat_connection</code> function performs a
sequential treatment, but it is not a requirement — we can
effectively combine a pool of threads with the creation of new
threads, which can be dynamically adjusted depending on the load.
</p><div class="fancybreak">* * *</div></div><p>Acquisition of a lock is an inexpensive operation when it succeeds
without blocking. It is generally implemented with a single
“test-and-set” instruction provided by all modern processors
(plus other small costs that are involved, such as updating caches).
However, when the lock is not available, the process must be suspended
and rescheduled later, which involves a significant additional cost.
We must therefore incur this penalty only for a real suspension of a
process in order to give control to another, and not for its potential
suspension during the acquisition of a lock. Consequently, we will
almost always want to release a lock as soon as possible and take it
back later if necessary, rather than simply holding onto the lock.
Avoiding these two operations would have the effect of enlarging the
critical region and therefore the frequency with which another thread
finds itself effectively in competition for the lock and in need of
suspension.</p><p>Locks reduce interleaving. In return, they increase the risk of
deadlock. For example, there is a deadlock if a thread <span class="c004">p</span> waits for
a lock <span class="c004">v</span> held by a thread <span class="c004">q</span> which itself waits for a lock <span class="c004">u</span> held
by <span class="c004">p</span>. (In the worst case, a thread waits for a lock that it holds
itself.) Concurrent programming is difficult, and guarding against
deadlock is not always easy. A simple way of avoiding this situation
that is often possible consists of defining a hierarchy among the
locks and ensuring that the order in which the locks are acquired
dynamically respects the hierarchy: a thread never acquires a lock
unless that lock is dominated by all the other locks that the thread
already holds.</p>
<!--TOC section id=sec161 Complete example: <span class="c005">http</span> relay-->
<h2 class="section" id="sec161">7.5  Complete example: <span class="c005">http</span> relay</h2><!--SEC END --><p>We modify the <span class="c005">http</span> relay developed in section <a href="#sec144">6.14</a> so
that it services requests using threads.</p><p>Intuitively, it suffices to replace the <code>establish_server</code> function
that creates a process clone with a function that creates a
thread. We must however take certain precautions. The challenge
with threads is that they share the entire memory space. We must
therefore ensure that the threads are not “stepping on each
other’s toes” with one undoing what was just done by another.
That typically happens when two threads modify the same mutable
structure in parallel.</p><p>In the case of the <span class="c005">http</span> server, there are several changes to make.
Let us start by resolving problems with access to resources. The
<code>proxy_service</code> function, described in section <a href="#sec144">6.14</a>,
handles the treatment of connections. Via the intermediary functions
<code>parse_host</code>, <code>parse_url</code> and <code>parse_request</code>, it calls the
<code>regexp_match</code> function which uses the <code>Str</code> library. However,
this library is not re-entrant (the result of the last search is
stored in a global variable). This example shows that we must beware
of calls to innocent-looking functions that hide potential collisions.
In this case we will not rewrite the <code>Str</code> library but simply
sequentialize its use. It suffices to protect calls to this library
with locks (and there is really no other choice). We must still take
the precaution of releasing the lock when returning from the function
abnormally due to an exception.</p><p>To modify the existing code as little as possible, we can just rename
the definition of <code>regexp_match</code> in the <code>Url</code> module as
<code>unsafe_regexp_match</code> and then define <code>regexp_match</code> as a
protected version of <code>unsafe_regexp_match</code>.

</p><div class="mylisting"><span class="c006">let</span> strlock = Mutex.create ();;
<span class="c006">let</span> regexp_match r string =
  Misc.run_with_lock strlock (unsafe_regexp_match r) string;;</div><p>The change is rather minimal. It should be noted that the
<code>regexp_match</code> function includes both the expression matching and
the extraction of the matched groups. It would definitely have been
incorrect to protect the <code>Str.string_match</code> and
<code>Str.matched_group</code> functions individually.</p><p>Another solution would be to rewrite the analysis functions without using
the <code>Str</code> library. But there is no reason for such a choice, since
synchronizing the library primitives is easy to do and does not turn
out to be a source of inefficiency. Obviously, a better solution
would be for the <code>Str</code> library to be re-entrant in the first place.</p><p>The other functions that are called are already re-entrant, in particular
the <code>Misc.retransmit</code> function that allocates different buffers for
each call.</p><p>However, there are still some precautions to take regarding error
handling. The handling of a connection by a thread must be robust, as
explained above. In particular, in case of error, the other threads
must not be affected. In other words, the thread must terminate
“normally”, properly closing the connection in question and
going back to accepting other pending connections. We must first of
all replace the call to <code>exit</code> in <code>handle_error</code> because it is
essential not to kill the whole process. A call to <code>Thread.exit</code>
would not be correct either, because thread termination does not close
its (shared) descriptors, the way the system does for process
termination. An error in the handling of a connection would leave the
connection open. The solution consists of raising an <code>Exit</code>
exception that allows the finalization code to do what is required.
We must now protect <code>treat_connection</code> by catching all errors, in
particular <code>Exit</code> but also <code>EPIPE</code>, which can be raised if the
client closes the connection prematurely. We will take care of this
by using a protected function.


</p><div class="mylisting"><span class="c006">let</span> allow_connection_errors f s =
  <span class="c006">try</span> f s <span class="c006">with</span> Exit | Unix_error(EPIPE,_,_) -&gt; ()</div><div class="mylisting"><span class="c006">let</span> treat_connection s =
  Misc.co_treatment s (allow_connection_errors proxy_service) <span class="c006">in</span></div><div class="exercise">
<!--TOC paragraph id=sec162 Exercise 19-->
<h5 class="paragraph" id="sec162">Exercise 19</h5><!--SEC END --><p><a id="ex19"></a>
Rewrite the proxy for the <span class="c005">http</span>/1.1 protocol using threads.
</p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id=sec163 Exercise 20-->
<h5 class="paragraph" id="sec163">Exercise 20</h5><!--SEC END --><p><a id="ex20"></a>
Coroutines can be seen as a very particular kind of threads where each
process must surrender control explicitly before another can execute.
Give an implementation of coroutines using threads.
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id=sec164 Conditions-->
<h2 class="section" id="sec164">7.6  Conditions</h2><!--SEC END --><p>The functions described in this section are defined in the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Condition.html"><span class="c001">Condition</span></a> module.</p><p>Synchronization with locks is very simple, but it is not sufficient:
locks allow waiting for shared data to be free, but do not allow
waiting for the data to have a particular state. Let us replace the
example of a counter by a (first-in/first-out) queue shared among
several threads. Adding a value to the queue can be synchronized by
using a lock as above, since no matter what the state of the queue,
we can always add an element. But what about removing an element
from the queue? What should be done when the queue is empty? We
cannot hold the lock while waiting for the queue to be filled, because
that would completely prevent another thread from filling the queue.
So it must be released. But how can we know when the queue is no
longer empty, except by testing it periodically? This solution,
called “busy-waiting”, is definitely not satisfactory. Either
it consumes computing cycles unnecessarily (period too short) or else
it it is not reactive enough (period too long).</p><p><em>Conditions</em> provide a solution to this problem. A thread that
holds a lock can wait for a condition object until another thread
sends a signal on that condition. As with locks, conditions are
passive structures that can be manipulated by synchronization
functions. They can be created by the <code>create</code>
function.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Condition.html#VALcreate">create</a> : unit -&gt; t</div><p>A process <span class="c004">p</span> that <em>already holds</em> a lock <code>v</code> can wait on a
condition <code>c</code> and the lock <code>v</code> with the system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_cond_wait.html"><span class="c001">wait</span></a><a id="hevea_default155"></a>.
The process <span class="c004">p</span> informs the system that it is waiting on the condition
<code>c</code> and the lock <code>v</code>, then releases the lock <code>v</code> and goes to
sleep. It will not be woken up by the system until another thread <span class="c004">q</span>
signals a change on the condition <code>c</code> and the lock <code>v</code> is
available; the process <span class="c004">p</span> will then hold the lock <code>v</code> again.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Condition.html#VALwait">wait</a> : t -&gt; Mutex.t -&gt; unit</div><p>Note: it is an error to call <code>wait c v</code> without holding the lock
<code>v</code>. The behavior of <code>wait c v</code> with respect to signals is the
same as for <code>Mutex.lock</code>.</p><p>When a thread signals a change on a condition, it can either ask for
all threads waiting on that condition to be woken up
(system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_cond_broadcast.html"><span class="c001">broadcast</span></a><a id="hevea_default156"></a>), or else for just one of them to be
woken up (system call <a href="http://www.opengroup.org/onlinepubs/009696799/functions/pthread_cond_signal.html"><span class="c001">signal</span></a><a id="hevea_default157"></a>).
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Condition.html#VALsignal">signal</a> : t -&gt; unit
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Condition.html#VALbroadcast">broadcast</a> : t -&gt; unit</div><p>Sending a signal or a broadcast on a condition does not require
holding a lock (unlike waiting), in the sense that it will not trigger
a “system” error.
However, it can sometimes be a programming error.
</p><p>The choice between waking up one thread or all the threads depends on
the problem. To consider the example of the queue again, if a thread
adds an element to an empty queue, there is no need to wake up all the
others, since only one will effectively be able to remove that
element. On the other hand, if it adds a number of elements that is
either not statically known or very large, it must wake up all the
threads. Note that if adding an element to a non-empty queue does not
send a signal, then adding an element to an empty queue must send a
broadcast, since it could be followed immediately by another addition
(without a signal) and therefore behave like a multiple addition.
In summary, either send a signal on every addition, or send a
broadcast only when adding to an empty queue.
The choice between these two strategies is a bet on whether the queue
is usually empty (first solution) or usually non-empty (second
solution).</p><p>Often, one thread knows only an approximation of the reason why
another thread is waiting on a condition. It will therefore signal
the condition whenever the situation <em>might</em> be what the other
thread is waiting for. An awakened thread, therefore, cannot assume
that the condition it was waiting is now satisfied. It must, in
general, re-test the state of its shared data, and if necessary wait
on the condition again. This does not constitute busy-waiting, because
it only happens when another thread signals the condition.</p><p>Here is another justification for this approach: when a thread has
just produced a lot of some resource and wakes all the others using a
<code>broadcast</code>, nothing prevents the first one that wakes up from
being greedy and exhausting the entire resource. The second one to
wake up must go back to sleep, hoping to be luckier next time.</p><p>We can now give a concrete solution for shared queues. The queue
structure defined in the <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Queue.html"><span class="c001">Queue</span></a> module is extended with a lock and
a <code>non_empty</code> condition.
</p><div class="mylisting"><span class="c003">   1</span> <span class="c006">type</span> 'a t =
<span class="c003">   2</span>   { queue : 'a Queue.t; lock : Mutex.t; non_empty : Condition.t }
<span class="c003">   3</span> <span class="c006">let</span> create () =
<span class="c003">   4</span>   { queue = Queue.create ();
<span class="c003">   5</span>     lock = Mutex.create (); non_empty = Condition.create () }
<span class="c003">   6</span> 
<span class="c003">   7</span> <span class="c006">let</span> add e q =
<span class="c003">   8</span>   Mutex.lock q.lock;
<span class="c003">   9</span>   <span class="c006">if</span> Queue.length q.queue = 0 <span class="c006">then</span> Condition.broadcast q.non_empty;<a id="prog:broadcast"></a>
<span class="c003">  10</span>   Queue.add e q.queue;
<span class="c003">  11</span>   Mutex.unlock q.lock;;
<span class="c003">  12</span> 
<span class="c003">  13</span> <span class="c006">let</span> take q =
<span class="c003">  14</span>   Mutex.lock q.lock;
<span class="c003">  15</span>   <span class="c006">while</span> Queue.length q.queue = 0 <a id="prog:lock"></a>
<span class="c003">  16</span>   <span class="c006">do</span> Condition.wait q.non_empty q.lock <span class="c006">done</span>;  <a id="prog:slock"></a>
<span class="c003">  17</span>   <span class="c006">let</span> x = Queue.take q.queue <span class="c006">in</span>
<span class="c003">  18</span>   Mutex.unlock q.lock; x;;</div><p>Addition never blocks, but we must not forget to signal
the <code>non_empty</code> condition when the list is empty beforehand,
because it is possible that someone is waiting on the condition.</p><p>Removal is a little more complicated: after acquiring the lock, we
must try to remove an element from the queue. If the queue is empty,
we must wait on the <code>non_empty</code> condition. When awakened, we try
again, knowing that we already have the lock.</p><p>As explained above, the <code>broadcast q.non_empty</code> signal
(line <a href="#prog%3Abroadcast">9</a>) is executed by a thread <span class="c004">p</span> already in
possession of the lock <code>q.lock</code>.
This implies that a reader thread <span class="c004">q</span> executing the <code>take</code> function
cannot be between line <a href="#prog%3Alock">15</a> and <a href="#prog%3Aslock">16</a>
where it would have verified that the queue is empty but not yet have
gone to sleep. In this case, the signal sent by <span class="c004">p</span> would be
ineffective and ignored, since <span class="c004">q</span> has not gone to sleep yet; but <span class="c004">q</span>
would then go to sleep and not be woken up, because <span class="c004">p</span> has already
sent its signal.
The lock therefore guarantees that either <span class="c004">q</span> is already asleep or
else has not yet tested the state of the queue.</p><div class="exercise">
<!--TOC paragraph id=sec165 Exercise 21-->
<h5 class="paragraph" id="sec165">Exercise 21</h5><!--SEC END --><p><a id="ex21"></a>
Implement a variant in which the queue is bounded: addition to the
queue becomes blocking when the size of the queue reaches a fixed
value. (In a concurrent world, we might need this scheme to avoid
having a producer that produces endlessly while the consumer is
blocked.)
<a href="#exans21">Answer</a>.</p><div class="fancybreak">* * *</div></div><!--FLOW <arg footer>YES</arg><arg title>Answer of exercise 21</arg>-->
<!--NAME exercise21.html-->
<div class="answer">
<!--TOC paragraph id=sec166 Answer of exercise 21-->
<h5 class="paragraph" id="sec166">Answer of <a href="#ex21">exercise 21</a></h5><!--SEC END --><p>
<a id="exans21"></a>
We must introduce an additional <code>non_full</code> condition.
We also add a <code>size</code> field to allow queues of different sizes.
</p><div class="mylisting"><span class="c006">type</span> 'a t =
    { queue : 'a Queue.t; size : int; lock : Mutex.t;
      non_empty : Condition.t; non_full : Condition.t; }

<span class="c006">let</span> create k =
  <span class="c006">if</span>  k &gt; 0 <span class="c006">then</span>
    { queue = Queue.create (); size = k; lock = Mutex.create ();
      non_empty = Condition.create (); non_full = Condition.create () }
  <span class="c006">else</span> failwith "Tqueue.create: empty size";;</div><p>Addition is a combination of the preceding versions of the
<code>add</code> and <code>take</code> functions above.
</p><div class="mylisting"><span class="c006">let</span> add x q =
  Mutex.lock q.lock;
  <span class="c006">while</span> Queue.length q.queue = q.size
  <span class="c006">do</span> Condition.wait q.non_full q.lock <span class="c006">done</span>;
  <span class="c006">if</span> Queue.is_empty q.queue <span class="c006">then</span> Condition.broadcast q.non_empty;
  Queue.add q x;
  Mutex.unlock q.lock;;</div><p>Removal is symmetric to addition (and must now signal <code>non_full</code>
when the queue is full beforehand), and is left to the reader.

We get the behavior of unbounded queues by choosing <code>max_int</code> for
<code>size</code>.
</p><div class="fancybreak">* * *</div></div><!--END FLOW-->

<!--TOC section id=sec167 Event-based synchronous communication-->
<h2 class="section" id="sec167">7.7  Event-based synchronous communication</h2><!--SEC END --><p>The functions described in this section are defined in the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html"><span class="c001">Event</span></a> module.</p><p>Locks and conditions together allow all forms of synchronization to be
expressed. However, their use is not always easy, as shown
by the example of the initially simple queue whose synchronization
code subsequently turned out to be subtle.</p><p>Event-based synchronous communication is a collection of higher-level
communication primitives that tend to facilitate concurrent
programming. The primitives in the <code>Event</code> module were initially
developed by John Reppy as an extension of the <em>Standard ML</em>
language called <em>Concurrent ML</em> [<a href="#CML">16</a>]. In OCaml, these
primitives are located above the more elementary synchronization of
locks and conditions.</p><p>Communication occurs by sending <em>events</em> along <em>channels</em>.
Channels are like “lightweight pipes”: they allow communication
among threads in the same program and take care of synchronization
between producers and consumers. A channel carrying values of type
<code>'a</code> has the type <code>'a Event.channel</code>. Channels are homogeneous
and therefore always carry values of the same type. A channel is
created with the <code>new_channel</code> function.

</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALnew_channel">new_channel</a><a id="hevea_default158"></a> : unit -&gt; 'a channel</div><p>Sending or receiving a message is not done directly, but through the
intermediary of an event. An elementary event is “sending a
message” or “receiving a message”. They are constructed by
means of the following primitives:
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALsend">send</a><a id="hevea_default159"></a> : 'a channel -&gt; 'a -&gt; unit event
<span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALreceive">receive</a><a id="hevea_default160"></a> : 'a channel -&gt; 'a event</div><p>Construction of a message does not have an immediate effect: it just
creates a data structure describing the action to be done. To make an
event happen, the thread must synchronize with another thread wishing
to make the complementary event happen. The <code>sync</code> primitive
allows a thread to wait for the occurrence of the event passed
as argument.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALsync">sync</a><a id="hevea_default161"></a> : 'a event -&gt; 'a</div><p>Thus, to send a value <code>v</code> on the channel <code>c</code>, we can execute
<code>sync (send c v)</code>. The thread is suspended until the event occurs,
that is to say until another thread is ready to receive a value on the
channel <code>c</code>. In a symmetric fashion, a thread can wait for a
message on channel <code>c</code> by performing <code>sync (receive c)</code>.</p><p>There is a competition among all the producers on one hand and all the
consumers on the other. For example, if several threads try to send a
message on a channel but only one is ready to read it, it is clear
that only one producer will make the event occur. The others will
remain suspended, without even noticing that another was
“served” ahead of them.</p><p>The competition can also occur within the same thread.
Multiple events can be combined by the <code>choose</code> primitive.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALchoose">choose</a><a id="hevea_default162"></a> : 'a event list -&gt; 'a event</div><p>The resulting event is an offer, in parallel, of the events passed as
arguments, and occurs when exactly one of them occurs. We distinguish
between the offer of an event and its occurrence. The call
<code>sync (choose [e1; e2])</code> synchronizes by offering a choice of two events
<code>e1</code> and <code>e2</code>, but only one of the two events will effectively
occur (the offer of the other event will be simultaneously canceled).
The <code>wrap_abort</code> primitive allows to handle an event being
canceled.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALwrap_abort">wrap_abort</a><a id="hevea_default163"></a> : 'a event -&gt; (unit -&gt; unit) -&gt; 'a event</div><p>The call <code>wrap_abort e f</code> creates an event that is equivalent to
<code>e</code>, but if it is not chosen during synchronization, then the
function <code>f</code> is executed. (This is only interesting when it is
part of a complex event.)</p><p>A thread can try to synchronize on an event without blocking (somewhat
like <code>Mutex.try_lock</code>) with <code>poll</code>.
</p><div class="mylisting"><span class="c006">val</span> <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Event.html#VALpoll">poll</a><a id="hevea_default164"></a> : 'a event -&gt; 'a option</div><p>The call <code>poll e</code> offers the event <code>e</code> but if it cannot occur
immediately, it cancels the offer rather than blocking and has no
effect (or more exactly, behaves as if the expression <code>poll e</code> had
been replaced by the value <code>None</code>). By contrast, if the event can
happen immediately, then it behaves as if the thread had done
<code>sync e</code>, except that the value <code>Some v</code> is returned
rather than <code>v</code>.</p><div class="example">
<!--TOC paragraph id=sec168 Example-->
<h5 class="paragraph" id="sec168">Example</h5><!--SEC END --><p>
In section <a href="#ex%2Fcrible-copro">7.3</a> the example of the Sieve of Eratosthenes,
the communication between different threads is done with pipes as in
the original program, using system memory (the pipe) as intermediary.
We may think that it is more efficient to communicate
directly by using the memory of the process. A simple solution
consists of replacing the pipe by a channel on which integers are sent.</p><p>Sending integers on the channel is not sufficient, because we must
also be able to detect the end of the stream. The simplest is
therefore to pass elements of the form <code>Some n</code> and to terminate by
sending the value <code>None</code>. To minimize the changes, we use the code
of the example in section <a href="#sec102">5.2</a>. We simulate pipes and the
functions for reading and writing pipes by channels and functions for
reading and writing channels.</p><p>It is sufficient to take the previous version of the program and
change the input/output functions to ones that read and write a channel,
rather than an input/output buffer from the <code>Pervasives</code> library.
For example, we can insert the following code at the beginning of the
program just after the <code><span class="c006">open</span> Unix;;</code> directive:

</p><div class="mylisting"><span class="c006">let</span> pipe () = <span class="c006">let</span> c = Event.new_channel () <span class="c006">in</span> c, c
<span class="c006">let</span> out_channel_of_descr x = x
<span class="c006">let</span> in_channel_of_descr x = x

<span class="c006">let</span> input_int chan =
  <span class="c006">match</span> Event.sync (Event.receive chan) <span class="c006">with</span>
  | Some v -&gt; v
  | None -&gt; raise End_of_file
<span class="c006">let</span> output_int chan x = Event.sync (Event.send chan (Some x))
<span class="c006">let</span> close_out chan = Event.sync (Event.send chan None);;</div><p>However, if we compare the efficiency of this version with the
previous one, we find that it is twice as slow. Communication of each
integer requires a synchronization between two threads and therefore
several system calls for acquiring and releasing locks. On the other
hand, communication via pipes uses buffered <span class="c005">i/o</span> that allows several
thousand integers to be exchanged with each system call.</p><p>To be fair, one should also provide buffered communication on
channels, using the channel only to exchange a packet of integers.
The child can accumulate the results in a private queue, to which it
can therefore write without synchronization. When the queue is full,
or upon an explicit request, it is emptied by synchronizing on the
channel. The parent has its own queue that it receives by
synchronizing and empties gradually.</p><p>Here is a solution:

</p><div class="mylisting"><span class="c006">type</span> 'a buffered =
    { c : 'a Queue.t Event.channel;
      <span class="c006">mutable</span> q : 'a Queue.t;
      size : int }

<span class="c006">let</span> pipe () = <span class="c006">let</span> c = Event.new_channel () <span class="c006">in</span> c, c;;

<span class="c006">let</span> size = 1024;;
<span class="c006">let</span> out_channel_of_descr chan =
  { c = chan; q = Queue.create (); size = size };;
<span class="c006">let</span> in_channel_of_descr = out_channel_of_descr;;

<span class="c006">let</span> input_int chan =
  <span class="c006">if</span> Queue.length chan.q = 0 <span class="c006">then begin
    let</span> q = Event.sync (Event.receive chan.c) <span class="c006">in
    if</span> Queue.length q &gt; 0 <span class="c006">then</span> chan.q &lt;- q
    <span class="c006">else</span> raise End_of_file
  <span class="c006">end</span>;
  Queue.take chan.q;;

<span class="c006">let</span> flush_out chan =
  <span class="c006">if</span> Queue.length chan.q &gt; 0 <span class="c006">then</span> Event.sync (Event.send chan.c chan.q);
  chan.q &lt;- Queue.create ();;

<span class="c006">let</span> output_int chan x =
  <span class="c006">if</span> Queue.length chan.q = size <span class="c006">then</span> flush_out chan;
  Queue.add x chan.q

<span class="c006">let</span> close_out chan =
  flush_out chan;
  Event.sync (Event.send chan.c chan.q);;</div><p>
This version allows us to regain efficiency comparable to (but not
better than) the version with pipes.</p><p>Compared to the original version with processes and pipes, there are
two potential advantages. First, threads are more lightweight and less
costly to launch. Second, communication on a channel merely passes a
pointer, without copying. But these advantages are not noticeable
here, because the number of threads created and the data exchanged are
not big enough compared to the cost of system calls and compute time.</p><p>In conclusion, we can say that communication between threads has a
cost of up to one system call (if the process must be suspended) and
the cost can be significantly reduced by buffering communication and
sending larger structures less often.
</p><div class="fancybreak">* * *</div></div><div class="exercise">
<!--TOC paragraph id=sec169 Exercise 22-->
<h5 class="paragraph" id="sec169">Exercise 22</h5><!--SEC END --><p><a id="ex22"></a>
An <span class="c005">http</span> server can be subjected to a high, bursty load. To improve
response time, we can refine the architecture of an <span class="c005">http</span> server by
always keeping a dozen threads ready to handle new requests. This means
that a thread does not handle only a single request, but a potentially
infinite series of requests that it reads from a queue.</p><p>To avoid overloading the machine, we can limit the number of threads
to a reasonable value beyond which the overhead of managing tasks
exceeds the latency for servicing requests (time spent waiting for
data on disk, etc.). After that, we can keep some connections waiting
to be handled, and then finally we can refuse connections. When the
load diminishes and the number of threads is above the “ideal”
value, some of them are allowed to die and the others remain ready for
the next requests.</p><p>Transform the example of section <a href="#sec161">7.5</a> into this architecture.
</p><div class="fancybreak">* * *</div></div>
<!--TOC section id=sec170 Implementation details-->
<h2 class="section" id="sec170">7.8  Implementation details</h2><!--SEC END -->
<!--TOC paragraph id=sec171 Implementation of threads in Unix-->
<h5 class="paragraph" id="sec171">Implementation of threads in Unix</h5><!--SEC END --><p>The Unix system was not originally designed to provide support for
threads. However, most modern Unix implementations now offer such
support. Nevertheless, threads remain an add-on that is sometimes
apparent. For example, when using threads it is strongly discouraged
to use <span class="c001">fork</span><a id="hevea_default165"></a> except when doing <code>exec</code> immediately afterward.
In effect, <code>fork</code> copies the current thread, which becomes a
crippled process that runs believing it has threads when in fact they
do not exist. The parent continues to run normally as before.
The special case of a call to <code>fork</code> where the child immediately
launches another program does not cause the parent any problem.
Luckily, since that is the only way to start other programs!</p><p>Inversely, one can do <code>fork</code> (not followed by <code>exec</code>), and then launch
several threads in the child and the parent, without any problem.</p>
<!--TOC paragraph id=sec172 Native and simulated implementation in OCaml-->
<h5 class="paragraph" id="sec172">Native and simulated implementation in OCaml</h5><!--SEC END --><p>When the underlying operating system has threads, OCaml can provide
a native implementation of threads, leaving their management to the
operating system as much as possible. Each thread then lives in a
different Unix process but shares the same address space.</p><p>When the system does not provide support for threads, OCaml can
emulate them. All the threads then execute in the same Unix process,
and their management, including their scheduling, is handled by the
OCaml runtime system. However, this implementation is only
available when compiling to bytecode.</p><p>The OCaml system provides the same programming interface for the
native and simulated versions of threads. The implementation of
threads is therefore split: one implementation for the emulated
version that includes its own task controller, and another
implementation that is based on <span class="c005">posix</span> (1003.1c) threads and
lifts the corresponding library functions to the level of the OCaml
language. In the process, the OCaml language handles certain
simple administrative tasks and ensures an interface identical to the
emulated version. This guarantees that a program compilable on one
Unix architecture remains compilable on another Unix architecture.
However, whether threads are emulated or native can change the
synchronization of calls to the C library, and therefore change,
despite everything, the semantics of the program. It is therefore
necessary to take certain precautions before believing that a program
will behave the same way in these two versions. In this chapter, the
discussion mainly concern these two implementations, but recall
that by default, we have taken the viewpoint of a native
implementation.</p><p>To use emulated threads, one must pass the <code>-vmthread</code> option
instead of <code>-thread</code> to the <code>ocamlc</code> compiler. This option is
not accepted by the <code>ocamlopt</code> compiler.</p>
<!--TOC paragraph id=sec173 Sequentialization of OCaml code-->
<h5 class="paragraph" id="sec173">Sequentialization of OCaml code</h5><!--SEC END --><p>The implementation of threads in OCaml must face one of the
peculiarities of the OCaml language: the automatic management of
memory and its high consumption of allocated data. The solution
adopted, which is the simplest and also generally the most efficient,
is to sequentialize the execution of OCaml code in all threads: a
lock in the runtime system prevents two threads from executing
OCaml code simultaneously. This seems contrary to the whole idea
of threads, but it is not, since the lock is released before blocking
system calls and reacquired upon return. Other threads can therefore
take control at that moment. A special case of such a system call is
the call to
<a href="http://www.opengroup.org/onlinepubs/007908799/xsh/sched_yield.html"><span class="c001">sched_yield</span></a>,
performed at regular intervals to suspend the running thread and give
control to another.</p><p>On a multiprocessor machine, the only source of true parallelism comes
from the execution of C code and system calls. On a uniprocessor
machine, the fact that the OCaml code is sequentialized is not
really noticeable.</p><p>The programmer cannot rely on this sequentialization, because one
thread can give control to another at almost any moment. With one
exception, the sequentialization guarantees memory coherence: two
threads always have the same view of memory, except perhaps when they
execute C code. In effect, the passing of the lock implies a
synchronization of the memory: a read operation by one thread
occurring after a write operation to the same address by another
thread will always return the freshly-written value, with no need for
additional synchronization.</p>
<!--TOC paragraph id=sec174 Threads and signals-->
<h5 class="paragraph" id="sec174">Threads and signals</h5><!--SEC END --><p>Generally speaking, using signals is already delicate with a single
thread due to their asynchronous character. It is even more so in the
presence of multiple threads because of the addition of new
difficulties: which thread should a signal be sent to? To all, to the
primary one, or to the one currently running? What happens if one
thread sends a signal to another? In fact, threads were implemented
before answering these questions, and different implementations can
behave differently with respect to signals.</p><p>The <code>Thread.join</code>, <code>Mutex.lock</code>, and <code>Condition.wait</code> functions
despite being long system calls, are not interruptible by a signal.
(They cannot therefore fail with the <code>EINTR</code> error.) If a signal
is sent while waiting, it will be received and handled when the call
returns.</p><p>The <span class="c005">posix</span> standard specifies that the signal handler is
shared among all the threads and in contrast the signal mask is
private to each thread and inherited upon creation of a thread. But
the behavior of threads with respect to signals remains largely
underspecified and therefore non-portable.</p><p>It is therefore preferable to avoid as much as possible the use of
asynchronous signals (such as <code>sigalrm</code>, <code>sigvtalrm</code>,
<code>sigchld</code>, etc.) with threads. These can be blocked and examined
with <code>Thread.</code><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Thread.html#VALwait_signal"><span class="c001">wait_signal</span></a>. 
We can dedicate a thread to signal
handling and nothing else: it can wait for the reception of signals,
undertake the necessary actions, and update certain information
examined by other threads.</p><p>In addition, OCaml threads (since version 3.08) use the
<code>sigvtalarm</code> signal internally to implement preemption of threads.
This signal is therefore reserved and must not be used by the program
itself, since there is a risk of interference.</p><!--TOC chapter id=sec175 Going further-->
<h1 class="chapter" id="sec175"><a id="htocmore">G</a>oing further</h1><!--SEC END --><!--NAME more.html-->
<p>We have shown how OCaml’s <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Sys.html"><span class="c001">Sys</span></a>, <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Unix.html"><span class="c001">Unix</span></a>, and
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Threads.html"><span class="c001">Threads</span></a> modules can be used to program applications that
interact with the operating system.</p><p>These modules allow the invocation of the most important Unix system calls
directly from OCaml. Some of these calls were replaced by higher-level
functions, either to facilitate programming or to maintain invariants
needed by OCaml’s runtime system. In any case, this higher-level
access to the Unix system streamlines the development of applications.</p><p>Not every feature of the Unix system is available through these
modules, however it is still possible to access the missing ones by
writing C bindings.</p><p>Another useful library is Cash [<a href="#Cash">3</a>] which focuses on writing
scripts directly in OCaml. This library completes the <code>Unix</code>
module in two different ways. First, in addition to a few helper
functions to write scripts, it provides, on top of the <code>Unix</code>
module, a few system call variations to assist the programmer in
process and pipe management. Second, it offers additional entry points
to the Unix system.
</p><!--TOC chapter id=sec176 References-->
<h1 class="chapter" id="sec176"><a id="htocrefs">R</a>eferences</h1><!--SEC END --><dl class="thebibliography"><dt class="dt-thebibliography">

<!--NAME references.html-->

<dt class="bibsection">OCaml</dt><a id="Caml-Light">[1]</a></dt><dd class="dd-thebibliography">
Xavier Leroy, Michel Mauny. <em>The Caml Light system, release 0.5.
Documentation and user’s manual.</em> L-5 software, distributed by <span class="c005">inria</span>.</dd><dt class="dt-thebibliography"><a id="OCaml">[2]</a></dt><dd class="dd-thebibliography">
Xavier Leroy, Didier Rémy, Jacques Garrigue, Jérôme Vouillon and
Damien Doligez.
<em>The OCaml system,
documentation and user’s manual – release 3.06.</em>
Documentation distributed by <span class="c005">inria</span> with the OCaml
system, August 2002.
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/"><span class="c001">http://caml.inria.fr/pub/docs/manual-ocaml/</span></a>.</dd><dt class="dt-thebibliography"><a id="Cash">[3]</a></dt><dd class="dd-thebibliography">
Bruno Verlyck.
<em>Cash, the Caml Shell – release 0.20</em>.
Documentation distributed by <span class="c005">inria</span> with the Cash system, 2002. 
<a href="http://pauillac.inria.fr/cash/"><span class="c001">http://pauillac.inria.fr/cash/</span></a>.<dt class="bibsection">Unix system programming</dt></dd><dt class="dt-thebibliography"><a id="man">[4]</a></dt><dd class="dd-thebibliography">
The Unix <span class="c001">man</span>ual, sections 2 and 3.</dd><dt class="dt-thebibliography"><a id="KP">[5]</a></dt><dd class="dd-thebibliography">
Brian Kernighan, Rob Pike. <em>The Unix programming
environment</em>, Addison-Wesley.</dd><dt class="dt-thebibliography"><a id="R1">[6]</a></dt><dd class="dd-thebibliography"> 
Jean-Marie Rifflet. <em>La programmation sous Unix</em>. McGraw-Hill.</dd><dt class="dt-thebibliography"><a id="R2">[7]</a></dt><dd class="dd-thebibliography">
Jean-Marie Rifflet. <em>La communication sous Unix</em>. McGraw-Hill.<dt class="bibsection">Unix kernel architecture</dt></dd><dt class="dt-thebibliography"><a id="BSD">[8]</a></dt><dd class="dd-thebibliography">
Samuel Leffler, Marshall McKusick, Michael Karels, John Quarterman.
<em>The design and implementation of the 4.3 <span class="c005">bsd</span>
Unix operating system</em>,
Addison-Wesley.</dd><dt class="dt-thebibliography"><a id="Bach">[9]</a></dt><dd class="dd-thebibliography">
Maurice Bach. <em>The design and implementation of the Unix operating
system</em>, Prentice-Hall.</dd><dt class="dt-thebibliography"><a id="Stevens/advanced">[10]</a></dt><dd class="dd-thebibliography">
Richard W. Stevens.
<em>Advanced Programming in the Unix Environment</em>.
Addison-Wesley, 1992.</dd><dt class="dt-thebibliography"><a id="Kay-Stevens/Practical">[11]</a></dt><dd class="dd-thebibliography">
Kay A. Robbins and Steven Robbins.
<em>Practical Unix Programming.
A Guide to Concurrency, Communication, and Multithreading</em>.
Prentice Hall, 1996.<dt class="bibsection">General knowledge on operating systems</dt></dd><dt class="dt-thebibliography"><a id="T3">[12]</a></dt><dd class="dd-thebibliography">
Andrew Tanenbaum. <em>Modern Operating Systems</em>,
Second Edition, Prentice-Hall, 2001. </dd><dt class="dt-thebibliography"><a id="T1">[13]</a></dt><dd class="dd-thebibliography">
Andrew Tanenbaum. <em>Operating systems, design and implementation</em>,
Prentice-Hall.</dd><dt class="dt-thebibliography"><a id="T2">[14]</a></dt><dd class="dd-thebibliography">
Andrew Tanenbaum. <em>Computer Networks</em>, Prentice-Hall.<dt class="bibsection">Typed communication of structured objects</dt></dd><dt class="dt-thebibliography"><a id="Dynamiques">[15]</a></dt><dd class="dd-thebibliography">
Xavier Leroy, Michel Mauny. <em>Dynamics in ML</em>. Actes de <span class="c005">fpca</span> 91,
<span class="c005">lncs</span> 523, Springer-Verlag.</dd><dt class="dt-thebibliography"><a id="CML">[16]</a></dt><dd class="dd-thebibliography">
John H. Reppy. <em>Concurrent Programming in ML</em>.
Cambridge University Press, 1999. <dt class="bibsection">Threads programming</dt></dd><dt class="dt-thebibliography"><a id="Butenhof/threads">[17]</a></dt><dd class="dd-thebibliography">
David R. Butenhof. 
<em>Programming with <span class="c005">posix</span> Threads</em>.
Addison-Wesley, 1997.<dt class="bibsection">Applications</dt></dd><dt class="dt-thebibliography"><a id="Unison">[18]</a></dt><dd class="dd-thebibliography">
Pierce et al.
<em>Unison File Synchronizer. Version 2.9.1.
User Manual and Reference</em>. 
Free software available from 
<a href="http://www.cis.upenn.edu/~bcpierce/unison/"><span class="c001">http://www.cis.upenn.edu/~bcpierce/unison/</span></a>. 
</dd></dl><!--TOC chapter id=sec177 Index-->
<h1 class="chapter" id="sec177">Index</h1><!--SEC END --><p>
<a id="htocindex"></a> Links in bold refer to the description of 
a <span class="c005">posix</span> system call.
</p><table class="c000 cellpading0"><tr><td class="c012"><ul class="indexenv"><li class="li-indexenv">
<span class="c001">accept</span>, <a href="#hevea_default124"><span class="c007">6.7</span></a>
</li><li class="li-indexenv"><span class="c001">access</span>, <a href="#hevea_default37"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">alarm</span>, <a href="#hevea_default80"><span class="c007">4.2</span></a>
</li><li class="li-indexenv"><span class="c001">argv</span>, <a href="#hevea_default0"><span class="c002">1.2</span></a>
</li><li class="li-indexenv"><span class="c001">at_exit</span>, <a href="#hevea_default4"><span class="c002">1.2</span></a>
</li><li class="li-indexenv"><span class="c001">bind</span>, <a href="#hevea_default122"><span class="c007">6.7</span></a>, <a href="#hevea_default128"><span class="c002">6.8</span></a>
</li><li class="li-indexenv"><span class="c001">broadcast</span>, <a href="#hevea_default156"><span class="c007">7.6</span></a>
</li><li class="li-indexenv"><span class="c001">chdir</span>, <a href="#hevea_default8"><span class="c002">2.1</span></a>
</li><li class="li-indexenv"><span class="c001">chmod</span>, <a href="#hevea_default35"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">choose</span>, <a href="#hevea_default162"><span class="c002">7.7</span></a>
</li><li class="li-indexenv"><span class="c001">chown</span>, <a href="#hevea_default26"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">chroot</span>, <a href="#hevea_default9"><span class="c002">2.1</span></a>
</li><li class="li-indexenv"><span class="c001">clear_nonblock</span>, <a href="#hevea_default105"><span class="c002">5.3</span></a>
</li><li class="li-indexenv"><span class="c001">close</span>, <a href="#hevea_default48"><span class="c007">2.8</span></a>, <a href="#hevea_default120"><span class="c002">6.5</span></a>, <a href="#hevea_default127"><span class="c002">6.8</span></a>
</li><li class="li-indexenv"><span class="c001">closedir</span>, <a href="#hevea_default42"><span class="c007">2.4</span></a>
</li><li class="li-indexenv"><span class="c001">connect</span>, <a href="#hevea_default117"><span class="c007">6.4</span></a>, <a href="#hevea_default132"><span class="c002">6.10</span></a>
</li><li class="li-indexenv"><span class="c001">create</span>, <a href="#hevea_default143"><span class="c007">7.2</span></a>
</li><li class="li-indexenv"><span class="c001">delay</span>, <a href="#hevea_default150"><span class="c002">7.3</span></a>
</li><li class="li-indexenv"><span class="c001">dup2</span>, <a href="#hevea_default107"><span class="c007">5.4</span></a>
</li><li class="li-indexenv"><span class="c001">dup</span>, <a href="#hevea_default108"><span class="c007">5.4</span></a>
</li><li class="li-indexenv"><span class="c001">environment</span>, <a href="#hevea_default1"><span class="c002">1.2</span></a>
</li><li class="li-indexenv"><span class="c001">error_message</span>, <a href="#hevea_default6"><span class="c002">1.3</span></a>
</li><li class="li-indexenv"><span class="c001">establish_server</span>, <a href="#hevea_default139"><span class="c002">6.12</span></a>
</li><li class="li-indexenv"><span class="c001">execv</span>, <a href="#hevea_default76"><span class="c007">3.4</span></a>
</li><li class="li-indexenv"><span class="c001">execve</span>, <a href="#hevea_default75"><span class="c007">3.4</span></a>, <a href="#hevea_default83"><span class="c002">4.3</span></a>
</li><li class="li-indexenv"><span class="c001">execvp</span>, <a href="#hevea_default77"><span class="c007">3.4</span></a>, <a href="#hevea_default84"><span class="c002">4.3</span></a>
</li><li class="li-indexenv"><span class="c001">exit</span>, <a href="#hevea_default3"><span class="c002">1.2</span></a>, <a href="#hevea_default144"><span class="c007">7.2</span></a>, <a href="#hevea_default145"><span class="c002">7.2</span></a>, <a href="#hevea_default146"><span class="c002">7.2</span></a>
</li><li class="li-indexenv"><span class="c001">fchmod</span>, <a href="#hevea_default36"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">fchown</span>, <a href="#hevea_default27"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">fork</span>, <a href="#hevea_default69"><span class="c007">3.1</span></a>, <a href="#hevea_default82"><span class="c002">4.3</span></a>, <a href="#hevea_default101"><span class="c002">5.1</span></a>, <a href="#hevea_default142"><span class="c002">7.1</span></a>, <a href="#hevea_default165"><span class="c002">7.8</span></a>
</li><li class="li-indexenv"><span class="c001">fstat</span>, <a href="#hevea_default19"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">ftruncate</span>, <a href="#hevea_default51"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">getcwd</span>, <a href="#hevea_default7"><span class="c002">2.1</span></a>
</li><li class="li-indexenv"><span class="c001">getegid</span>, <a href="#hevea_default33"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">getenv</span>, <a href="#hevea_default2"><span class="c002">1.2</span></a>
</li><li class="li-indexenv"><span class="c001">geteuid</span>, <a href="#hevea_default32"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">getgid</span>, <a href="#hevea_default31"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">getgrgid</span>, <a href="#hevea_default23"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">getgrnam</span>, <a href="#hevea_default21"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">getgroups</span>, <a href="#hevea_default25"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">gethostbyname</span>, <a href="#hevea_default115"><span class="c007">6.3</span></a>
</li><li class="li-indexenv"><span class="c001">gethostname</span>, <a href="#hevea_default129"><span class="c002">6.9</span></a>
</li><li class="li-indexenv"><span class="c001">getitimer</span>, <a href="#hevea_default92"><span class="c002">4.6</span></a>
</li><li class="li-indexenv"><span class="c001">getlogin</span>, <a href="#hevea_default24"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">getpid</span>, <a href="#hevea_default70"><span class="c002">3.1</span></a>
</li><li class="li-indexenv"><span class="c001">getprotobyname</span>, <a href="#hevea_default112"><span class="c007">6.2</span></a>
</li><li class="li-indexenv"><span class="c001">getpwnam</span>, <a href="#hevea_default20"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">getpwuid</span>, <a href="#hevea_default22"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">getservbyname</span>, <a href="#hevea_default116"><span class="c007">6.3</span></a>
</li><li class="li-indexenv"><span class="c001">getsockopt</span>, <a href="#hevea_default125"><span class="c007">6.8</span></a>
</li><li class="li-indexenv"><span class="c001">gettimeofday</span>, <a href="#hevea_default91"><span class="c007">4.6</span></a>
</li><li class="li-indexenv"><span class="c001">getuid</span>, <a href="#hevea_default30"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">gmtime</span>, <a href="#hevea_default94"><span class="c002">4.6</span></a>
</li><li class="li-indexenv"><span class="c001">handle_unix_error</span>, <a href="#hevea_default5"><span class="c002">1.3</span></a>
</li><li class="li-indexenv"><span class="c001">in_channel_of_descr</span>, <a href="#hevea_default102"><span class="c002">5.2</span></a>
</li><li class="li-indexenv"><span class="c001">inet_addr_of_string</span>, <a href="#hevea_default113"><span class="c002">6.3</span></a>
</li><li class="li-indexenv"><span class="c001">input_value</span>, <a href="#hevea_default141"><span class="c002">6.13</span></a>
</li><li class="li-indexenv"><span class="c001">ioctl</span>, <a href="#hevea_default59"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">join</span>, <a href="#hevea_default148"><span class="c007">7.3</span></a>
</li><li class="li-indexenv"><span class="c001">kill</span>, <a href="#hevea_default79"><span class="c007">4.2</span></a>
</li><li class="li-indexenv"><span class="c001">link</span>, <a href="#hevea_default11"><span class="c007">2.2</span></a>
</li><li class="li-indexenv"><span class="c001">listen</span>, <a href="#hevea_default123"><span class="c007">6.7</span></a>
</li><li class="li-indexenv"><span class="c001">localtime</span>, <a href="#hevea_default72"><span class="c002">3.2</span></a>, <a href="#hevea_default95"><span class="c002">4.6</span></a>
</li><li class="li-indexenv"><span class="c001">lock</span>, <a href="#hevea_default152"><span class="c007">7.4</span></a>
</li><li class="li-indexenv"><span class="c001">lockf</span>, <a href="#hevea_default67"><span class="c007">2.14</span></a>
</li></ul></td><td class="c012"><ul class="indexenv"><li class="li-indexenv"><span class="c001">lseek</span>, <a href="#hevea_default49"><span class="c007">2.12</span></a>, <a href="#hevea_default58"><span class="c002">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">lstat</span>, <a href="#hevea_default18"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">mkdir</span>, <a href="#hevea_default43"><span class="c007">2.4</span></a>
</li><li class="li-indexenv"><span class="c001">mkfifo</span>, <a href="#hevea_default104"><span class="c007">5.3</span></a>
</li><li class="li-indexenv"><span class="c001">mktime</span>, <a href="#hevea_default96"><span class="c002">4.6</span></a>
</li><li class="li-indexenv"><span class="c001">new_channel</span>, <a href="#hevea_default158"><span class="c002">7.7</span></a>
</li><li class="li-indexenv"><span class="c001">open_connection</span>, <a href="#hevea_default137"><span class="c002">6.12</span></a>
</li><li class="li-indexenv"><span class="c001">open</span>, <a href="#hevea_default45"><span class="c007">2.6</span></a>
</li><li class="li-indexenv"><span class="c001">opendir</span>, <a href="#hevea_default39"><span class="c007">2.4</span></a>, <a href="#hevea_default55"><span class="c002">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">openfile</span>, <a href="#hevea_default52"><span class="c002">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">out_channel_of_descr</span>, <a href="#hevea_default103"><span class="c002">5.2</span></a>
</li><li class="li-indexenv"><span class="c001">output_value</span>, <a href="#hevea_default140"><span class="c002">6.13</span></a>
</li><li class="li-indexenv"><span class="c001">pipe</span>, <a href="#hevea_default98"><span class="c007">5.1</span></a>
</li><li class="li-indexenv"><span class="c001">poll</span>, <a href="#hevea_default164"><span class="c002">7.7</span></a>
</li><li class="li-indexenv"><span class="c001">read</span>, <a href="#hevea_default38"><span class="c002">2.4</span></a>, <a href="#hevea_default46"><span class="c007">2.7</span></a>, <a href="#hevea_default78"><span class="c002">4</span></a>, <a href="#hevea_default100"><span class="c002">5.1</span></a>, <a href="#hevea_default119"><span class="c002">6.4</span></a>, <a href="#hevea_default135"><span class="c002">6.11</span></a>
</li><li class="li-indexenv"><span class="c001">readdir</span>, <a href="#hevea_default40"><span class="c007">2.4</span></a>
</li><li class="li-indexenv"><span class="c001">readlink</span>, <a href="#hevea_default57"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">receive</span>, <a href="#hevea_default160"><span class="c002">7.7</span></a>
</li><li class="li-indexenv"><span class="c001">recv</span>, <a href="#hevea_default133"><span class="c007">6.11</span></a>
</li><li class="li-indexenv"><span class="c001">recvfrom</span>, <a href="#hevea_default130"><span class="c007">6.10</span></a>
</li><li class="li-indexenv"><span class="c001">rename</span>, <a href="#hevea_default13"><span class="c007">2.2</span></a>
</li><li class="li-indexenv"><span class="c001">rewinddir</span>, <a href="#hevea_default41"><span class="c007">2.4</span></a>
</li><li class="li-indexenv"><span class="c001">rmdir</span>, <a href="#hevea_default44"><span class="c007">2.4</span></a>
</li><li class="li-indexenv"><span class="c001">select</span>, <a href="#hevea_default86"><span class="c002">4.5</span></a>, <a href="#hevea_default97"><span class="c002">4.7</span></a>, <a href="#hevea_default109"><span class="c007">5.6</span></a>, <a href="#hevea_default151"><span class="c002">7.3</span></a>
</li><li class="li-indexenv"><span class="c001">self</span>, <a href="#hevea_default147"><span class="c007">7.2</span></a>
</li><li class="li-indexenv"><span class="c001">send</span>, <a href="#hevea_default134"><span class="c007">6.11</span></a>, <a href="#hevea_default159"><span class="c002">7.7</span></a>
</li><li class="li-indexenv"><span class="c001">sendto</span>, <a href="#hevea_default131"><span class="c007">6.10</span></a>
</li><li class="li-indexenv"><span class="c001">set_nonblock</span>, <a href="#hevea_default106"><span class="c002">5.3</span></a>
</li><li class="li-indexenv"><span class="c001">setgid</span>, <a href="#hevea_default29"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">setitimer</span>, <a href="#hevea_default93"><span class="c002">4.6</span></a>
</li><li class="li-indexenv"><span class="c001">setsid</span>, <a href="#hevea_default66"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">setsockopt</span>, <a href="#hevea_default126"><span class="c007">6.8</span></a>
</li><li class="li-indexenv"><span class="c001">setuid</span>, <a href="#hevea_default28"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">shutdown_connection</span>, <a href="#hevea_default138"><span class="c002">6.12</span></a>
</li><li class="li-indexenv"><span class="c001">shutdown</span>, <a href="#hevea_default121"><span class="c007">6.5</span></a>
</li><li class="li-indexenv"><span class="c001">signal</span>, <a href="#hevea_default81"><span class="c007">4.3</span></a>, <a href="#hevea_default157"><span class="c007">7.6</span></a>
</li><li class="li-indexenv"><span class="c001">sigprocmask</span>, <a href="#hevea_default85"><span class="c007">4.4</span></a>
</li><li class="li-indexenv"><span class="c001">sleep</span>, <a href="#hevea_default90"><span class="c007">4.6</span></a>
</li><li class="li-indexenv"><span class="c001">socket</span>, <a href="#hevea_default111"><span class="c007">6.2</span></a>
</li><li class="li-indexenv"><span class="c001">stat</span>, <a href="#hevea_default17"><span class="c007">2.3</span></a>, <a href="#hevea_default53"><span class="c002">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">stderr</span>, <a href="#hevea_default16"><span class="c002">2.2</span></a>
</li><li class="li-indexenv"><span class="c001">stdin</span>, <a href="#hevea_default14"><span class="c002">2.2</span></a>
</li><li class="li-indexenv"><span class="c001">stdout</span>, <a href="#hevea_default15"><span class="c002">2.2</span></a>
</li><li class="li-indexenv"><span class="c001">string_of_inet_addr</span>, <a href="#hevea_default114"><span class="c002">6.3</span></a>
</li><li class="li-indexenv"><span class="c001">symlink</span>, <a href="#hevea_default12"><span class="c007">2.2</span></a>, <a href="#hevea_default56"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">sync</span>, <a href="#hevea_default161"><span class="c002">7.7</span></a>
</li><li class="li-indexenv"><span class="c001">system</span>, <a href="#hevea_default87"><span class="c002">4.5</span></a>
</li><li class="li-indexenv"><span class="c001">tcdrain</span>, <a href="#hevea_default63"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">tcflow</span>, <a href="#hevea_default65"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">tcflush</span>, <a href="#hevea_default64"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">tcgetattr</span>, <a href="#hevea_default60"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">tcsendbreak</span>, <a href="#hevea_default62"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">tcsetattr</span>, <a href="#hevea_default61"><span class="c007">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">time</span>, <a href="#hevea_default71"><span class="c002">3.2</span></a>, <a href="#hevea_default89"><span class="c002">4.6</span></a>
</li><li class="li-indexenv"><span class="c001">truncate</span>, <a href="#hevea_default50"><span class="c007">2.13</span></a>, <a href="#hevea_default54"><span class="c002">2.13</span></a>
</li><li class="li-indexenv"><span class="c001">trylock</span>, <a href="#hevea_default154"><span class="c007">7.4</span></a>
</li><li class="li-indexenv"><span class="c001">umask</span>, <a href="#hevea_default34"><span class="c007">2.3</span></a>
</li><li class="li-indexenv"><span class="c001">unlink</span>, <a href="#hevea_default10"><span class="c007">2.2</span></a>
</li><li class="li-indexenv"><span class="c001">unlock</span>, <a href="#hevea_default153"><span class="c007">7.4</span></a>
</li><li class="li-indexenv"><span class="c001">utime</span>, <a href="#hevea_default68"><span class="c007">2.15</span></a>
</li><li class="li-indexenv"><span class="c001">wait</span>, <a href="#hevea_default73"><span class="c002">3.3</span></a>, <a href="#hevea_default155"><span class="c007">7.6</span></a>
</li><li class="li-indexenv"><span class="c001">waitpid</span>, <a href="#hevea_default74"><span class="c007">3.3</span></a>, <a href="#hevea_default88"><span class="c002">4.5</span></a>
</li><li class="li-indexenv"><span class="c001">wrap_abort</span>, <a href="#hevea_default163"><span class="c002">7.7</span></a>
</li><li class="li-indexenv"><span class="c001">write</span>, <a href="#hevea_default47"><span class="c007">2.7</span></a>, <a href="#hevea_default99"><span class="c002">5.1</span></a>, <a href="#hevea_default110"><span class="c007">5.7</span></a>, <a href="#hevea_default118"><span class="c002">6.4</span></a>, <a href="#hevea_default136"><span class="c002">6.11</span></a>
</li><li class="li-indexenv"><span class="c001">yield</span>, <a href="#hevea_default149"><span class="c002">7.3</span></a>
</li></ul></td></tr>
</table><!--NAME docindex.html-->
<!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
</body>
</html>
