%------------------------------------------------------------------------------
% Copyright (c) !!COPYRIGHTYEAR!!, Xavier Leroy and Didier Remy.  
%
% All rights reserved. Distributed under a creative commons
% attribution-non-commercial-share alike 2.0 France license.
% http://creativecommons.org/licenses/by-nc-sa/2.0/fr/
%
% Translation by Thaddeus Meyer
%------------------------------------------------------------------------------

\chapter{Signals}
\label{sec/signals}
\cutname{signals.html}

Signals, or software interrupts, are external, asynchronous events
used to alter the course of a program.  These may occur at any
time during the execution of a program.  Because of this,
they differ from other methods of interprocess communication, where
two programs must be explictly directed to wait for external messages,
for example, by calling \indexvalue{read} on a pipe.

The amount of information transmitted via a signal is minimal (e.g.
the type of signal, and nothing else) and although they were not
intended for communication between processes, they do make it
possible to transmit atomic information concerning the state of an
external concern (the state of the system or another process). 

\section{Default behavior}

When a process receivies a signal, there are several possible behaviors:
%
\begin{itemize}
\item 
The signal terminates the process.  Additionally, the system may write
an image of the process state in a core file (a emph{core dump}, which
may be later examined with a \emph{debugger}.
%
\item 
The signal suspends process execution, but retains it in memory.  The
parent process (usually the shell) is not terminated, and so may
choose to continue the process, or restart it in the background by
sending the process additional signals.
%
\item Nothing occurs.  The signal is completely ignored.
%
\item The signal triggers the executation of an associated function in the
receiving program.  The normal execution of the program resumes when the
function returns.
\end{itemize}
%

The are several types of signals each associated with a particular condition.  
Table~\ref{tab/signals} lists them, with the default behavior:

\begin{mytable}
\begin{tabular}{lll}
Name & Significance & Behavior \\
\hline
\ml+signup+ &
Hang-up (end of connection) &
Termination \\
\ml+sigint+ &
Interruption (\ml+ctrl-C+) &
Termination \\
\ml+sigquit+ &
Strong interruption (\ml+ctrl-\+) &
Term. + core dump \\
\ml+sigfpe+ &
Arithmetic error (division by zero) &
Term. + core dump \\
\ml+sigkill+ &
Very strong interruption (cannot be ignored) &
Terminasion \\
\ml+sigsegv+ &
Memory protection violation &
Term. + core dump \\
\ml+sigpipe+ &
Writing to a pipe without readers &
Termination \\
\ml+sigalrm+ &
Timer interrupt &
Possibly ignored \\
\ml+sigtstp+ &
Temporary halt (\ml+ctrl-Z+) &
Suspension \\
\ml+sigcont+ &
Resuming a stopped process &
Possibly ignored \\
\ml+sigchld+ &
A process died or was stopped &
Possibly ignored \\
\end{tabular}
\caption{Some signal types and their default behavior}
\label{tab/signals}
\end{mytable}

The signals received by a program come from several possible sources:
%
\begin{itemize}

\item The user may send signals via the keyboard.  By typing \ml+ctrl-C+,
  the console operator sends the \ml+sigint+ signal to the processes
  controlled by their terminal (that were not already put in the background).
  In the same way, \ml+sigquit+ is sent by typing \verb'ctrl-\'\footnote{These 
    are the default characters, but it is possible to change them by 
    modifying the properties of the terminal, see section~\ref {sec/termio}.}.  
  When the terminal is closed (through disconnection, either voluntarily 
  or through a disconnected telephone link), the signal \ml+signup+ is sent.

\item The user, by issuing the \ml+kill+ command.  This makes it possible 
  to send a specific signal to a specific process.  For example, 
  \ml+kill -KILL 194+ sends the signal \ml+sigkill+ to process 194, which 
  causes the process to be killed.

\item Another program (via the operating system), requesting a system 
  \ml+kill+ (the preceeding example being a specific case).

\item The system, for misbehaving processeses.  For example, a process 
  attempting a divide by zero instruction will receive  a \ml+sigfpe+ signal.

\item The system, to notify a process when its execution environment has 
  been changed.  For example, when a child process terminates, its parent 
  will receive a \ml+sigchld+ signal.

\end{itemize}


\section{Using signals}

The system call \syscall{kill} makes it possible to send a
signal to a process.

%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{kill}$ : int -> int -> unit
\end{listingcodefile}
%
The only parameter is the process identifier (PID) of the intended 
recipient.  An error occurs if one attempts to send a signal
to a process not owned by the user.  A process may send signals to 
itself.  When the \ml+kill+ system call executes, it is guaranteed
that the signal is delivered to the intended recipient.  That is to say, 
if the recipient is made aware of an unmasked signal, its first action
will be to treat the signal (either this one, or another). If a process 
receives the same signal in rapid succession, it will execute the code 
associated with the signal only once.  Therefore a program cannot 
count the number of times it receives a signal, but only the number 
of times it reponds to it.

The system call \syscall{alarm} makes it possible to create interruptions
based on the system clock.

%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{alarm}$ : int -> int
\end{listingcodefile}
%

The call \ml+alarm s+ returns immediately, but causes the \ml+sigalrm+ 
signal to be sent the the recieving process at least \ml+s+ seconds later 
(note: there is no guarantee on the maximum wait time).  The call returns 
the number of seconds remaining until the signal is actually sent.  
If \ml+s+ is null, the effect is simply to cancel an earlier alarm.

\section{Changing the effect of a signal}

The system call \syscall{signal} makes it possible to modify the behavior
of a process when it receives a signal of a certain type.

%
\begin{codefile}{tmpsys.mli}
type signal_behavior = Sys.signal_behavior
\end{codefile}
%
\begin{listingcodefile}{tmpsys.mli}
val signal : int -> signal_behavior -> signal_behavior
\end{listingcodefile}
%

The second argument indicates the desired behavior.  If it is the 
\ml+Signal_ignore+ constant, the signal will be ignored.  If it is 
\ml+Signal_default+, the default behavior is assumed.  In the case of 
\ml+Signal_handle f+ (where \ml+f+ is a function of the type 
\ml+unit -> unit+), the function \ml+f+ will be 
invoked each time the signal is received.

Forking a process (with the system call \indexvalue{fork}) preserves 
signal behavior: the initial definitions for the child are those of 
the parent at the time the \ml+fork+ is executed.  The \indexvalue{exec} 
system call sets the behaviors to \ml+Signal_default+, with one 
exception: signals ignored before are ignored afterwards.

\begin{example}
Occassionally one wants to logoff or end a session while allowing 
background tasks (large calculations, \quotes{spyware} programs, etc) 
to continue to run.  If this is desired, processes which normally
exit on receiving \ml+SIGHUP+ (sent at the time the user disconnects)
should be prevented from doing so. The \ml+nohup+
command is exactly what is needed:
\begin{lstlisting}
nohup cmd arg1 ... argn
\end{lstlisting}
executes the command \ml+cmd arg1 ... argn+ in a way unaffected by
the signal \ml+SIGHUP+. (Certain shells execute \ml+nohup+
automatically for all processes launched as background tasks).  Here's how
to implement this in three lines:
%
\begin{listingcodefile}{nohup.ml}
open Sys;;
signal sighup Signal_ignore;;
Unix.execvp argv.(1) (Array.sub argv 1 (Array.length argv - 1));;
\end{listingcodefile}
%
The system call \ml+execvp+ preserves the fact that \ml+sighup+ is ignored.
\end{example}

Here are some examples of how signals are intercepted.

\begin{example} 
Carefully exiting when a program is misbehaving. For example,
a program like \ml+tar+ can try to save important information
in a file or destroy the corrupted file before terminating.  For this 
it is possible to include the following lines at the beginning of the program:
%
\begin{lstlisting}
signal sigquit (Signal_handle quit);
signal sigsegv (Signal_handle quit);
signal sigfpe  (Signal_handle quit);
\end{lstlisting}
%
where the function \ml+quit+ is of the form:
%
\begin{lstlisting}
let quit() =
  (* Try to save important information in a file  *);
  exit 100;;
\end{lstlisting}
\end{example}

\begin{example} 
Capturing user-initiated interruptions. Some interactive programs, 
for example, need to return main control loop when a user
strikes \ml+ctrl-C+.  It is enough to raise an exception when the
\ml+SIGINT+ signal is received.

%
\begin{lstlisting}
exception Break;;
let break () = raise Break;;
...
let main_loop() =
  signal sigint (Signal_handle break);
  while true do
    try
      (* Read and carry out instructions *)
    with Break ->
      (* display ``stopped'' *)
  done;;
\end{lstlisting}
\end{example}

\begin{example} 
To carry out periodic tasks (animations, etc) interlaced with
the execution of the main program.  For example, here is how
to create \quotes{beep} sounds every 30 seconds, regardless of
the activity of the main program (calculations or input/output).

\begin{lstlisting}
let beep () = output_char stdout `\007`; flush stdout; alarm 30; ();;
...
signal sigalrm (Signal_handle beep); alarm 30;;
\end{lstlisting}
\end{example}

\subsection*{Checkpoints}

Signals are useful for asynchronous communication--indeed, it is their 
very reason for existence--but they are often impossible to 
circumvent and thus create some significant difficulties for the
system programmer.

Indeed, the signal handling code (that which is executed upon 
receiving a particular signal) is handled asynchronously, and thus 
pseudo-concurrently executed (i.e., interlaced) with the main 
code of the program.  As the signal handler does not return
a signal, their side effect is typically to modify a global variable.
A competition (race condition) between the signal and the main program 
for access to this global variable may ensue.  Generally, the solution
is to block signals during the treatment of these critical areas as 
explained later in this chapter.  

However, OCaml does not treat signals in a strictly asynchronous
fashion.  Upon receiving a signal, OCaml is satisfied to record the
signals' reception but the signal will only be handled (that is to
say, the signal handling code will be executed) at certain
checkpoints.  These are frequent enough to provide the illusion of
asynchronous treatment.  The checkpoints typically occur during
allocations, loop controls, or interactions with the system
(particularly with system calls).  OCaml guarantees that a program
that does not loop, does not allocate, and does not interact with the
system, will not interlace with the signal handler.  Specifically, the
writing of an unallocated value (whole, boolean, etc~---~but not a
float !) in a reference does not pose the problem of contention.

\section{How to mask signals}

Signals may be blocked.  Blocked signals are not ignored, but put on 
standby, generally to be delivered later.  The system call
\syscall{sigprocmask} makes it possible to change the mask
for incoming signals:
%
\begin{codefile}{tmpunix.mli}
type sigprocmask_command = Unix.sigprocmask_command
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{sigprocmask}$ : sigprocmask_command -> int list -> int list
\end{listingcodefile}
%
\ml+sigprocmask cmd sigs+ changes the list of blocked signals and 
returns a list of signals that were blocked immediately proceeding 
the execution of the command.  This makes it possible later on to 
give the mask of blocked signals in its intial state.  The argument 
\ml+sigs+ is a list of signals whose order depends on \ml+cmd+:

\begin{mltypecases}
\mltypecase{SIG\_BLOCK} the signals \ml+sigs+ are added
to the list of blocked signals.

\mltypecase{SIG\_UNBLOCK} the signals \ml+sigs+ are removed
from the freed signals.

\mltypecase{SIG\_SETMASK} the signals \ml+sigs+ are exactly the 
blocked signals.
\end{mltypecases}
%
A typical usage of \ml+sigprocmask+ is to temporarily mask certain
signals.

%
\begin{lstlisting}
let old_mask = sigprocmask cmd sigs in 
(* do something *)
let _ = sigprocmask SIG_SETMASK old_mark
\end{lstlisting}
%
Often, one will have to protect oneself from possible errors by using
the following outline:

%
\begin{codefile}{sign.ml}
open Unix;;
let tmp cmd sigs = 
\end{codefile}
%
\begin{listingcodefile}{sign.ml}
let old_mask = sigprocmask cmd sigs in 
let treat() = ((* do something *)) in
let reset() = ignore (sigprocmask SIG_SETMASK old_mask) in
Misc.try_finalize treat () reset ()
\end{listingcodefile}

\section{Signals and system calls} 

Warning ! Any signal that is not ignored can potentially interrupt 
certain system calls.  Generally speaking, these system calls are 
known as \emph{slow} calls, which can take an arbitrary length of time (for
example, terminal I/O, select (see below), system, \etc).
If an interruption occurs, the system call is not completed and
returns exception \ml+EINTR+.  Note file I/O is not interruptible:
although these operations can suspend the running process to instead
execute another process for disk I/O, when this occurs the interruption
will always be brief--if the disk functions correctly.  In particular, 
the throughput of data depends only on the system, and not another user's
process.

Ignored (masked) signals are never delivered.  In the case of unmasked 
signals, it is important to guard against any potentially 
unwanted interruptions.

A typical example is a parent waiting for the termination of a child.
In this case, the father executes \ml+waitpid [] pid+ where \ml+pid+ 
is the process \textsc{id} of the child.  This is a blocking system call, and 
is therefore \emph{slow}, which means it could be stopped by the 
arrival of a signal.  Specifically, the signal \ml+sigchld+ is sent 
to the parent concerning the terminated child process.

The module \ml+Misc+ contains the following function:
\ml+restart_on_EINTR+ of the type \ml+('a -> 'b) -> 'a -> 'b+ which
makes it possible to repeat a system call when it is stopped
by a signal, \ie. when the exception \ml+EINTR+ is raised.

%
\begin{codefile}{misc.mli}
val restart_on_EINTR : ('a -> 'b) -> 'a -> 'b
(** [restart_on_EINTR f x] calls [f x] repeatedly until it does not fail
with [EINTR] *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let rec restart_on_EINTR f x = 
  try f x with Unix_error (EINTR, _, _) -> restart_on_EINTR f x
\end{listingcodefile}
\label{restart_on_EINTR}%
To really wait on a child, then, one needs to simply write
\ml+restart_on_EINTR (waitpid flags) pid+.

\begin{example}
The parent can also recover children asynchronously, specifically
when their return value does not necessitate continued execution.
This is accomplished by executing a function \ml+free_children+ upon
receiving the signal \ml+sigchld+.  We find this general function 
described in the \ml+Misc+ library.


%
\begin{codefile}{misc.mli}
val free_children : int -> unit
(** [free_children signal] free all zombie children of the current process, 
    discarding their exit status. *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let free_children signal = 
  try while fst (waitpid [ WNOHANG ] (-1)) > 0 do () done 
  with Unix_error (ECHILD, _, _) -> ()
\end{listingcodefile}
%
This function executes \ml+waitpid+ in non-blocking mode 
(option \ml+WNOHANG+) and for each thread, repeats
the call when a child reutrns.  It stops when there are
no more live threads (zero is returned to the pid of the
original process) or when there are no more threads
(exception \ml+ECHILD+).  When the process receives the \ml+sigchld+ 
signal, it is not possible to know the number of completed process, 
especially if the signal is received several times within a short 
period of time--the parent 'sees' only one signal.  Note that it 
is not important to guard against signal \ml+EINTR+ because 
\ml+waitpid+ is non-blocking when called with the \ml+WNOHANG+ option.

In other cases, this signal cannot be ignored (the associated 
action will release all completed threads, in a non-blocking way--
one never knows how much time may have elapsed during the signal 
generation).
\end{example}

\begin{example}
The command \ml+system+ in the \ml+Unix+ module is simply defined as: 

\begin{lstlisting}
let system cmd =
  match fork() with
    0 -> 
      begin try
        execv "/bin/sh" [| "/bin/sh"; "-c"; cmd |]; assert false
      with _ -> exit 127 
      end
  | id -> snd(waitpid [] id);;
\end{lstlisting}

The assertion following the system call \ml+execv+ corrects an
erroneous restriction on the type of the return value of the
\ml+execv+ function (in versions equal to or earlier than 3.07).
As the system call did not return, no constraint could relate to the
returned value, and of course, the assertion could not be
carried out.

The specifications of the standard C library specifies that the parent
should be unaware of the \ml+sigint+ and \ml+siquit+ signals, and masks
the \ml+sigchld+ signal during the command's execution.  
That makes it possible to stop or kill a child process without
affecting the main program's execution.

We prefer to define the function \ml+system+ as specialization of a
more general function \ml+exec_as_system+ which does not make it
mandatory to carry out the order with the shell. We place it in the
\ml+Misc+ module.

%
\begin{codefile}{misc.mli}
val system : string -> process_status
(** [system cmd] behaves as [Unix.system cmd] except that [sigchld] is
blocked and [sigint] and [sigquit] are ignored during the excecution 
of the command [cmd] *)

val exec_as_system : ('a -> process_status) -> 'a -> process_status
(** [system exec args] behaves as [system cmd] except that it takes as
arguments a function [exec] and arguments [args] to be passed to [exec]
to start in the new process. In particular, [system] is an abbreviation for 
[exec_as_system (execv "/bin/sh") \[|"-c"; cmd; |\] v]. *)
\end{codefile}
%
\begin{codefile}{misc.ml}
open Sys;;
open Unix;;
\end{codefile}
%
\begin{listingcodefile}[style=numbers]{misc.ml}
let exec_as_system exec args = 
  let old_mask = sigprocmask SIG_BLOCK [sigchld ] in 
  let old_int = signal sigint Signal_ignore in 
  let old_quit = signal sigquit Signal_ignore in 
  let reset() =
    ignore (signal sigint old_int); 
    ignore (signal sigquit old_quit);
    ignore (sigprocmask SIG_SETMASK old_mask) in
  let system_call () = 
    match fork() with
    | 0 -> 
        reset(); $\label{prog:sreset}$
        begin try 
          exec args 
        with _ -> exit 127 
        end
    | k -> 
        snd (restart_on_EINTR (waitpid []) k) in
  try_finalize system_call() reset();; $\label{prog:stry}$

let system cmd = 
  exec_as_system (execv "/bin/sh") [| "/bin/sh"; "-c"; cmd |];;
\end{listingcodefile}
%

Note that the signal change must be made before the \ml+fork+ call is
executed.  Immediately thereafter only one of the two processes
(generally the child) remains.  During the interval where the son
takes control of the execution flow, the father could receive signals
(in particular \ml+sigchld+) if the son finishes immediately.  As a
result, it is necessary to supply signals with their initial value in
the child before executing the command in line~\ref{prog:sreset}.
Indeed, all ignored signals are preserved by \ml+fork+ and \ml+exec+,
and their behavior is preserved by \ml+fork+.  The system call
\ml+exec+ normally supplies signals with their default value, except
in the specific instance where the default behavior is to ignore the
signal.

Finally, the parent must supply signals with their initial value
immediately after executing the call, including error trapping, by 
using the command \ml+try_finalize+ in line~\ref{prog:stry}.
\end{example}


\section{The passage of time}

\subsection*{Legacy approach to time}

Since the earliest versions of Unix, time has been counted in seconds.
For compatability concerns, then, one can always measure time in seconds.
The current time is reckoned in the number of seconds since January 1, 1970
with \ml+00:00:00 GMT+.  It is returned by the function:

%
\begin{listingcodefile}{tmpunix.mli}
val $\indexlibvalue{Unix}{time}$ : unit -> float
\end{listingcodefile}
%

The system call \syscall{sleep} can pause the execution of a program
for the number of seconds specified in the argument:
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{sleep}$ : int -> unit
\end{listingcodefile}
%

However, this function is not primitive. It is programmable with 
more elementary system calls using the function alarm (see 
above) and \ml+sigsuspend+: 

%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{sigsuspend}$ : int list -> unit
\end{listingcodefile}
%

The call \ml+sigsuspend l+ temporarily suspends the signals of the 
list \ml+l+, then halts the execution of the program until the reception 
of a signal, one not ignored or suspended (on return, the 
mask of the signals is again returned to its old value by the system).

\begin{example}

Now we may program the \ml+sleep+ function.
%
\begin{codefile}{sleep.ml}
open Sys;;
open Unix;;
\end{codefile}
%
\begin{listingcodefile}[style=numbers]{sleep.ml}
let sleep s = 
  let old_alarm = signal sigalrm (Signal_handle (fun s -> ())) in $\label{prog:sold}$
  let old_mask = sigprocmask SIG_UNBLOCK [ sigalrm ] in
  let _ = alarm s in
  let new_mask = List.filter (fun x -> x <> sigalrm) old_mask in
  sigsuspend new_mask; 
  let _ = alarm 0 in
  ignore (signal sigalrm old_alarm); 
  ignore (sigprocmask SIG_SETMASK old_mask)$\label{prog:ssigproc}$;;
\end{listingcodefile}
%

Initially, the behavior of the signal sigalarm is to do nothing.  Note
that \quotes{to do nothing} is the same as ignoring the signal.  In
the second case, the process would not be awakened with the reception
of the signal. The signal \ml+sigalarm+ is put in a non-blocking
state.  Then one puts oneself on standby by suspending all the other
signals which were not it already (\ml+old_mask+). After the alarm
clock, one erases the preceding modifications. (Note that
line~\ref{prog:ssigproc} could is placed immediately after
line~\ref{prog:sold}, because the call to \ml+sigsuspend+ preserves
the signals' mask.)

\end{example}

\subsection*{Modern times}

In modern versions of Unix, time can also be measured in microseconds.
In OCaml, time measured in microseconds are represented as floats.  
The function \syscall{gettimeofday} is the equivalent of \ml+time+ 
for modern systems.

%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{gettimeofday}$ : unit -> float
\end{listingcodefile}

\subsection*{Timers}
In modern Unix each process is equipped with three timers, each
measuring time in a different way.  The types of timers are:

%
\begin{mltypecases}
\mltypecase{ITIMER\_REAL} real time (\ml+sigalrm+)
\mltypecase{ITIMER\_VIRTUAL} user time (\ml+sigvtalrm+)
\mltypecase{ITIMER\_PROF} user time and system time (\ml+sigprof+)
\end{mltypecases}
% 
The state of a timer is described by the \ml+interval_timer_status+
type which is a structure with two fields (each a \ml+float+)
representing time:


%
\begin{itemize}
\item The field \ml+it_interval+ indicates the length of the time 
to be measured
\item The \ml+field it_value+ is the current value of the timer; 
when it returns \ml+null+ the signal \ml+sigvtalarm+ is sent and 
the timer is reset to the value in \ml+it_interval+.
\end{itemize}
%

A timer is therefore inactive when its two fields are \ml+null+.  
The timers can be queried or modified with the following functions:

%
\begin{codefile}{tmpunix.mli}
type interval_timer = Unix.interval_timer
type interval_timer_status = Unix.interval_timer_status
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val getitimer : interval_timer -> interval_timer_status
val setitimer : 
    interval_timer -> interval_timer_status -> interval_timer_status
\end{listingcodefile}
%

The value returned by \ml+settitimer+ is the old value of 
the timer at the time of its modification.

\begin{exercise}[noanswer]

To manage serveral timers, write a module having the following interface:
%
\begin{listingcodefile}{timers.mli}
module type Timer = sig
  open Unix
  type t
  val new_timer : interval_timer -> (unit -> unit) -> t
  val get_timer : t -> interval_timer_status
  val set_timer : t -> interval_timer_status -> interval_timer_status
end
\end{listingcodefile}
%

The function \ml+new_timer k f+ should create a new sand glass of the 
type \ml+k+ starting the action \ml+f+, inactive with its creation; 
the function \ml+set_timer t+ allowing to regulate the timer \ml+t+ 
(returning the old value). 

\end{exercise}

\subsection* {Date calculations}

Modern versions of Unix also provide libraries of functions dedicated to
date handling, see the structure \ml+tm+ which makes it possible to
represent dates and times according to a calendar (year, month, etc.) as
well as providing conversion functions:
\indexlibvalue{Unix}{gmtime}, \indexlibvalue{Unix}{localtime},
\indexlibvalue{Unix}{mktime}, \etc

\section{Problems with signals}

The use of signals for interprocess communication, because of 
their asynchronous nature, presents some limitations and difficulties:
%
\begin{itemize}

\item Very little information is trasmitted--the signal 
type and nothing else.

\item A signal may occur at any point during the execution 
of the program.  Therefore, a function associated with the receipt 
of a signal should not generally modify the data structures of 
the main program, because the main program may be interrupted 
unexpectedly with the modification of a structure.  If necessary,
the entire program must be protected from this type of contention that
results from actions associated with a signal.

\item The use of signals requires one to take into account the 
possibility that long system calls might stop the execution of the 
main program, even if the signals keep their default behavior.

\item The functions associated with a standard library must always 
consider the possibility of signal use and guard against system 
call interruption.

\end{itemize}
%

Signals offer only a limited form of asynchronous communication but
carry all the difficulties and problems associated to it. If possible,
it's therefore better not to use them. For example to wait for a small
amount of time, \indexvalue{select} can be used instead of alarms. But
in certain situations they must be taken into account (for example in
command line interpreters).

Signals are possibly the least useful concept in the Unix system.  On
certain older versions of Unix (in particular, System V) the behavior
of a signal is initially automatically associated with
\ml+Signal_default+ when it is received.  This function can of course
be made to perform the proper behavior, thus, in the \quotes{beep}
example above, it would be necessary to write:

\begin{lstlisting}
let rec beep () =
  set_signal SIGALRM (Signal_handle beep);
  output_char stdout `\007`; flush stdout;
  alarm 30; ();;
\end{lstlisting}

However, the problem takes place when signals are received between the
instant the behavior is automatically trapped by \ml+Signal_default+
and the moment the \ml+set_signal+ function is carried out.  
Any signals received during this interval are not treated correctly 
(according to to the type of the signal); they may be inadvertently 
ignored, or might cause the process to crash, instead of carrying 
out the associated function.

Other flavors of Unix (\textsc{bsd} or Linux) treat the 
signals more consistently: the behavior associated with a 
signal is not altered when it is received, and while a particular 
signal is being handled, other signals of the same type are put on standby.

