%------------------------------------------------------------------------------
% Copyright (c) !!COPYRIGHTYEAR!!, Xavier Leroy and Didier Remy.  
%
% All rights reserved. Distributed under a creative commons
% attribution-non-commercial-share alike 2.0 France license.
% http://creativecommons.org/licenses/by-nc-sa/2.0/fr/
%
% Translation by Thaddeus Meyer
%------------------------------------------------------------------------------

\chapter{Signals}
\label{sec/signals}
\cutname{signals.html}

Signals, or software interrupts, are external, asynchronous events
used to alter the course of a program.  These may occur at any
time during the execution of a program.  Because of this,
they differ from other methods of interprocess communication, where
two processes must be explicitly directed to wait for external messages;
for example, by calling \indexvalue{read} on a pipe.

The amount of information transmitted via a signal is minimal (just
the type of signal) and although they were not originally
intended for communication between processes, they do make it
possible to transmit atomic information about the state of an
external entity (e.g. the state of the system or another process). 

\section{Default behavior}

When a process receives a signal, there are four possible outcomes:
%
\begin{itemize}
\item 
The signal terminates the process.  Additionally, the system may write
an image of the process state in a core file (a \emph{core dump}, which
may be later examined with a \emph{debugger}).
%
\item 
The signal suspends process execution, but retains it in memory.  The
parent process (usually the shell) is not terminated, and so may
choose to continue the process or restart it in the background by
sending the process additional signals.
%
\item Nothing occurs: the signal is completely ignored.
%
\item The signal triggers the execution of an associated function in the
receiving process.  Normal execution of the process resumes after the
function returns.
\end{itemize}
%

There are several types of signals, each associated with a particular event.  
Table~\ref{tab/signals} lists some of them with their default behaviors:

\begin{mytable}
\begin{tabular}{lll}
Name & Event & Default Behavior \\
\hline
\ml+sighup+ &
Hang-up (end of connection) &
Termination \\
\ml+sigint+ &
Interruption (\ml+ctrl-C+) &
Termination \\
\ml+sigquit+ &
Strong interruption (\ml+ctrl-\+) &
Term.\ \& core dump \\
\ml+sigfpe+ &
Arithmetic error (division by zero) &
Term.\ \& core dump \\
\ml+sigkill+ &
Very strong interruption (cannot be ignored) &
Termination \\
\ml+sigsegv+ &
Memory protection violation &
Term.\ \& core dump \\
\ml+sigpipe+ &
Writing to a pipe without readers &
Termination \\
\ml+sigalrm+ &
Timer interrupt &
Possibly ignored \\
\ml+sigtstp+ &
Temporary halt (\ml+ctrl-Z+) &
Suspension \\
\ml+sigcont+ &
Resuming a stopped process &
Possibly ignored \\
\ml+sigchld+ &
A child process died or was stopped &
Possibly ignored \\
\end{tabular}
\caption{Some signals and their default behaviors}
\label{tab/signals}
\end{mytable}

The signals received by a process come from several possible sources:
%
\begin{itemize}

\item The user may send signals via the keyboard.  By typing \verb'ctrl-C',
  the console operator sends the \ml+sigint+ signal to the processes
  controlled by her terminal (that were not already put in the background).
  In the same way, the \ml+sigquit+ signal is sent by typing \verb'ctrl-\'\footnote{These 
    are the default keystrokes, but it is possible to change them by 
    modifying the properties of the terminal, see section~\ref {sec/termio}.}.  
  When the terminal is closed (either through voluntary disconnection or owing to a disconnected network link), the \ml+sighup+ signal is sent.

\item The user may issue the \ml+kill+ command.  This makes it possible 
  to send a specific signal to a specific process.  For example, 
  \ml+kill -KILL 194+ sends the \ml+sigkill+ signal to the process with ID 194, which 
  causes the process to be killed.

\item Another program (via a system call), requesting a
  \ml+kill+ (the preceding example being a specific case).

\item The system, for misbehaving processes.  For example, a process 
  attempting to divide by zero will receive a \ml+sigfpe+ signal.

\item The system, to notify a process that its execution environment has 
  been changed.  For example, when a child process terminates, its parent 
  will receive a \ml+sigchld+ signal.

\end{itemize}


\section{Using signals}

The system call \syscall{kill} makes it possible to send a
signal to a process.

%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{kill}$ : int -> int -> unit
\end{listingcodefile}
%
The only parameter is the process identifier (\ml+pid+) of the
intended recipient.  An error occurs if one attempts to send a signal
to a process not owned by the user.  A process may send signals to
itself.  When the \ml+kill+ system call executes, it is guaranteed
that the signal is delivered to the intended recipient process
\ie{} if the recipient is made aware of an unmasked signal then its
first action will be to act on the signal (either this one, or another
pending signal). If a process receives the same signal in rapid
succession it will execute the code associated with the signal only
once.  Therefore a program cannot count the number of times it
receives a signal, rather only the number of times it responds to it.

The system call \syscall{alarm} makes it possible to schedule
interruptions based on the system clock.

%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{alarm}$ : int -> int
\end{listingcodefile}
%

The call \ml+alarm s+ returns immediately but causes the \ml+sigalrm+ 
signal to be sent to the receiving process at least \ml+s+ seconds later 
(note that there is no guarantee on the maximum wait time).  The call returns 
the number of seconds remaining until the signal is actually sent.  
If \ml+s+ is \ml+0+, the effect is simply to cancel an earlier alarm.

\section{Changing the effect of a signal}

The system call \syscall{signal} makes it possible to modify the behavior
of a process when it receives a signal of a certain type.

%
\begin{codefile}{tmpsys.mli}
type signal_behavior = Sys.signal_behavior
\end{codefile}
%
\begin{listingcodefile}{tmpsys.mli}
val signal : int -> signal_behavior -> signal_behavior
\end{listingcodefile}
%

The second argument indicates the desired behavior.  If it is
\ml+Signal_ignore+, then the signal will be ignored.  If it is 
\ml+Signal_default+ then the default behavior is assumed.  For
\ml+Signal_handle f+ (where \ml+f+ is a function with type 
\ml+unit -> unit+) then the function \ml+f+ will be 
invoked each time the signal is received.

Forking a process (with the system call \indexvalue{fork}) preserves 
signal behavior: the initial definitions for the child are those of 
the parent at the time when \ml+fork+ was executed.  The \indexvalue{exec} 
system call sets all the behaviors to \ml+Signal_default+ except that
signals ignored before are still ignored afterwards.

\begin{example}
Occasionally one wants to log-off or end a session while allowing 
background tasks (large calculations, \quotes{spyware} programs, \etc) 
to continue to run.  If this is desired, processes which normally
exit on receiving \ml+sighup+ (sent at the time the user disconnects)
should be prevented from doing so. The \ml+nohup+
command is exactly what is needed.
\begin{lstlisting}
nohup cmd arg1 ... argn
\end{lstlisting}
executes the command \ml+cmd arg1 ... argn+ in a way unaffected by
the signal \ml+sighup+ (certain shells execute \ml+nohup+
automatically for all processes launched as background tasks).  Here's how
to implement this in three lines:
%
\begin{listingcodefile}{nohup.ml}
open Sys;;
signal sighup Signal_ignore;;
Unix.execvp argv.(1) (Array.sub argv 1 (Array.length argv - 1));;
\end{listingcodefile}
%
The system call \ml+execvp+ preserves the fact that \ml+sighup+ is ignored.
\end{example}

Here are some examples of how signals are intercepted.

\begin{example} 
Carefully exiting when a program is misbehaving. For example,
a program like \ml+tar+ can try to save important information
in a file or destroy the corrupted file before terminating.  For this 
it is possible to include the following lines at the beginning of the program:
%
\begin{lstlisting}
signal sigquit (Signal_handle quit);
signal sigsegv (Signal_handle quit);
signal sigfpe  (Signal_handle quit);
\end{lstlisting}
%
where the function \ml+quit+ is of the form:
%
\begin{lstlisting}
let quit () =
  (* Try to save important information in a file *);
  exit 100;;
\end{lstlisting}
\end{example}

\begin{example} 
Capturing user-initiated interruptions. Some interactive programs
need to return to a main control loop when a user
presses \ml+ctrl-C+.  It is enough to raise an exception when the
\ml+sigint+ signal is received.

%
\begin{lstlisting}
exception Break;;
let break () = raise Break;;
...
let main_loop () =
  signal sigint (Signal_handle break);
  while true do
    try
      (* Read and carry out instructions *)
    with Break ->
      (* display "stopped" *)
  done;;
\end{lstlisting}
\end{example}

\begin{example} 
To carry out periodic tasks (animations, \etc) interlaced with
the execution of the main program.  For example, here is how
to create \quotes{beep} sounds every 30 seconds, regardless of
the activity of the main program (calculations or input/output).

\begin{lstlisting}
let beep _ = output_char stdout '\007'; flush stdout; ignore (alarm 30);;
...
signal sigalrm (Signal_handle beep); ignore (alarm 30);;
\end{lstlisting}
\end{example}

\subsection*{Checkpoints}

Signals are useful for asynchronous communication -- indeed, it is their 
raison d'\^etre -- but they are often impossible to 
circumvent and thus create some significant difficulties for the
system programmer.

The signal handling code (that which is executed on 
receiving a particular signal) is handled asynchronously, and thus 
pseudo-concurrently executed (\ie{} interlaced) with the main 
code of the process.  As the signal handler does not return
a signal, its side effect is typically to modify a global variable.
A competition (race condition) between the signal and the main process
for access to this global variable may therefore ensue.  Generally, the solution
is to block signals during the treatment of these critical sections as 
explained later in this chapter.  

However, OCaml does not treat signals in a strictly asynchronous
fashion.  On receiving a signal, OCaml records the receipt of the
signal but the signal handling code will only be executed at certain
\emph{checkpoints}.  These are frequent enough to provide the illusion of
asynchronous treatment.  The checkpoints typically occur during
allocations, loop controls, or interactions with the system
(particularly with system calls).  OCaml guarantees that a program
that does not loop, does not allocate, and does not interact with the
system will not interlace with the signal handler.  Specifically, the
writing of an unallocated value (integer, boolean, \etc{} -- but not a
float!) in a reference does not pose the problem of contention.

\section{How to mask signals}

Signals may be blocked.  Blocked signals are not ignored, but put on 
standby, generally to be delivered later.  The 
\syscall{sigprocmask} system call makes it possible to change the mask
for incoming signals:
%
\begin{codefile}{tmpunix.mli}
type sigprocmask_command = Unix.sigprocmask_command
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{sigprocmask}$ : sigprocmask_command -> int list -> int list
\end{listingcodefile}
%
\ml+sigprocmask cmd sigs+ changes the list of blocked signals and 
returns a list of signals that were blocked immediately proceeding 
the execution of the command.  This makes it possible later on to 
give the mask of blocked signals in its initial state.  The argument 
\ml+sigs+ is a list of signals whose interpretation depends on \ml+cmd+:

\begin{mltypecases}
\mltypecase{SIG\_BLOCK} the signals \ml+sigs+ are added
to the list of blocked signals.

\mltypecase{SIG\_UNBLOCK} the signals \ml+sigs+ are removed
from signal mask.

\mltypecase{SIG\_SETMASK} the signals \ml+sigs+ are exactly the 
signals to be blocked.
\end{mltypecases}
%
A typical usage of \ml+sigprocmask+ is to mask certain
signals temporarily.

%
\begin{lstlisting}
let old_mask = sigprocmask cmd sigs in 
(* do something *)
let _ = sigprocmask SIG_SETMASK old_mark
\end{lstlisting}
%
Often, one has to guard against possible errors by using
the following outline:

%
\begin{codefile}{sign.ml}
open Unix;;
let tmp cmd sigs = 
\end{codefile}
%
\begin{listingcodefile}{sign.ml}
let old_mask = sigprocmask cmd sigs in 
let treat () = ((* do something *)) in
let reset () = ignore (sigprocmask SIG_SETMASK old_mask) in
Misc.try_finalize treat () reset ()
\end{listingcodefile}

\section{Signals and system calls} 

Any signal that is not ignored can potentially interrupt 
certain system calls.  Generally speaking, these system calls are 
known as \emph{slow} calls, which can take an arbitrary length of time (for
example, terminal I/O, \syscall{select} -- see below, \syscall{system}, \etc).
If an interruption occurs, the system call is not completed and
returns exception \ml+EINTR+.  File I/O is not interruptible:
although these operations can suspend the running process to 
execute another process for disk I/O, when this occurs the interruption
will always be brief if the disk functions correctly.  In particular, 
the throughput of data depends only on the system, and not another user's
process.

Ignored (masked) signals are never delivered.  For unmasked 
signals, it is important to guard against any potentially 
unwanted interruptions.

A typical example is a parent waiting for the termination of a child.
In this case, the parent executes \ml+waitpid [] pid+ where \ml+pid+ 
is the process ID of the child.  This is a blocking system call and 
is therefore \emph{slow}, which means it could be stopped by the 
arrival of a signal.  Specifically, the \ml+sigchld+ signal is sent 
to the parent concerning the terminated child process.

The module \ml+Misc+ contains the function
\ml+restart_on_EINTR+ of type \ml+('a -> 'b) -> 'a -> 'b+ which
makes it possible to repeat a system call when it is stopped
by a signal, \ie{} when the \ml+EINTR+ exception is raised.

%
\begin{codefile}{misc.mli}
val restart_on_EINTR : ('a -> 'b) -> 'a -> 'b
(** [restart_on_EINTR f x] calls [f x] repeatedly until it does not fail
with [EINTR] *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let rec restart_on_EINTR f x = 
  try f x with Unix_error (EINTR, _, _) -> restart_on_EINTR f x
\end{listingcodefile}
\label{restart_on_EINTR}%
To wait on a child correctly one simply writes
\ml+restart_on_EINTR (waitpid flags) pid+.

\begin{example}
The parent can also recover children asynchronously, specifically
when their return value does not necessitate continued execution.
This is accomplished by executing a function \ml+free_children+ upon
receiving the \ml+sigchld+ signal signal.  We find this general function 
described in the \ml+Misc+ library.


%
\begin{codefile}{misc.mli}
val free_children : int -> unit
(** [free_children signal] free all zombie children of the current process, 
    discarding their exit status. *)
\end{codefile}
%
\begin{listingcodefile}{misc.ml}
let free_children signal = 
  try while fst (waitpid [ WNOHANG ] (-1)) > 0 do () done 
  with Unix_error (ECHILD, _, _) -> ()
\end{listingcodefile}
%
This function executes \ml+waitpid+ in non-blocking mode 
(option \ml+WNOHANG+) and for each thread, repeats
the call when a child returns.  It stops when there are
no more live threads (zero is returned to the \ml+pid+ of the
original process) or when there are no more threads
(\ml+ECHILD+ exception).  When the process receives the \ml+sigchld+ 
signal, it is not possible to know the number of completed processes, 
especially if the signal is received several times within a short 
period of time -- the parent \quotes{sees} only one signal.  Note that it 
is not important to guard against the \ml+EINTR+ signal because 
\ml+waitpid+ is non-blocking when called with the \ml+WNOHANG+ option.

In other cases, this signal cannot be ignored: the associated 
action will release all completed threads, in a non-blocking way --
one never knows how much time may have elapsed during the signal 
generation.
\end{example}

\begin{example}
The function \ml+system+ in the \ml+Unix+ module is simply defined as: 

\begin{lstlisting}
let system cmd = match fork () with
  | 0 -> begin try
          execv "/bin/sh" [| "/bin/sh"; "-c"; cmd |]
         with _ -> exit 127 
         end
  | id -> snd (waitpid [] id);;
\end{lstlisting}

The assertion following the system call \ml+execv+ corrects an
erroneous restriction on the type of the return value of the
\ml+execv+ function (in versions equal to or earlier than 3.07).
As the system call did not return, no constraint could relate to the
returned value, and of course, the assertion could not be
carried out.

The specifications of the standard C library state that the parent
should be unaware of the \ml+sigint+ and \ml+siquit+ signals and masks
the \ml+sigchld+ signal during the command's execution.  
That makes it possible to stop or kill a child process without
affecting the main program's execution.

We prefer to define the function \ml+system+ as a specialization of the
more general function \ml+exec_as_system+ which does not make it
mandatory to carry out the order with the shell. We place it in the
\ml+Misc+ module.

%
\begin{codefile}{misc.mli}
val system : string -> process_status
(** [system cmd] behaves as [Unix.system cmd] except that [sigchld] is
blocked and [sigint] and [sigquit] are ignored during the execution 
of the command [cmd] *)

val exec_as_system : ('a -> process_status) -> 'a -> process_status
(** [system exec args] behaves as [system cmd] except that it takes as
arguments a function [exec] and arguments [args] to be passed to [exec]
to start in the new process. In particular, [system] is an abbreviation for 
[exec_as_system (execv "/bin/sh") \[|"-c"; cmd; |\] v]. *)
\end{codefile}
%
\begin{codefile}{misc.ml}
open Sys;;
open Unix;;
\end{codefile}
%
\begin{listingcodefile}[style=numbers]{misc.ml}
let exec_as_system exec args = 
  let old_mask = sigprocmask SIG_BLOCK [ sigchld ] in 
  let old_int = signal sigint Signal_ignore in 
  let old_quit = signal sigquit Signal_ignore in 
  let reset () =
    ignore (signal sigint old_int); 
    ignore (signal sigquit old_quit);
    ignore (sigprocmask SIG_SETMASK old_mask) in
  let system_call () = 
    match fork () with
    | 0 -> 
        reset (); $\label{prog:sreset}$
        begin try 
          exec args 
        with _ -> exit 127 
        end
    | k -> 
        snd (restart_on_EINTR (waitpid []) k) in
  try_finalize system_call () reset ();; $\label{prog:stry}$

let system cmd = 
  exec_as_system (execv "/bin/sh") [| "/bin/sh"; "-c"; cmd |];;
\end{listingcodefile}
%

Note that the signal change must be made before the call to \ml+fork+ is
executed.  Immediately afterwards only one of the two processes
(generally the child) will remain.  During the period where the child
takes control of the flow of execution, the parent could receive signals
(in particular \ml+sigchld+) if the child were to finish immediately.  As a
result, it is necessary to supply signals with their initial values in
the child before executing the command in line~\ref{prog:sreset}.
Indeed, all ignored signals are preserved by \ml+fork+ and \ml+exec+
and their behavior is preserved by \ml+fork+.  The
\ml+exec+ system call normally supplies signals with their default values, except
where the default behavior is to ignore the
signal.

Finally, the parent must supply signals with their initial values
immediately after executing the call, including error trapping, by 
using the command \ml+try_finalize+ in line~\ref{prog:stry}.
\end{example}


\section{The passage of time}

\subsection*{Legacy approach to time}

Since the earliest versions of Unix, time has been counted in seconds.
For compatibility reasons, therefore, one can always measure time in seconds.
The current time is reckoned in the number of seconds since January 1, 1970
at \ml+00:00:00 GMT+.  It is returned by the function:

%
\begin{listingcodefile}{tmpunix.mli}
val $\indexlibvalue{Unix}{time}$ : unit -> float
\end{listingcodefile}
%

The \syscall{sleep} system call can pause the execution of a program
for the number of seconds specified in its argument:
%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{sleep}$ : int -> unit
\end{listingcodefile}
%

However, this function is not primitive. It is programmable with 
more elementary system calls using the function alarm (see 
above) and \ml+sigsuspend+: 

%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{sigsuspend}$ : int list -> unit
\end{listingcodefile}
%

The \ml+sigsuspend l+ system call temporarily suspends the signals in the 
list \ml+l+ and then halts the execution of the program until the reception 
of a signal which is not ignored or suspended (on completion, the 
signal mask is returned to its old value).

\begin{example}

Now we may program the \ml+sleep+ function:
%
\begin{codefile}{sleep.ml}
open Sys;;
open Unix;;
\end{codefile}
%
\begin{listingcodefile}[style=numbers]{sleep.ml}
let sleep s = 
  let old_alarm = signal sigalrm (Signal_handle (fun s -> ())) in $\label{prog:sold}$
  let old_mask = sigprocmask SIG_UNBLOCK [ sigalrm ] in
  let _ = alarm s in
  let new_mask = List.filter (fun x -> x <> sigalrm) old_mask in
  sigsuspend new_mask; 
  let _ = alarm 0 in
  ignore (signal sigalrm old_alarm); 
  ignore (sigprocmask SIG_SETMASK old_mask)$\label{prog:ssigproc}$;;
\end{listingcodefile}
%

Initially, the behavior of the \ml+sigalarm+ signal is to do nothing.  Note
that \quotes{doing nothing} is the same as ignoring the signal.  In
the second instance, the process would not be awakened by the reception
of the signal. The \ml+sigalarm+ signal is put in a non-blocking
state.  Then the process is put on standby by suspending all other
signals which were not already suspended (\ml+old_mask+). After the alarm
is signalled, the preceding modifications are erased. (Note that
line~\ref{prog:ssigproc} could be placed immediately after
line~\ref{prog:sold} because the call to \ml+sigsuspend+ preserves
the signal mask.)

\end{example}

\subsection*{Modern times}

In more modern versions of Unix, time can also be measured in microseconds.
In OCaml, time measured in microseconds is represented as a float.  
The \syscall{gettimeofday} function is the equivalent of the \ml+time+ 
function for modern systems.

%
\begin{listingcodefile}{tmpunix.mli}
val $\libvalue{Unix}{gettimeofday}$ : unit -> float
\end{listingcodefile}

\subsection*{Timers}
In present-day Unix each process is equipped with three timers, each
measuring time from a different perspective.  The timers are:

%
\begin{mltypecases}
\mltypecase{ITIMER\_REAL} real time (\ml+sigalrm+)
\mltypecase{ITIMER\_VIRTUAL} user time (\ml+sigvtalrm+)
\mltypecase{ITIMER\_PROF} user time and system time (\ml+sigprof+)
\end{mltypecases}
% 
The state of a timer is described by the \ml+interval_timer_status+
type which is a record with two fields (each a \ml+float+)
representing time:
%
\begin{itemize}
\item The field \ml+it_interval+ indicates the length of the time 
being measured
\item The field \ml+it_value+ is the current value of the timer; 
when it returns \ml+0+ the signal \ml+sigvtalarm+ is sent and 
the timer is reset to the value in \ml+it_interval+.
\end{itemize}
%
A timer is therefore inactive when its two fields are \ml+0+.  
The timers can be queried or modified with the following functions:
%
\begin{codefile}{tmpunix.mli}
type interval_timer = Unix.interval_timer
type interval_timer_status = Unix.interval_timer_status
\end{codefile}
%
\begin{listingcodefile}{tmpunix.mli}
val getitimer : interval_timer -> interval_timer_status
val setitimer : 
    interval_timer -> interval_timer_status -> interval_timer_status
\end{listingcodefile}
%

The value returned by \ml+settitimer+ is the old value of 
the timer at the time of the modification.

\begin{exercise}[noanswer]

To manage serveral timers, write a module having the following interface:
%
\begin{listingcodefile}{timers.mli}
module type Timer = sig
  open Unix
  type t
  val new_timer : interval_timer -> (unit -> unit) -> t
  val get_timer : t -> interval_timer_status
  val set_timer : t -> interval_timer_status -> interval_timer_status
end
\end{listingcodefile}
%

The function \ml+new_timer k f+ should create a new timer of the 
timer-type \ml+k+ starting the action \ml+f+, inactive at its creation with 
the function \ml+set_timer t+ allowing the regulation of the timer \ml+t+ 
(returning the old value). 

\end{exercise}

\subsection* {Date calculations}

Modern versions of Unix also provide libraries of functions dedicated
to date handling, see the structure \libtype{Unix}{tm} which allows
dates and times to be expressed according to a calendar (year, month,
\etc) and the conversion functions: \indexlibvalue{Unix}{gmtime},
\indexlibvalue{Unix}{localtime}, \indexlibvalue{Unix}{mktime}, \etc

\section{Problems with signals}

Owing to their asynchronous nature, the use of signals for interprocess communication 
presents some limitations and difficulties:
%
\begin{itemize}

\item Very little information is transmitted -- the signal's
type and nothing else.

\item A signal may occur at any point during the execution 
of the program, therefore, a function associated with the receipt 
of a signal should not generally modify the data structures of 
the main program because the main program may be interrupted 
unexpectedly with the modification of a structure.  If necessary,
the entire program must be protected from the type of contention that
results from actions associated with a signal.

\item The use of signals requires taking into account the 
possibility that long system calls might stop the execution of the 
main program, even if the signals keep their default behavior.

\item The functions associated with a standard library must always 
consider the possibility of signal use and guard against system 
call interruption.

\end{itemize}
%

Signals offer only a limited form of asynchronous communication but
carry all the difficulties and problems associated with it. If possible,
it is therefore better not to use them. For example, to wait for a small
amount of time, \indexvalue{select} can be used instead of alarms. But
in certain situations signals must be taken into account (for example in
command line interpreters).

Signals are possibly the least useful concept in the Unix system.  On
certain older versions of Unix (System V, in particular) the behavior
of a signal is initially associated with
\ml+Signal_default+ when it is received.  This function can of course
be made to perform the proper behavior, thus, in the \quotes{beep}
example above, it would be necessary to write:

\begin{lstlisting}
let rec beep _ =
  set_signal sigalrm (Signal_handle beep);
  output_char stdout '\007'; flush stdout;
  ignore (alarm 30);;
\end{lstlisting}

However, the problem takes place when signals are received between the
instant the behavior is automatically trapped by \ml+Signal_default+
and the moment the \ml+set_signal+ function is carried out.  
Any signals received during this interval are not treated correctly 
(according to the type of the signal): they may be inadvertently 
ignored or might cause the process to crash, instead of carrying 
out the associated function.

Other flavors of Unix (BSD or Linux) treat the 
signals more consistently: the behavior associated with a 
signal is not altered when it is received, and while a particular 
signal is being handled, other signals of the same type are put on standby.

